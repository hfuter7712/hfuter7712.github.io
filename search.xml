<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[计算机组成原理期末复习（一）]]></title>
    <url>%2Fhfuter7712.github.io%2F2019%2F12%2F05%2Freview1%2F</url>
    <content type="text"><![CDATA[——————————总线——————————总线如何传输信息总线是共享的，如何判优总线的两种传输方式同步，异步，半同步，分离式通信 ——————————存储器————————————计算机最重要的两个部件:主存和半导体存储器?磁表面存储器?不关注材料存储单元为什么计算机会把存储器分成多个层次结构？主存RAM 随机访问存储器如何进行编址按字节编址或按字编址存储矩阵动态RAM：刷新Cache原理Cache出现的理论依据程序访问的局部性原理 三种映射方式直接映射，组相联映射，全相联映射 如何提高访问速度高位交叉，低位交叉 如何校验海明码分组的奇偶校验检错一位，矫正一位检错两位，矫正一位 磁道如何解决磁道扇区如何把主存中的01序列转化为磁盘中的01序列通过电流产生磁场来进行磁化 虚拟存储器主要原理解决的主要是容量问题 ——————————输入输出系统——————————软件涉及到IO指令的编址硬件涉及到接口 接口与端口的区别 DMA跟中断有很多似乎相似又不相似的地方 ——————————计算机的运算方法————————————操作数无符号数和有符号数机器数原码，反码，补码，移码 浮点数和定点数阶码浮点数的规格化定点数的移位运算，加法运算乘法运算，除法运算 补码乘法补码一位乘 浮点运算对阶规格化 IEEE 754标准 ——————————指令系统——————————操作码扩展操作码技术地址码零地址，一地址，二地址，三地址 寻址方式数据寻址方式如果采用某种寻址方式询问有效地址和操作数？8020规律 ——————————CPU的结构和功能——————————四大结构五大功能中断系统设计一个中断系统需要考虑哪些问题如何寻找中断的入口如何写中断服务程序在中断中出现新的中断该怎么办 ——————————控制单元的控制和设计——————————输入输出是什么根据输出发出输出命令需要发出那些命令 组合逻辑控制器和微程序控制器微程序控制器的设计不考，但是要理解概念 讲完了？不就这点东西，如有遗漏，考试考了概不负责但是实验相关的内容也会考单周期CPU多周期CPU]]></content>
      <categories>
        <category>specialized-course</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Verilog语言学习（二）]]></title>
    <url>%2Fhfuter7712.github.io%2F2019%2F11%2F21%2Fverilog2%2F</url>
    <content type="text"><![CDATA[wire表示Verilog之间的物理连线,一般使用持续赋值assign赋值 reg只能在always语句和initial语句中被赋值 数组reg[15:0] reg_file[0:31]表示32个16位的寄存器构成的寄存器堆 always与initial只有reg类型数据可以在这两种语句中进行赋值 always@* begin表示所有的输入中任意一个值改变，就执行下列begin开始end结束的程序段 赋值语句1.阻塞型过程2.非阻塞型过程3.连续赋值语句 测试模块非常重要包括以下内容:1.测试模块中要调用设计块2.测试模块中要包含测试的激励信号激励信号（输入到待测试模块的信号）必须是reg类型输出信号要定义成wire类型 3.]]></content>
      <categories>
        <category>Coding(hardware)</category>
      </categories>
      <tags>
        <tag>Verilog</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Verilog语言学习]]></title>
    <url>%2Fhfuter7712.github.io%2F2019%2F11%2F12%2Fverilog1%2F</url>
    <content type="text"><![CDATA[模块是Verilog的基本描述单位说明部分用于定义不同的项，例如模块描述中使用的寄存器和参数语句定义设计的功能和结构，说明部分和语句可以散步在模块中的任何地方 input 定义输入端口input A,B; output 定义输出端口output C,D; 如果没有数据类型说明的话，端口默认为线网数据类型 initial语句initial语句只执行一次 always语句该语句总是反复执行/重复执行上述两种语句中只有寄存器类型的数据能够被赋值寄存器类型数据在被赋新值前保持原有值不变，所有的初始化语句与always语句在0时刻并发执行 case语句在Verilog中没有switch,只有caseexample: case(target) 8&apos; d0: result = 3&apos; b001 ; 8&apos; d1: result = 3&apos; b010 ; 8&apos; d2: result = 3&apos; b100 ; default: result = 3&apos; b000 ; endcase 不需要break,每执行完一个case分项后的语句就会跳出该case语句的执行 wirewire型数据常用来表示以assign关键字指定的组合逻辑信号，模块的输入输出端口类型都默认为wire型wire相当于物理连线,无逻辑连线，不带逻辑性默认初始值为z assign语句中必须定义为wire不能是reg reg a,b; wire test_result; assign test_result = a&amp;&amp;b; 如果将test_result定义为reg,则会报错 reg表示寄存器类型，用于always模块内被复制的信号，必须定义为reg型，代表触发器常用于时许逻辑电路，reg相当于存储单元默认初始值为x 参考:https://blog.csdn.net/u010549444/article/details/50993274?utm_source=copyhttps://max.book118.com/html/2018/0220/153942558.shtm 如何进行仿真点击Window中的Library,点击其中的work,点击要进行模拟的文件，右键选择”Simulate”进入界面选自需要的Objects右键选择“Add to”随后选择“Wave”随后选择“Selected Signals”随后在上面的按钮组中选择”Run All”,点击Wave即可看到结果 随后在Transcript中输入quit -sim退出仿真]]></content>
      <categories>
        <category>Coding(hardware)</category>
      </categories>
      <tags>
        <tag>Verilog</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++程序设计——如何将一个整数转化为字符串]]></title>
    <url>%2Fhfuter7712.github.io%2F2019%2F11%2F09%2Fpat1%2F</url>
    <content type="text"><![CDATA[如何将一个整数转化为字符串呢这里要运用到一个头文件#include&lt;sstream&gt;随后如下所示键入代码 int sum; //需要转换的整数 std::string result; //目标字符串 std::stringstream ss; //定义字符串流 ss&lt;&lt;sum; ss&gt;&gt;result; 这样就很快捷的将整数sum转化为了字符串result比较省力(没有具体研究它的时间复杂度)]]></content>
      <categories>
        <category>Coding(Algorithm)</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>PAT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NLP自然语言处理学习(二)]]></title>
    <url>%2Fhfuter7712.github.io%2F2019%2F11%2F01%2FNLP2%2F</url>
    <content type="text"><![CDATA[本博文重点：加工原料文本默认使用以下import from __future__ import division import nltk, re, pprint]]></content>
      <categories>
        <category>Coding(New Area)</category>
      </categories>
      <tags>
        <tag>NLP</tag>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NLP自然语言处理学习(一)]]></title>
    <url>%2Fhfuter7712.github.io%2F2019%2F10%2F26%2FNLP1%2F</url>
    <content type="text"><![CDATA[来自PYTHON自然语言处理(IDE为pycharm,使用python3) import nltk print(nltk.download()); 可以启动NLTK下载器下载显示为book的项目（是NLTK的图书集)下载完成后from nltk.book import *搜索文本text.concordance(&quot;目标词语&quot;) 可以显示指定单词出现的所有位置example:print(text1.concordance(&quot;monstrous&quot;) 同样可以将该词换成其他的单词进行搜索如果在指定的书中未查找到对应单词，会显示no matches text.similar(&quot;目标词语&quot;)用于查找具有和目标词语有着相似上下文的词语 text.common_contexts([&quot;目标词语1&quot;,&quot;目标词语2&quot;]) 查找两个或两个以上的词的共同的上下文 离散图绘制text.dispersion_plot([&quot;词1&quot;,&quot;词2&quot;,&quot;词3&quot;])可以绘制出当前文本中这些对应词的里三分部从文本开头算起在它们前面有多少词（相对位置)注意:需要NumPy中的Matplotlib包（明显风格) 生成随机文本text.generate()它会产生对应文本风格的随机文本,该随机文本重用了源文本中常见的词和短语,从而体现出它的内容 词数统计len(text)可以输出文本从头到尾的长度，包括单词和标点符号set(text)获取文本的词汇表sorted(set(text))将文本词汇表进行排序，各种标点符号打头，而后接的是按顺序的英文字母 一个词类型是指一个词在一个文本中独一无二的出现形式或者拼写所以len(set(text)) 称为唯一项目类型而不是词类，因为其中包含标点符号 text.count(&quot;词&quot;)用这个来计算文本中指定词的出现个数 索引text[index]可以用这种形式来输出以文本为基础内容的链表所对应的位置的词或标点example: print(text4[173])从text4中取出index为174的内容 频率分布FreqDist(text) fdist1 = FreDist(text1) vocabulary1 = fdist1.keys() print(vocabulary1[:50]) 其中输出的内容就是文本中出现次数排名前50的词或者标点符号 输入fdist1.plot(50, cumulative=True)产生plot图，可以看到这五十个词将近占了书的一半 fdist1.hapaxes()该语句可以输出那些在文本中只出现过一次的词 更加细致的选择词 V = set(text1) long_words = [w for w in V if len(w) &gt; 15] print(long_words) 该代码输出文本中长度大于15的单词 fdist5 = FreqDist(text5) print(sorted([w for w in set(text5) if len(w) &gt; 7 and fedist5[w] &gt; 7]) 该段代码筛选出长度大于7并且出现次数超过7的单词 fdist1.freq(n)输出词长为n的词在所有词中占的比重fdist1.freq(3)可以输出词长为3的词在所有词中占的比重 [w for w in sent1 if len(w) == 7]返回一个包含所有长度为7的词的组[w for w in set(text1) if w.startswith(&#39;y&#39;)])返回text1中所有以y开头的词[w for w in set(text1) if w.startswith(&#39;ye&#39;)])返回text1中所有以ye开头的词 NLP的局限性在现实世界的应用中已经部署的语言理解系统仍然不能进行常识推理或以一种一般的可靠的方式描绘这个世界的知识 获取文本语料库——————古腾堡语料库——————包含大约36000以上的免费电子图书 import nltk print(nltk.corpus.gutenberg.fileids()) 上述代码输出古腾堡语料库中的文件标识符 print(len( nltk.corpus.gutenberg.words(&#39;austen-emma.txt&#39;)))输出古腾堡语料库中特定文件标识符中包含的词数 其实可以直接从nltk.corpus中import古腾堡进来from nltk.corpus import gutenbergprint(gutenberg.words(&#39;austen-emma.txt&#39;)这样可以更简便的输出 每个文件标识符中平均字长:len(guteberg.raw(fileid)/gutenberg.words(fileid))平均句长:len(guteberg.words(fileid)/gutenberg.sents(fileid))文本中每个词出现的平均次数len(guteberg.words(fileid)/gutenberg.vocabs(fileid)) 可以看出len(guteberg.words(fileid)是文本中所有词的数量len(guteberg.sents(fileid)是文本中所有句子的数量len(guteberg.vocabs(fileid)是文本中所有词汇的数量(一个词多次出现也按1次计算) ——————布朗语料库——————from nltk.corpus import brown是第一个百万词级的英语电子语料库包含500个不同来源的文本，按照文体分类 ——————停用词语料库——————from nltk.corpus import stopwords通常就是那些高频词汇，几乎没什么词汇内容，并且它们的出现会使得区分文本变得更加困难 ——————比较词表——————from nltk.corpus import swadesh包含了几种语言中约200个常用词的列表编码：ISO639双字母码 列表函数tabulate(conditions,sample,cumulative)conditions可以选择要输出哪些内容sample可以限定输出范围，比如range(10)为输出到10为止的内容cumulative可以设定是否累计(True/False)cfd.tabulate(conditions=[&#39;English&#39;,&#39;German_Deutsch&#39;],sample=range(10),cumulative=False) 可以同样应用到plot函数中cfd.plot(conditions=[&#39;English&#39;,&#39;German_Deutsch&#39;],cumulative=False) 词汇工具 Toolbox可能是最流行的语言学家用来管理数据的工具toolbox.entries()可以查看条目 WordNet是面向语义的英语词典同义词:wn.synsets()synsets即为同义词集 WordNet的同义词集对应于抽象的概念，它们并不总是有对应的英语词汇，这些概念在层次结构中相互联系在一起 概念阐述：上位词:指概念上外延更广的主题词下位词:指概念上内涵更窄的主题词比如“奔驰”是“汽车”的下位词“手机”是“智能手机”的上位词 · 蕴含动词之间有着蕴含的关系，比如“eat”蕴含着“swallow”以及“chew”wn.synset().entailments()example:wn.synset(&#39;walk.v.01&#39;).entailments() · 反义词wn.lemma(&#39;rush.v.01.rush&#39;).antonyms() 用dir() 查看词汇关系和同义词集上定义的其他方法 · 语义相似度可以通过查找每个同义词集深化这个一般性概念:wn.synset(&#39;baleen_whale.n.01&#39;).min_depth()WordNet同义词集上定义了类似的函数能够深入的观察right.path_similarity(minke)可以得出right所表达词汇以及minke所表达词汇的相似度比如你要对比一个词汇”东北虎”，相比”华南虎”和”孟加拉虎”来说，如果你将其和”教科书”进行相似度对比，那相似度肯定是远远小于上述这些虎的]]></content>
      <categories>
        <category>Coding(New Area)</category>
      </categories>
      <tags>
        <tag>NLP</tag>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue.js学习（一）]]></title>
    <url>%2Fhfuter7712.github.io%2F2019%2F10%2F04%2FVue1%2F</url>
    <content type="text"><![CDATA[来自菜鸟教程https://www.runoob.com/vue2/vue-tutorial.html是一套构建用户界面的渐进式框架 CDN如下https://cdn.staticfile.org/vue/2.2.2/vue.min.js 首先需要通过实例化Vue var vm=new Vue({ //选项 }) elVue构造器中的一个参数，是DOM元素中的idexample:el: &#39;#my_id&#39;data用于定义属性 data:{ site:&quot;google&quot;, url&quot;www.google.com&quot; }, method用于定义函数，可用return来返回函数值 method:{ detail:function(){ return this.site+&quot;添加文本内容&quot;; } } 双大括号用于输出对象属性和函数返回值 &lt;h1&gt;{{site}}&lt;/h1&gt; &lt;h1&gt;{{details()}}&lt;/h1&gt; 当data中引用了部分外界的原始数据，当改变Vue实例中这些对应的数据时，原始数据也会跟着一起改动，同理，当原始数据改动时，Vue实例中的数据也会一起改变 指令v-html可用于输出html代码 &lt;div v-html=&quot;test&quot;&gt;&lt;/div&gt; 在Vue对象中的data： data:{ test:&apos;&lt;h1&gt;夜夜夜&lt;/h1&gt;&apos; } 将会展示一个一级标题夜夜夜如下图 夜夜夜 v-bind用于HTML属性中的值&lt;a v-bind:href=&quot;url&quot;&gt;就将该链接改成了Vue实例中url data所对应的的url v-if如果所绑定的值为true,则显示该元素，否则不显示&lt;p v-if=&quot;seen&quot;&gt;测试&lt;/p&gt;如果seen为true,则会显示文本“测试” v-else跟在v-if后面，当if和else-if都不满足条件时执行该else v-else-if跟在if后面，其实上面三条语句跟C语言中的if,else if和else语法相同example： &lt;div id=&quot;app&quot;&gt; &lt;div v-if=&quot;type === &apos;A&apos;&quot;&gt; A &lt;/div&gt; &lt;div v-else-if=&quot;type === &apos;B&apos;&quot;&gt; B &lt;/div&gt; &lt;div v-else-if=&quot;type === &apos;C&apos;&quot;&gt; C &lt;/div&gt; &lt;div v-else&gt; Not A/B/C &lt;/div&gt; &lt;/div&gt; v-on用于监听DOM事件&lt;a v-on:click=&quot;thingFirst&quot;&gt; v-model可以在指定的表单控件元素上创建双向数据绑定，也就是说，通过榜单中输入值，借助这个指令可以更新Vue实例中data的值&lt;input v-model=&quot;message&quot;&gt; 指令缩写v-bind&lt;a v-bind:href=&quot;url&quot;&gt;&lt;/a&gt;缩写:&lt;a :href=&quot;url&quot;&gt;&lt;/a&gt; v-on&lt;a v-on:click=&quot;thingA&gt;&lt;/a&gt;缩写&lt;a @click=&quot;thingA&gt;&lt;/a&gt; 循环语句v-for可以让data中的数组循环渲染 &lt;ol&gt; &lt;li v-for=&quot;site in sites&quot;&gt; {{site.name}} &lt;/li&gt; &lt;/ol&gt; 在Vue实例中的data中的sites sites:[ {name:&apos;first&apos;}, {name:&apos;second&apos;}, {name:&apos;third&apos;} ] 渲染出来的效果就是一个有序列表，分别对应着 1.first 2.second 3.third 个人感觉很适合大量数据的列表显示还可以循环整数 &lt;ul&gt; &lt;li v-for=&quot;n in 10&quot;&gt; {{n}} &lt;/li&gt; &lt;/ul&gt; 计算属性computed computed:{ reverseMessage:function(){ return this.message.split(&apos;&apos;).reverse().join(&apos;&apos;) } } 与method的区别（来自菜鸟教程）:效果是一样的，但是computed是基于它的依赖缓存，只有相关依赖发生改变的时候才重新取值，而methods在重新渲染的时候函数会重新调用执行 监听属性watch可以通过watch来响应数据变化 vm.$watch(&apos;v-model所绑定的变量&apos;,function(before,after){ console.log(&quot;之前的值为:&quot;+before+&quot; 之后的值为:&quot;+after); }); 样式绑定&lt;div v-bind:class=&quot;{active: isActive}&quot;&gt;&lt;/div&gt;在Vue实例data中定义isActive为true或者false可以将该div的类设置为active或者解除设定，若isActive为true，则相当于如下&lt;div class=&quot;active&quot;&gt;&lt;/div&gt; 表单复选框&lt;input v-model=&quot;checkbox&quot; v-model=&quot;checked&quot;&gt; &lt;input type=&quot;checkbox&quot; id=&quot;google&quot; value=&quot;google&quot; v-model=&quot;selectNames&quot;&gt; &lt;input type=&quot;checkbox&quot; id=&quot;baidu&quot; value=&quot;baidu&quot; v-model=&quot;selectNames&quot;&gt; &lt;input type=&quot;checkbox&quot; id=&quot;yahoo&quot; value=&quot;yahoo&quot; v-model=&quot;selectNames&quot;&gt; 在Vue实例中定义data selectNames:[],然后在前面表单后方键入如下代码&lt;p&gt;&lt;/p&gt;即可看到其中显示自己已经选中的值比如选中google与百度显示如下[google,baidu] Vue最强大功能:组件组件可以扩展HTML元素，封装可以重复使用的代码注册一个全局组件语法格式如下:Vue.component(tagName,option)注册完成后可以用以下方式来调用组件&lt;tagName&gt;&lt;/tagName&gt; 局部组件 &lt;script&gt; var Target={ template:&apos;&lt;h1&gt;模板组件1&lt;/h1&gt; }; new Vue({ el:&apos;#app&apos;, components:{ &apos;test&apos;:Target } }); 这样&lt;test&gt;&lt;/test&gt;组件就只能在id为app的Vue实例里使用了 自定义指令注册一个全局自定义指令 Vue.directive(&apos;focus,{ inserted:function(el){ el.focus() } }) 这样当页面载入时，标签上有v-focus的元素自动获得焦点]]></content>
      <categories>
        <category>Coding(Front End)</category>
      </categories>
      <tags>
        <tag>css</tag>
        <tag>Javascript</tag>
        <tag>html</tag>
        <tag>Vue.js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Node.js学习（五）through腾讯网课（五）]]></title>
    <url>%2Fhfuter7712.github.io%2F2019%2F10%2F04%2FnodeJS5%2F</url>
    <content type="text"><![CDATA[网络基础TCP/IP协议七层网络协议 DNS服务器IP地址很重要，可以访问一个虚假的IP地址，也可已改变现有域名指向的IP地址，比如将百度改为一个Hello World的界面 服务器首先引入http模块var http=require(&#39;http&#39;); 创建服务器var server=http.createServer(); 监听request请求事件 server.on(&apos;request&apos;,function(req,res){ //req:请求对象，包含了所有客户端请求的数据，请求头和请求主体 //res:响应对象，包含所有服务器端发送给客户端的数据，响应头和响应主题 res.write(&apos;&lt;h1&gt;Woc&lt;/h1&gt;&apos;); }); 监听端口 server.listen(80,function(){ console.log(&apos;服务器正在运行&apos;); }); 上述是监听80端口 在cmd中输入netstat -a可以查看当前电脑中的所有活动接口 netstat -ab可以查看是谁占用了哪些端口（需要管理员权限） req.url可以根据不同的请求来获取不同的html数据与页面 HTTP响应状态码http协议规定的服务器响应数据时的状态编码1xx 普通消息，无特殊含义2xx 表示服务器响应成功200 OK3xx 表示重定向301 永久重定向302 临时重定向304 使用缓存4xx 无法访问403 服务器理解请求，但是拒绝执行404 资源找不到5,6字头 服务器执行有错500 服务器端代码有错502 网关错误503 服务器已崩溃 状态码的使用res.writeHead(200,{&quot;Content-Type&quot;:&quot;text/html;charset=utf-8&quot;);res.writeHead(状态码，响应头对象); 响应头Content-Type 响应的文件类型text-html默认编码:系统编码，GBK编码然而Node.js里面写的中文都是utf-8编码，因此未声明编码的话就会产生乱码Content-Length 响应内容的长度如果响应内容长度和指定响应内容长度相同的话，就没有问题，加入内容长度为52字节，设定Length为53的话，将会不停的等待（浏览器上面会有转圈圈的标志） MIME类型MIME类型可以认为是文件类型的表述 常见的MIME类型.html text/html.css text/css.js text/javascript.jpg image/jpeg.png image/png.gif image/gif.json text/json application/json.xml text/xml.mp3.mp4 video/mpeg.pdf application/pdf.zip application/x-zip 后端可以生成任意规格的文件]]></content>
      <categories>
        <category>Coding(Back End)</category>
      </categories>
      <tags>
        <tag>Javascript</tag>
        <tag>Node.js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Node.js学习（四）through腾讯网课（三）]]></title>
    <url>%2Fhfuter7712.github.io%2F2019%2F10%2F03%2FnodeJS4%2F</url>
    <content type="text"><![CDATA[网络网址与http模块 path路径模块是node.js中提供的一个系统模块，用于格式化或拼接一个完整的模块var path=require(&#39;path&#39;); 路径格式化path.normalize(路径);比如说路径中出现诸如./path../相当于进入该文件夹又退出，相当于多余操作，就会进行省略 将多个字符串拼接成一个完整的路径path.join() example: p2=&apos;./day02/hello/zs.html&apos;; console.log(path.join(&apos;code&apos;,p2); 结果显示code/day02/hello/zs.html path.dirname()返回路径中的文件夹部分example:原路径: as/example/1.html文件夹部分:as/example path.basename()返回路径中的文件部分example:原路径:as/example/1.html文件部分:1.html path.extname()返回路径中的扩展名部分原路径:as/example/1.html扩展名部分:.html path.parse()解析路径,返回一个对象包含路径中的每一个对象 { root: &apos;&apos;, dir: &apos;&apos;, base: &apos;c.html&apos;, ext: &apos;.html&apos;, name: &apos;c&apos; } URL统一资源定位符,对网络资源的一种简洁表达式是一个结构字符串 协议://用户名:密码@主机名.名.域:端口号/目录名/文件名.扩展名?参数名=参数值&amp;参数名2=参数值2#hash .gov.cn政府机关 默认端口:80端口 单页面应用http://music.163.com/#/discover/playlist 端口号范围：0~65535所有的网络程序都会占用一个端口1000以下的端口最好不要随便用 node.js的URL模块在node.js中提供了两套对于url进行处理的API功能1.老的node.js url模块2.新的url模块(WHATWG URL标准模块)var url=require(&#39;url&#39;); 对url进行解析url.parse(&#39;要解析的url值&#39;);上述是老模式 新模式会把url看作一个类var obj=new url.URL(u);新模式可以查询传递的参数更好地获取数据 http协议超文本传输协议，是TCP/IP协议之上的一个应用层是一种请求应答形式的协议，一次请求对应一次应答 细节:定义了浏览器以什么格式向服务器发送请求定义了服务器以什么样式解析浏览器发送过来的数据定义了服务器以什么格式响应数据给浏览器定义了浏览器以什么格式解析服务器响应的数据 软件开发模式1.单机模式打开电脑即可使用，不需要通过网络 2.C/S模式Client / Server需要下载安装以后才能连接网络使用，比如QQ和微信 3.B/S模式浏览器Browser / Server打开网址直接使用，比如谷歌，淘宝 Web客户端使用HTTP协议就可以访问Web服务器上面的内容，Web服务器响应相关的内容 http模块设计成支持协议的许多特性HTTP消息头由一个对象表示 http.get(&#39;url&#39;,function(res){//res为返回对象，接收到服务器响应的所有内容});因为大多数请求都是GET请求而且不带请求主体，所以Node.js提供了该便捷方法用于模仿客户端从服务器获取数据 将网络中的html代码保存到本地res.pipe(fs.createWriteStream(&#39;文件路径&#39;);]]></content>
      <categories>
        <category>Coding(Back End)</category>
      </categories>
      <tags>
        <tag>Javascript</tag>
        <tag>Node.js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java Swing GUI学习(一)]]></title>
    <url>%2Fhfuter7712.github.io%2F2019%2F09%2F27%2FJavaSwingUI1%2F</url>
    <content type="text"><![CDATA[1.GUI组件的左上角坐标默认为(0,0)2.从左上角到右下角，水平坐标x与垂直坐标y增加也就是说其坐标系如下 ——————————————————————&gt;x||||||||y 3.坐标的单位是像素 在执行paint方法时，系统会传递一个指向特定平台的Graphics子类的图形对象g Graphics2D是Graphics的抽象子类 Swing组件实在原来AWT组件上扩展而来的JButtonJCheckBoxJScrollbar都是JComponent类的子类 Component类包含paint,repaint类，可以在屏幕上绘制组件 Container类容纳相关组件包括add方法，用来添加组件包括setLayout方法，用来设置布局 顶层容器(JFrame,JDialog,JApplet)JFrame主窗口JFrame(String title);JFrame f1=new JFrame(String title);创建一个标题为title的主窗口 JDialog JApplet ———————————————————————————————————— 中间层容器(一般用途，特殊用途)一般用途JPanelJScrollPaneJSplitPane等 特殊用途 JPanelJPanel j1=new JPanel();默认使用FlowLayout布局 JScrollPane JToolBar工具栏 ———————————————————————————————————— 原子组件JButton按钮组件JButton button = new JButton(&quot;按钮名称&quot;); JLabel显示文本的组件JLabel label = new JLabel(&quot;文本标签显示内容&quot;); TextAreaTextArea ta=new TextArea(&quot;输入区域默认内容&quot;); JTextField用于输入的文本域JTextField useText = new JTextField(20);参数为column数 JPasswordField和输入文本域类似，，但是输入的信息会以.代替，保证密码(password)的安全性 JMenuBar菜单条JMenuBar jb=new JMenuBar(); ———————————————————————————————————— 布局example:setLayout(new FlowLayout());f.setLayout(new FlowLayout()); BorderLayoutFlowLayoutJPanel默认使用的布局管理器，只是简单地把组件放在一行，若容器不足够容纳所有组件，则新起一行GridLayout按照指定的行数和列数将界面分成格子 BoxLayout将组件放在单一的列或行中 SpringLayout能够精确指定组件之间的间距 CardLayout 内部类可以非常方便的编写事件驱动程序 ———————————————————————————————————— 事件处理鼠标移动，单双击鼠标各个按钮，单击按钮等等Swing通过事件对象来包装事件 事件源与用户进行交互的GUI组件，表示事件来自于哪个组件或者对象 事件监听器负责监听事件并作出响应一个事件源可以注册多个事件监听器，每个监听器又可以对多种事件进行响应通过事件源的addxxxListener方法被注册到某个事件源上要实现事件监听器接口就要实现接口中所有的方法，即便是一对空的花括号也要写,即空方法体也要写如果有Adapter适配器类，那就不需要写空方法体，因为空方法体已经提前实现好了 事件对象封装了有关已发生的事件的信息ActionEvent发生在按下按钮，选择了一个项目，在文本框中按下回车键 ItemEvent ChangeEvent ———————————————————————————————————— 零散实用f.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);设置程序默认关闭功能 f.setSize(350,200);第一个参数为宽度width,第二个参数为高度height f.setVisible(true);设置界面可见]]></content>
      <categories>
        <category>Coding(GUI)</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Swing</tag>
        <tag>GUI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Node.js学习（三）through腾讯网课（二）]]></title>
    <url>%2Fhfuter7712.github.io%2F2019%2F09%2F27%2FnodeJS3%2F</url>
    <content type="text"><![CDATA[section2 回调函数回调函数称为回调，将一个函数a作为参数传入另外一个函数b中，根据时机或者条件决定是否调用a函数 同步与异步同步:上一行执行完以后，下一行才能得到执行异步:将比较复杂的任务以任务线程实现，不用等上一个执行完，下一个也能执行 setTimeout最小时间在Windows上该函数最小执行时间为15ms，因此即便设置setTimeout(fn,0);在windows上也会设置为15ms,苹果系统上为10ms 异步事件轮询机制 异步的实现:1.回调函数2.事件 事件源.on(&#39;事件名称&#39;,回调函数) 3.promise是ES6中新增的承诺对象，用于对异步的操作进行消息的传递状态：Pending 等待中Resolved 成功Rejected 失败 Pending =&gt; ResolvedPending =&gt; Rejected由于异步的时间不可控，所以要用promise来同一控制输出结果example：定义promise对象 var pro1 = new Promise(function(resolve,reject){ fs.readFile(&apos;文件名&apos;,function(err,data){ if(err){ reject(&apos;数据找不到&apos;); }else{ resolve(data.toString()); } }); }); 调用promise对象 p1.then(function(data){ console.log(&apos;数据&apos;,data); }.function(err){ console.log(&apos;error&apos;,err); }); 回调函数不一定是异步，异步一定是回调函数 缓存区在内存中开辟一个临时区域用于存储需要运算的字节码 创建缓存区创建指定长度的缓存区var buf=new Buffer(大小); 按指定字符串建缓存区var buf=new Buffer([]); 写入缓存区buf.write(&#39;字符串&#39;); 读取缓冲区buf.toString(); 复制（将buf1中的内容复制给buf2)buf1.copy(buf2); 文件系统读取文件,由于是服务器程序因此node.js必须要有文件读写操作1.直接读取将所有内容读取完成后才执行回调函数同时也分为异步和同步2.流式读取 读取文件内容fs.readFile(&quot;文件名&quot;,回调函数); fs.readFile(&apos;文件名&apos;,function(err,data){ console.log(data.toString()); }); 上述代码块为异步 几乎所有的fs函数都有同步版本，只要在异步函数后面添加Sync 读取文件信息 fs.stat(&quot;文件名&quot;,function(err,state){ console.log(state); //即输出文件具体信息 }); size:文件大小mtime： 文件修改时间birthtime 文件创建时间 isFile()判断当前查看的对象是否为一个文件 isDirectory()判断当前查看的对象是否为目录 删除文件fs.unlink(path,callback)删除链接即删除但是如果不继续写入内容的话，原内容其实还是在的 回调函数必须手动抛出错误。因为其本身是不会自己抛出错误的 if(err) { throw err; } 删除空目录fs.rmdir() 流 ——读取——一节一节读取，一节是65536字节即64KB创建一个可以读取的流var stream=fs.createReadStream(&#39;文件路径&#39;); ——写入——创建一个可写入的流var stream=fs.createWriteStream(&#39;文件路径&#39;); stream.write(&#39;内容&#39;);向输出流中写入内容stream.end(); 以流的方式写入数据必须显示的声明结束 stream.on(&apos;finish&apos;,function(){ }); 绑定error事件 stream.on(&apos;error&apos;,function(a){ console.log(a); }); 绑定data事件 stream.on(&apos;data,function(a){ //可以输出读取到的数据 }); 管道是node.js中流的实现机制，直接定义一个输出流，导出输入流 可以实现大文件的复制 语法:OutputStream.pipe(InputStream);]]></content>
      <categories>
        <category>Coding(Back End)</category>
      </categories>
      <tags>
        <tag>Javascript</tag>
        <tag>Node.js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[visual studio使用win32学习GUI中的一些小细节]]></title>
    <url>%2Fhfuter7712.github.io%2F2019%2F09%2F25%2Fwin32F%2F</url>
    <content type="text"><![CDATA[WinMain与wWinMainWinMain对应的是多字节字符集（ANSI)wWinMain对应Unicode字符集编译时字符集为ASSI就等同于WinMain,为Unicode时就等同于wWinMain倘若程序中包含中文的话，用wWinMain来源：https://www.cnblogs.com/JettTang/archive/2015/08/21/4748323.html WINAPI与APIENTRY在windef.h头文件中有以下定义#define WINAPI __stdcall#define APIENTRY WINAPI因此WINAPI和APIENTRY实际上是一样的来源:https://blog.csdn.net/VonSdite/article/details/81165308 创建新画笔形式 hp=CreatePen ( int nPenStyle, //画笔样式 int nWidth, //画笔宽度 COLORREF rgbColor //画笔颜色 ); example:hp=CreatePen(PS_SOLID,2,RGB(255,0,0)); 创建画笔后，要用SelectObject函数将其选入设备环境SelectObject(hDC,hp); Polyline从当前位置开始依次用线段链接lpPoints中指定的各点Polyline(hDC,points,6); Arc绘制椭圆弧线 BOOL Arc (HDC hdc, int X1,int Y1, //边框矩形在左上角的逻辑坐标 int X2,int Y2, //边框矩形右上角的逻辑坐标 int X3,int Y3, //椭圆弧起始点坐标 int X4,int Y4 //椭圆弧终止点坐标 ) 文本HFONT为字体的句柄HFONT hF; CreateFont用于自定义字体HFont=CreateFont(...); 设置字体颜色SetTextColor(hdc,crColor);设置背景颜色SetBkColor(hdc,crColor); 获取当前字体信息GetTextMetrics(hdc,&amp;tm);tm是TEXTMETRIC结构，调用该函数时，系统将当前字体的信息拷贝到tm标识的TEXTMETRIC结构中 键盘操作一个汉字占用2个字符，一个英文字母占用一个字节]]></content>
      <categories>
        <category>Coding(GUI)</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>GUI</tag>
        <tag>win32</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[微信小程序开发复习(一)]]></title>
    <url>%2Fhfuter7712.github.io%2F2019%2F09%2F17%2FwechatApp%2F</url>
    <content type="text"><![CDATA[App.js作用： 小程序逻辑撰写App.json作用:小程序公共设置&quot;pages&quot;:[]配置页面路径每个自定义页面都必须在pages页面被注册，否则访问未注册页面会报错 &quot;window&quot;:{}配置窗口表现navigationBarBackgroundColor 导航条背景色navigationBarTitleText 导航条文字navigationBarTextStyle 导航条文字颜色 &quot;tabBar&quot;:{}配置标签导航 &quot;tabBar&quot;: { &quot;selectedColor&quot;: //标签导航选中时文字颜色 &quot;backgroundColor&quot;: //标签导航背景色 &quot;borderStyle&quot;: //标签导航上边框色 &quot;list&quot;:[{ &quot;pagePath&quot;: //跳转页面路径 &quot;text&quot;: //标签导航名称 &quot;iconPath&quot;: //默认时图标 &quot;selectedIconPath&quot;: //选中后的图标 }, { &quot;pagePath&quot;: &quot;text&quot;: &quot;iconPath&quot;: &quot;selectedIconPath&quot;: }] } &quot;networkTimeout&quot;:{}配置网络超时 &quot;debug&quot;:true/false配置debug模式，是否开启 App.wxss作用:小程序公共样式表 utils文件夹存放工具栏的js函数定义完函数之后需要通过module.exports将定义的函数名称注册出来，才能在其他页面使用 App.js 生命周期函数onLaunch函数当小程序初始化完成时，会触发，全局只触发一次 onShow函数当小程序启动，或者从后台进入前台显示时触发 onHide函数当小程序从前台进入后台触发该函数 onError函数用来监听小程序脚本或者API是否发生错误，发生错误时返回错误信息 页面 Page生命周期函数onLoad函数一个页面只会调用一次 onShow函数页面显示，每次打开页面都会调用一次 onReady函数页面初次渲染完成，一个页面只会调用一次，代表页面已经准备妥当 onHide函数页面隐藏,当navigateTo或者底部Tab切换时调用 onUnload函数页面卸载，当redirectTo或者navigateBack时调用 onPullDownRefresh函数监听用户下拉刷新事件 onShareAppMessage用户分享，只有定义了此事件处理函数，右上角才会显示“分享”按钮，用户点击“分享”按钮的时候会调用 自定义函数example: Fun: function() { //函数内容 } 绑定数据用双大括号表示example: 条件渲染wx:if=&quot;&quot;判断是否需要渲染改代码 &lt;block wx:if=&quot;{{true}}&quot;&gt; 内容 &lt;/block&gt; 区块条件渲染 wx:for=&quot;用wx:for绑定一个数组，就可以使用数组中的各项数据重复渲染该组件 &lt;view wx:for=&quot;{{array}}&quot;&gt; {{index}}: {{item.message}} &lt;/view&gt; 区块列表渲染 &lt;block wx:for=&quot;{{[1,1,5,4,1,4]}}&quot;&gt; &lt;view&gt;{{index}}:&lt;/view&gt; &lt;view&gt;{{item}}&lt;/view&gt; &lt;/block&gt; 使用wx:for-index可以指定数组当前下标的变量名使用wx:for-item可以指定数组当前元素的变量名wx:for-index=&quot;idx&quot; wx:for-item=&quot;itemName&quot; wx:key指定唯一标识符 import 和 includeimport引用模板文件include将整个文件除了&lt;/template&gt;之外的进行引用 view视图容器是WXML界面布局的基础组件,和HTML里面的div功能类似 scroll-view可滚动视图允许视图区域内容横向滚动或者纵向滚动 swiper滑块视图容器用来在指定区域内切换内容的显示]]></content>
      <categories>
        <category>Coding(Front End)</category>
      </categories>
      <tags>
        <tag>微信小程序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Node.js学习（二）through腾讯网课（一）]]></title>
    <url>%2Fhfuter7712.github.io%2F2019%2F09%2F17%2FnodeJS2%2F</url>
    <content type="text"><![CDATA[section1：入门 特点：可以用Javascript来搞后端速度很快可以读文件 JS分为两块1.客户端JS，执行在浏览器上2.服务器端JS，执行在服务器 Node.js的包管理工具npm，是全球最大的开源库生态系统Node.js是一个基于Chrome V8引擎 Node.js薪资高，人才少 主流模块规范AMD 异步模块定义CMD(Common Module Definition)Commonjs：采用同步加载文件方式，适用于服务端 ——NodeJs模块基础——nodeJS中所有的功能都是以模块形式存在的，每一个文件就是一个模块模块与模块之间相互独立，若在一个模块中使用另一个模块的内容，就要引入模块，这也会导致那个模块的数据暴露 exports. exports是暴露对象，可以将模块内部的数据暴露到引用出 主模块一个项目只允许有一个主模块，该项目通常命名为main.js index.js app.js package.json是整个项目的启动模块，主模块对整个项目的其他模块进行统筹调度 所有用户编写的代码都自动封装在一个函数中通过console.log(arguments.callee.toString())可以看出用户编写的代码都会封装成一个函数function $ node 01 function (exports, require, module, __filename, __dirname) { // JavaScript Docu ent console.log(arguments.callee.toString()) var obj = require(&apos;./str.js&apos;); console.log(obj); obj.show(); } { str: &apos;asc&apos;, show: [Function] } this is a show 同时可以发现该函数有五个参数exports: 暴露对象，可将模块中的数据暴露给引入的地方require: 引入模块的函数module: 模块对象_filename: 当前模块的文件名_dirname: 当前模块所在的路径 require函数作用：在当前模块里加载另外一个模块 引入模块分类:1.自定义模块2.第三方模块 require的默认路径不在当前目录查找模块的默认路径在node_modules文件夹目录中因此require(&#39;./str.js&#39;);中的./不能省略 https://www.npmjs.com上面包含大量第三方包，也可以在上面上传自己的包 当模块被多次执行时，模块只执行一次，但是返回值赋给每个执行的变量 exports函数暴露，将模块中需要共享给其他模块的数据暴露到引入处exports.属性名=值exports.方法名=函数 exports是module.exports对象的一个引用,不能改指向，只能添加属性和方法 package 包package.json是package的包描述文件s ——如何创建package文件——在命令行中输入npm init将会逐步引导创建版本 x.y.zx:大版本y:中版本z:小版本 package name包名称version版本description描述entry point 入口文件（主文件）dependencies依赖devDependencies开发依赖(开发的时候依赖，使用的时候不依赖，比如某些打包工具)scriptsauthor作者 npm i &lt;包的名称&gt; -g //全局安装 cnpm是一个淘宝NPM镜像,只能下载，不能上传（只读），下载会更快安装npm install -g cnpm --registry=https://registry.npm.taobao.org使用方法:cnpm install &lt;包名称&gt; Node.js作用域模块中使用var 定义的变量为局部作用域，只能在该模块中使用，要在其他模块中使用就要用exports暴露或者使用globalglobal.name=&quot;&quot;即global全局对象]]></content>
      <categories>
        <category>Coding(Back End)</category>
      </categories>
      <tags>
        <tag>Javascript</tag>
        <tag>Node.js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[机器学习笔记(三)]]></title>
    <url>%2Fhfuter7712.github.io%2F2019%2F09%2F11%2FmachineLearn3%2F</url>
    <content type="text"><![CDATA[非线性规律要解决非线性问题，可以创建一个特征组合，特征组合是指通过将两个或多个输入特征相乘来对特征空间中的非线性规律进行编码的合成特性可以将x1与x2组合来创建提个名为x3的特征组合x3=x1x2 在实践中机器学习模型很少会组合连续特征，但是机器学习经常组合独热特征矢量 组合特征矢量所获得的预测能力将远远超过任一特征单独的预测能力 简化正则化可以通过降低复杂模型的复杂度来防止过拟合，这种原则称为正则化 并不是以最小化损失为目标，而是以最小化损失和复杂度为目标，称为结构风险最小化 我们的训练算法是一个由两项内容组成的函数：一个是损失项，用于衡量模型与数据的拟合度一个是正则化项，用于衡量模型复杂度 若模型复杂度是权重的函数，则特征权重的绝对值越高，对模型复杂度的贡献越大 ——L2正则化公式——该公式将正则化项定义为所有特征权重的平方和接近于0的权重对模型复杂度几乎没有影响，而离群值权重则可能会产生巨大的影响 ——lambda——模型开发者通过以下方式来调整正则化项的整体影响用正则化项的值乘以名为lanbda(正则化率)的标量 增加lambda值将增强正则化效果降低lambda的值往往会得出比较平缓的直方图 lambda值过高，模型会很简单，但是将面临数据欠拟合的风险，模型将无法从训练数据中获得足够的信息来做出有用的预测lambda过低，模型比较复杂，将会有过拟合的风险，模型因为获得过多训练数据特点而无法泛化到新数据 理想的lambda值生成的模型具有很好的泛化能力 逻辑回归是一种极其高效的概率计算机制——S型函数——S型函数生成的输出值正好具有输出值始终落在0和1之间的特性 线性回归的损失函数是平方损失逻辑回归的损失函数是对数损失函数 ——正则化——大多数逻辑回归模型会使用以下两个策略之一来降低模型复杂性: L2正则化 早停法 分类为了将逻辑回归值映射到二元类别，必须指定分类阈值（判定阈值） 真正例指模型将正类别样本正确的预测为正类别真负例指模型将负类别样本正确的预测为负类别假正例指模型将负类别样本错误的预测为正类别假负例指模型将正类别样本错误的预测为负类别 ——准确率——准确率是指我们的模型预测正确的结果所占比例Accuracy=(TP+TN)/(TP+TN+FP+FN) TP:真正例TN:真负例FP:假正例FN:假负例 当使用分类不平衡的数据集时，单单准确率一项并不能反映全面情况 ——精确率——精确率=TP/(TP+FP) ——召回率——从数学上来讲召回率=TP/(TP+FN) 要全面评估模型的有效性，必须同时检查精确率和召回率，但是精确率和召回率是此消彼长的情况 一般来说，提高分类阈值会减少假正例，从而提高精确率同时导致真正例的数量减少或者保持不变以及假负例的数量增加或保持不变，因此召回率会保持不变或者下降 ——ROC曲线——又称为接收者操作特征曲线该去线绘制了以下两个参数1.真正例率（TPR）是召回率的同义词TPR = TP/(TP+FN)2.假正例率(FPR)FPR=FP/(FP+TN) ROC曲线用于绘制采用不同分类阈值时的TPR与FPR ——曲线下面积（AUC）——表示“ROC曲线下面积”,就是从(0,0)点到(1.1)点之间整个ROC曲线以下的整个二维面积曲线下面积的取值范围为0-1，预测结果100%错误的模型的曲线下面积为0.0，预测结果百分之100正确的模型的下曲线面积为1.0 AUC以相对预测为依据，因此保持相对排名的任何预测变化都不会对AUC产生影响 ——预测偏差——预测平均值 应当约等于 观察平均值预测偏差就是这两个平均值之间的差值预测偏差= 预测平均值-数据集中相应标签的平均值 添加校验层并非良策，因为修复的是症状，而不是原因，并且会使系统更加脆弱，必须持续更新]]></content>
      <categories>
        <category>Coding(New Area)</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>machine-learning</tag>
        <tag>tensorflow</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python数组中的那些骚操作]]></title>
    <url>%2Fhfuter7712.github.io%2F2019%2F09%2F11%2FpythonArray%2F</url>
    <content type="text"><![CDATA[建立一个新数组，以另外一个二维数组中每行第一个元素组成newArray = [x[0] for x in matrix]example: matrix=[[1,2,3], [4,5,6], [7,8,9]] newArray=[1,4,7]]]></content>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[算法——递归输出全排列(templete)]]></title>
    <url>%2Fhfuter7712.github.io%2F2019%2F09%2F11%2FAlg-Perm%2F</url>
    <content type="text"><![CDATA[给定一串无重复字符串的序列如[1,2,3,4,7,9]如何输出其全排列先从简单的例子开始[1,2,3]全排列依次为[1,2,3],[2,1,3],[3,2,1],[3,1,2],[1,3,2],[2,3,1]这个模板是用交换来实现的具体过程: [2,3,1] [2,1,3] [1,2,3] [3,2,1] [3,1,2] [1,3,2] 首先定义递归函数Perm(Array,m,n)m是起始index,n是终止index然后开始循环交换递归 for(int i=m;i&lt;=n;i++) { Swap(Array,m,i); Perm(Array,m+1,n); Swap(Array,m,i); } 也就是依次将index为m的元素与它之后的元素进行交换，然后再对剩下的部分进行递归操作例子:[2,3,4,1]的得来 Swap Perm(1,3) Swap Perm(2,3) Swap [1,2,3,4]-&gt;[2,1,3,4]-&gt;对剩下的序列[1,3,4]进行递归操作-&gt; [3,1,4]-&gt; 对序列[1,4]操作-&gt;[4,1] [1,2,3,4] [2,1,3,4] [2,3,1,4] [2,3,4,1] 但是在递归完之后还要再把数列换回来因为只有这样才能有效的进行其他序列的交换 Swap(0,1) 没有Swap回来 for循环进行下一个Swap(0,2) [1,2,3,4]-&gt;[2,1,3,4]-&gt;递归-&gt;[2,1,3,4]-&gt;[3,1,2,4] 无法得到[3,2,1,4]序列 Swap(0,1) Swap(0,1) for循环进行下一个Swap(0,2) [1,2,3,4]-&gt;[2,1,3,4]-&gt;递归-&gt;[1,2,3,4]-&gt;[3,2,1,4] 得到[3,2,1,4]序列 当起始index等于终止index时，就表明一个新的排列已经生成，此时进行输出或者储存即可完整代码: void Perm(int nums[100],int s,int e) { if(s==e) {//相关操作} else{ for(int i=s,i&lt;=e;i++) { Swap(s,i); Perm(nums,s+1,e); Swap(s,i); } }]]></content>
      <categories>
        <category>Coding(Algorithm)</category>
      </categories>
      <tags>
        <tag>algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[(打开会引发界面变化，关闭即可）在hexo博客上测试前端代码]]></title>
    <url>%2Fhfuter7712.github.io%2F2019%2F09%2F10%2FhexoFrontTest1%2F</url>
    <content type="text"><![CDATA[测试1(单纯HTML代码) 这是一个p元素这是一个大标题这是一段强调文本这是一个div元素，背景色打了鸡血点击这里是一个可爱的按钮通往百度的大门链接这是一个输入框单选表单这是单选表单1这是单选表单2多选表单这是多选选项1这是多选选项2这是一段分割线测试2（完整前端代码)&lt;html&gt; &lt;head&gt; &lt;style&gt; .test{ width:20px; background-color:yellow; .no{ background-color:red; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div class=&quot;test&quot;&gt; as &lt;div class=&quot;no&quot;&gt; shit &lt;/div&gt; &lt;/div&gt; &lt;/body&gt; &lt;/html&gt;测试出来div元素背景色没变没效果，不能加&lt;html&gt;标签(傻了)去掉&lt;html&gt;.test{height:100px;width:200px; background-color:yellow;.no{background-color:red;}as shit Bootstrap测试 测试按钮信息按钮信息按钮信息按钮按钮font-awesome测试]]></content>
      <categories>
        <category>Coding(blog)</category>
      </categories>
      <tags>
        <tag>HTML</tag>
        <tag>css</tag>
        <tag>Javascript</tag>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTML5 学习]]></title>
    <url>%2Fhfuter7712.github.io%2F2019%2F09%2F09%2Fhtml5%2F</url>
    <content type="text"><![CDATA[HTML5是下一代HTML标准HTML5必须在第一行声明&lt;!DOCTYPE html&gt;HTML5中定义了8个新的HTML语义元素&lt;header&gt;&lt;section&gt;&lt;footer&gt;&lt;aside&gt;&lt;nav&gt;&lt;main&gt;&lt;article&gt;&lt;figure&gt;将其定义为块级元素 header,section,footer,aside,nav,main,article,figure{ display: block; } canvas创建一个画布&lt;canvas id=&quot;myCanvas&quot; width=&quot;200&quot; height=&quot;100&quot;&gt;&lt;/canvas&gt;使用style来定义边框border: solid;效果: 需要借助JS来绘制图像 var c =document.getElementById(&quot;myCanvas&quot;); var ctx=c.getContext(&quot;2d&quot;); ctx.fillStyle=&quot;#123456&quot;; ctx.fillRect(0,0,150,75); 其中首先通过JS DOM得到画板元素1（不知道用jQuery能不能实现，研究ing），然后用getContext创建context对象绘制一个矩形fillStyle设置填充颜色fillRect(x,y,width,height) x,y是起始的坐标，width是宽度，height是高度 注意：canvas画布中的坐标轴是这样的 X —————————————————— | Y | | | X正方向是向屏幕右手方向，Y轴是屏幕正下方 ——画线——moveTo(x,y)定义线条开始坐标lineTo(x,y)定义线条结束坐标stroke()最终通过stroke函数来绘制线条example: var ctx=Can.getContext(&quot;2d&quot;); for(var i=0;i&lt;50;i++) { ctx.moveTo(0,2*i); ctx.lineTo(2*i,0); ctx.stroke(); } 绘制了一组连续的线条（连续到都快重叠到一起了，之前尝试过0,i和i,0的直接绘制了一个实心的三角形效果: arc(x,y,r,start,stop)x与y是圆心坐标r是圆的半径start是起始弧度stop是终止弧度因此start=0,stop=2*Math.PI自然画出了一个圆用于绘制圆形 var ctx=Can.getContext(&quot;2d&quot;); ctx.beginPath(); ctx.arc(95,50,40,0,2*Math.PI); ctx.stroke(); 这是一个圆，不过鄙人多加了点小改动于是就变成了这样 var ctx=Can.getContext(&quot;2d&quot;); for(var i=0;i&lt;50;i++) { ctx.beginPath(); ctx.arc(95,50,i,0,2*Math.PI); ctx.stroke(); } 画出来的一堆同心圆竟然还有点美感？效果图: 文本绘制文本 var ctx=c.getContext(&quot;2d&quot;); ctx.font=&quot;30px Arial&quot;; ctx.fillText(&quot;Hello World&quot;,10,50); ctx.font()用于定制字体的属性（大小字体等等）ctx.fillText(text,x,y)text指的是填充文本x,y是字体的位置ctx.strokeText(text,x,y)可以绘制空心的字体 个人感觉可以用canvas来绘制个人logo或者简单的图标 获取地理位置getCurrentPosition()用于获取用户的位置 设置函数: function getLocation() { if(navigator.geolocation) { navigator.geolocation.getCurrentPosition(showPosition); } else { alert(&quot;该浏览器不支持获取地址!&quot;); } } showPosition(position)是获取完成之后的操作函数,position应该是获取的坐标对象，position.coords.latitude是指经度position.coords.longtitude是指纬度结果:没获取到，可能是获取时间过长 视频使用&lt;video&gt;标签 &lt;video width=&quot;320&quot; height=&quot;240&quot; controls&gt; &lt;source src=&quot;movie.mp4&quot; type=&quot;video/mp4&quot;&gt; &lt;source src=&quot;movie.ogg&quot; type=&quot;video/ogg&quot;&gt; 您的浏览器不支持Video标签。 &lt;/video&gt; 可以在其中使用多个source元素，浏览器将使用第一个可以识别的格式 用DOM操作视频首先获取视频元素var myVideo=document.getElementById(&quot;&quot;); play()播放视频：myVideo.play() pause()暂停视频:myVideo.pause() 使用myVideo.paused可以判定视频是否暂停if(myVideo.paused) width()用于设置视频宽度myVideo.width()]]></content>
      <categories>
        <category>Coding(Front End)</category>
      </categories>
      <tags>
        <tag>HTML</tag>
        <tag>Javascript</tag>
        <tag>HTML5</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[机器学习笔记(二)]]></title>
    <url>%2Fhfuter7712.github.io%2F2019%2F09%2F09%2FmachineLearn2%2F</url>
    <content type="text"><![CDATA[表示为了训练模型，必须选择最能代表数据的特征集特征值应以非零值的形式在数据集中出现良好特征具备的特性：1.应该具有清晰明确的定义2.特征不应该使用“神奇”值（避免很少使用的离散特征值)3.特征的定义不应随事件发生变化4.分布不应包含离谱的离群值 为模型中每个分类特征创建一个二元向量来表示这些值，对于适用于样本的值，将相应向量元素设为1，其他设为0当只有一个值为1时，称为独热编码当有多个值为1时，称为多热编码 稀疏表示法用于内容十分庞大的数据集稀疏表示法仅存储非零值但是仍然为每个特征值学习独立的模型权重 ——处理极端离群值——1.对每个值取对数，取完后离群值仍然存在，这时候将最大值限制为某个任意值，虽然会导致限制值的那个点有个小峰值，但仍然比原始数据好用2.分箱分箱后，可以为每个属性学习完全不同的权重 ——清查——1.遗漏值2.重复样本3.不良标签4.不良特征值检测到以上问题需要将其从数据集中移除]]></content>
      <categories>
        <category>Coding(New Area)</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>machine-learning</tag>
        <tag>tensorflow</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Node.js学习(一)]]></title>
    <url>%2Fhfuter7712.github.io%2F2019%2F09%2F08%2FnodeJS%2F</url>
    <content type="text"><![CDATA[教程链接:https://www.runoob.com/nodejs/nodejs-tutorial.htmlNode.js就是运行在服务端的Javascript 新建一个文件夹用于实践在文件夹中打开Git输入node -v可以查看目前Node.js的版本输入node可以进入命令交互模式在里面输入console.log(&quot;Hello World&quot;);可以输出“Hello World”想要运行某js文件，在Git中输入node xxx.js即可 使用Node.js时，不仅仅在实现一个应用，同时还实现了整个HTTP服务器 Node.js组成：1.引入required模块可以使用require指令来载入Node.js模块2.创建服务器3.接收请求与响应请求 使用require指令来载入http模块，并将实例化的HTTP赋值给变量httpvar http = require(&quot;http&quot;); http.createServer()创建服务器 代码来自菜鸟教程 var http = require(&apos;http&apos;); http.createServer(function (request, response) { // 发送 HTTP 头部 // HTTP 状态值: 200 : OK // 内容类型: text/plain response.writeHead(200, {&apos;Content-Type&apos;: &apos;text/plain&apos;}); // 发送响应数据 &quot;Hello World&quot; response.end(&apos;Hello World\n&apos;); }).listen(8888); // 终端打印如下信息 console.log(&apos;Server running at http://127.0.0.1:8888/&apos;); 分析:第一句引入require命令不说了，第二部通过http.createServer()创建服务器,.listen()用于绑定端口 效果:实现了一个在端口8888上的服务器，并且进入时页面上打印着Hello World NPM可以使用npm命令安装模块npm install &lt;Module Name&gt;example:用npm安装模块expressnpm install express安装过后的包在工程目录下的node_modules目录中 卸载模块npm uninstall express更新模块npm update express搜索模块npm search express REPL(交互式解释器)在cmd或git中输入node即可开启RDPL下划线变量可以使用_下划线来获取上一个表达式的运算结果 &gt; x + y 30 &gt; var sum = _ undefined &gt; console.log(sum) 30 可以看出sum从下划线中获取到了上一个表达式x+y的值30 按^C可以退出REPL 回调函数Node.js异步编程的直接体现就是回调回调函数一般作为函数的最后一个参数出现 回调函数在完成任务后就会被调用，Node使用大量的回调函数，其所有API都支持回调函数作用(来自菜鸟教程)：可以一边读取文件一边执行其他命令，在文件读取完成后，将文件内容作为回调函数的参数返回，这样在执行代码时就没有阻塞或者等待文件I/0操作大大提高了Node.js的性能可以处理大量的并发请求 事件循环Node.js是单进程单线程1应用程序单线程进入类似一个while(true)的事件循环，知道没有事件观察者退出每个异步事件都生成一个时间观察者，若有事件发生，就调用该回调函数 事件驱动程序Node.js使用事件驱动模型，当web server接收到请求，就把它关闭然后进行处理，去服务下一个web请求当这个请求完成，它被放回处理队列，当到达队列开头，这个结果被返回给用户 引入events模块var events = require(&#39;events&#39;); events模块只提供了一个对象 events.EventEmitter其核心就是事件触发与事件监听器功能的封装eventEmitter 创建eventEmitter对象var eventEmitter = new events.EventEmitter();当EventEmitter对象实例化发生错误会触发error事件添加新的监视器的时候会触发newListener事件监视器移除时，会触发removeListener事件 绑定事件处理程序eventEmitter.on(&#39;eventName&#39;,eventHandler);其中的eventHandler是一个自定义函数，当事件被调用之后该函数被调用，如果你编写的函数是console.log(“某些东西”);的话，那么当事件被调用时，将会在控制台上输出你想要输出的某些东西EvenEmitter的每个事件由一个事件名和若干个参数组成，当事件触发时，注册到这个事件的事件监听器被依次调用，时间参数作为回调函数参数传递 获取’connection’事件监听器个数var eventListeners = evenEmitter.listenerCount(&#39;connection&#39;); 移除绑定的函数eventEmitter.removeListener(&#39;connection&#39;,listener1); 触发事件eventEmitter.emit(&#39;eventName&#39;);]]></content>
      <categories>
        <category>Coding(Back End)</category>
      </categories>
      <tags>
        <tag>Javascript</tag>
        <tag>Node.js</tag>
        <tag>服务端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[机器学习笔记(一)]]></title>
    <url>%2Fhfuter7712.github.io%2F2019%2F09%2F07%2FmachineLearn1%2F</url>
    <content type="text"><![CDATA[来自谷歌教程https://developers.google.com/machine-learning/ 标签和特征标签是指要预测的真实事物: y ·基本线性回归中的y变量 特征是用于描述数据的输入变量 样本与模型样本：数据的特定实例有标签样本：用于训练模型无标签样本：用于对新数据做出预测模型：将样本映射到预测标签 训练与推断训练：创建或学习模型，向模型展示有标签样本，让模型逐渐学习特征与标签之间的关系推断：将训练后的模型用于无标签样本 回归与分类回归模型可以预测连续值分类模型可以预测离散值 误差给定样本的L2损失也称为平方误差等于预测值和标签值 之差的平方等于观测值和预测值 之差的平方在监督式学习中，机器学习算法通过以下方式构建模型：检查多个样本并尝试找出可最大限度的减少损失的模型这一过程称为经验风险最小化 MSE均方误差指每个样本的平均平方损失等于各个样本的所有平方损失之和除以样本数量 ————降低损失————迭代方法是一个广泛用于降低损失的方法 梯度下降法回归问题产生的损失与权重图为凸形选取一个起始值并计算其梯度，然后沿着负梯度方向移动，以便降低损失 学习速率如果学习速率过小，步伐过小，则图标上的点密集，需要通过大量的计算来达到最小值（最小损失loss)如果学习速率过大，步伐大，可能会超过最小损失对应的点，甚至可能会比之前的loss还要大所以合理的定义学习速率是十分重要的 神经网络并不是凸型 随机梯度下降法：一次抽取一个样本小批量梯度下降法：每批包含10-1000个样本 基于大型数据集执行梯度下降法时，采用小批量甚至包含一个样本的批量（SGD）更为高效 机器学习练习中的常用超参数:steps:训练迭代的总次数batch size:单步的样本数量（随机选择） total number of trained examples = steps * batch size 方便变量periods:控制报告的粒度example:若periods设为7，steps设为70，则每10步输出一次损失值最好不要修改periods的值 泛化指模型很好的拟合以前从未见过的新数据的能力个人理解：就是能用现有模型很好的预测所给定的数据————问题:过拟合————过拟合模型在训练过程中产生的损失很低，但在预测新数据方面的表现非常糟糕 因此模型应该尽可能简单 基本假设:1.从分布中随机抽取独立同分布的样本2.分布是平稳的，不随时间变化3.始终从同一分布中抽取样本，包括训练集，验证集和测试集倘若违背任何一项，就必须密切注意指标 将数据集拆分为用于训练模型的训练集和用于测试训练后模型的测试集绝对不要对测试数据进行训练reason:因为你用测试数据进行训练，得到的模型当然是最拟合测试数据的模型。。 验证在训练集和测试集之外创建第三个集合即验证集]]></content>
      <categories>
        <category>Coding(New Area)</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>machine-learning</tag>
        <tag>tensorflow</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[网页前端实践--弹幕墙]]></title>
    <url>%2Fhfuter7712.github.io%2F2019%2F09%2F07%2FdammuProject%2F</url>
    <content type="text"><![CDATA[刚学完了Bootstrap和jQuery，二话不说马上来了一波实践，刚上手就放大招，这次的任务是搞一个弹幕墙，像B站的那种，弹幕从右边飘到左边，一开始还百思不得其解，那时候本人才刚学完前端三大件，后来有了jQuery和bootstrap的帮助，真的懂了很多 成品地址：https://codepen.io/hfuter7712/pen/xxKpKyM包含源代码首先讲讲前端页面的设计弹幕墙就是一个单纯的div，然后设置的width为auto以便适应各种屏幕的大小,本人还设置了弹幕墙的边框然后是弹幕输入框，一个单纯的input元素然后套上bootstrap的输入框风格，设置默认占位符playholder为你想说啥?其次是按钮的设计，运用了bootstrap的按钮样式btn btn-primary，还是挺方便的 最下方的信息div，背景色和文字就不多说了，这次尝试按钮链接+font-awesome图标库，成功搞了一套个人信息按钮出来，不得不说多了图标真的好看多了，包含github,codePen,freecodecamp和本人自己的博客 其次讲到弹幕的实现，这个思路是本人完全自主想到的一开始还不知道咋实现，但是一学完jQuery中的animate动画后，恍然大悟，其实原理很简单，只要在弹幕墙的右侧部位进行弹幕元素生成，然后设置动画即可，很简单的动画，直接left:&quot;-=2000px就可以了，弹幕元素如何生成呢首先用jQuery选择器获取输入框中的内容，然后存入一个数组中，再运用Math.random随机选取数组中的元素，然后再次用jQuery添加带有弹幕文本的p元素，如何创建，当然是.append大法，不过插入要严格按照HTML格式，这个还花费了本人一段时间来研究然后动画设置好了接下来就是实现完全自动生成弹幕的时候了setInterval()，请每隔一段时间就执行生成弹幕函数，这样就可以每隔一段时间产生弹幕 每隔代码的id设置成自己的数组下标，，不过这样会产生一个现象，如果在一个弹幕还在运动的时候（没被销毁时）随机选择又选到了这个弹幕，即两个弹幕id相同的话（因为销毁代码是按照id来销毁的），那个稍后的代码就会自动停留在初始位置，而不会被销毁，貌似再次被选中的时候才会飞出去被销毁，因此最后那边累积的弹幕会越来越多，这个问题本来想到是依照1~50递增的对id进行命名，但是那样又会出现重复的弹幕影响体验，这个到后面再研究 差不多就是这样，毕竟只是一个初级的前端设计实践，也没啥特别难的很高兴自己有了自己的想法，继续努力吧，冲冲冲！]]></content>
      <categories>
        <category>Coding(Front End)</category>
      </categories>
      <tags>
        <tag>HTML</tag>
        <tag>css</tag>
        <tag>jQuery</tag>
        <tag>Javascript</tag>
        <tag>Bootstrap</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Javascript AJAX 学习(一)]]></title>
    <url>%2Fhfuter7712.github.io%2F2019%2F09%2F04%2Fajax1%2F</url>
    <content type="text"><![CDATA[学习自菜鸟教程https://www.runoob.com/ajax/ajax-intro.html AJAX(Asynchronous JavaScript and XML)翻译为“异步JS与XML”是一种用于创建快速动态网页的技术，通过在后台与服务器进行少量数据交换，AJAX可以使网页实现异步更新意味着可以在不重新加载整个网页的情况下，对网页的部分进行更新AJAX基于现有的Internet标准 XMLHttpRequestXMLHttpRequest是AJAX的基础用于在后台与服务器交换数据，这意味着可以在不重新加载整个网页的情况下，对网页的某部分进行更新（人类的本质） 创建XMLHttpRequest对象的方法:variable=new XMLHttpRequest();判断是否支持该对象: var xmlhttp; if(window.XMLHttpRequest) { xmlhttp=new XMLHttpRequest(); } else { xmlhttp=new ActiveXObjext(&quot;Microsoft.XMLHTTP&quot;); //这个大部分是IE6和IE5使用的对象 } 向服务器发送请求open(method,url,async)method:请求的类型;”GET”或者”POST”url:文件在服务器上的位置该文件可以是任何类型的文件，比如.txt和.xml,或者服务器脚本文件，.asp和.php文件async:true(异步),false(同步)example: xmlhttp.open(&quot;GET&quot;,&quot;ajax_info.txt&quot;,true);xmlhttp是XMLHttpRequest对象 send(string)将请求发送到服务器string:仅用于POST请求 GET相比于POST更简单，更快但是在以下情况下，使用POST：1.无法使用缓存文件(更新服务器上的文件或数据库)2.向服务器发送大量数据(POST无数据量限制)3.发送包含未知字符的用户输入时 通过AJAX，JS无需等待服务器的响应，而是1.在等待服务器响应时执行其他脚本2.当响应就绪后对响应进行处理 当Async=true时，需要规定在响应处于onreadystatechange事件中的就绪状态时执行的函数当Async=false,不要编写onreadystatechange函数，把代码放到send()后即可 服务器响应responseText如果来自服务器的响应并非XML，使用该属性document.getElementById(&quot;myDiv&quot;).innerHTML=xmlhttp.responseText;本人拓展:用jQuery书写为:$(&quot;#myDiv&quot;).html(xmlhttp.responseText); responseXML来自服务器的响应是XML，并且需要作为XML对象进行解析，就使用上述属性 onreadystatechange 事件每当readyState改变时，就会触发该事件readyState参数:0:请求未初始化1:服务器连接已建立2：请求已接收3：请求处理中4：请求已完成，且响应已经就绪 status参数:200:“OK”404:未找到界面（万恶之源)（其实status的值有好多好多,不全列举了) 当readyState等于4且status等于200时，表示响应已经就绪if(xmlhttp.readyState==4 &amp;&amp; xmlhttp.status==200)]]></content>
      <categories>
        <category>Coding(Front End)</category>
      </categories>
      <tags>
        <tag>Javascript</tag>
        <tag>AJAX</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jQuery复习+学习（二）]]></title>
    <url>%2Fhfuter7712.github.io%2F2019%2F09%2F03%2FjQuery2%2F</url>
    <content type="text"><![CDATA[css()要返回指定的CSS属性的值，使用如下语法即可css(&quot;propertyname&quot;);example:$(&quot;p&quot;).css(&quot;background-color&quot;); 设置属性，在先前的语法上加上第二个参数$(&quot;p&quot;).css(&quot;background-color&quot;,&quot;yellow&quot;);就将p元素的背景色设置为了黄色 同时设置多个属性$(&quot;p&quot;).css({&quot;background-color&quot;:&quot;yellow&quot;,&quot;font-size&quot;:&quot;200%&quot;});以设置属性名:属性值的格式，用逗号隔开，放在中括号中作为参数 遍历parent()通过这个方法取得当前选取的元素的直接父元素通俗的说就是当前元素的老爸 parents()通过这个方法获取当前选取元素的所有父元素 parentsUntil()返回介于两个给定元素之间的所有祖先元素$(&quot;#firstElement&quot;).parentsUntil(&quot;secondElement&quot;); children()返回被选元素的所有直接子元素通俗的说就是当前元素的儿子 find()返回被选元素的后代元素，一路向下直到最后一个后代可对find中进行参数定义来匹配特定元素$(&quot;#grandfather&quot;).find(&quot;*&quot;);所有后代元素$(&quot;#grandfather&quot;).find(&quot;span&quot;);所有后代span元素 siblings()返回被选元素的所有同胞元素同胞元素：拥有相同的父元素 next()返回被选元素的下一个同胞元素通俗的讲就是，同一个老爸，当前元素按顺序下一个儿子 nextAll()返回被选元素的所有跟随的同胞元素就是把当前元素之后的所有同胞元素都返回了 nextUntil()返回两个给定参数之间的所有跟随的同胞元素 prev()prevAll()prevUntil()和上述三个函数方向相反，方法类似 过滤first()选取被选元素的首个元素example:$(&quot;p&quot;).first();第一个p元素 last()选取被选元素的最后一个元素 eq()返回被选元素中带有指定索引号的元素注意:索引号和数组下标一样从0开始$(&quot;p&quot;).eq(2);返回索引号为2的，第三个p元素 filter()括号中规定一个标准，返回匹配的元素$(&quot;p&quot;).filter(&quot;.test&quot;);返回带有类名test的p元素 not()和filter()函数刚好相反，返回不与括号中条件匹配的元素上面那个换成not()函数就是返回不带有类名test的p元素 当jQuery典型的美元符号和其他框架冲突noConflict()这个方法可以将jQuery的美元前缀改成其他的 var yeah=$.noConflict(); yeah(document).ready(function(){ yeah(&quot;button&quot;).click(function(){ yeah(&quot;p&quot;).text(&quot;jQuery 还能yeah!&quot;); }); }); 前缀变成”yeah”了233]]></content>
      <categories>
        <category>Coding(Front End)</category>
      </categories>
      <tags>
        <tag>jQuery</tag>
        <tag>Javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[编译原理预习笔记（二）--高级语言及其语法描述]]></title>
    <url>%2Fhfuter7712.github.io%2F2019%2F09%2F03%2FcomplieP2%2F</url>
    <content type="text"><![CDATA[语法任何语言程序都可以看做是一定字符集（字母表）上的一个字符串（有限序列）语言的单词符号是由语法规则所确定的一个程序语言只使用一个有限字符集作为字母表单词符号是语言中具有独立意义的最基本结构词法规则是指单词符号的形成规则语法规则是语法单位的形成规则上下文无关文法是一种可取的有效工具语法单位比单词符号具有更丰富的意义 语义对于一个语言，不仅要给出他的词法，语法规则，还要定义它的单词符号和语法单位的意义一个程序的基本功能是描述数据和对数据的运算 ，所谓一个程序，从本质上说是描述一定数据的处理过程程序语言的每个组成成分都有（抽象的）逻辑和计算机实现 两方面的意义 数据类型与操作一个数据类型通常包括以下三种要素：1.用于区别这种类型的数据对象的属性2.这种类型的数据对象可以具有的值3.可以作用于这种类型的数据对象的操作 ——初等数据类型——一个程序语言必须提供一定的初等类型数据成分，并定义对于这些数据成分的运算常见的初等数据类型有：1.数值数据2.逻辑数据3.字符数据4.指针类型 在程序中各种名字都是用标识符表示的一个名字的属性包括类型和作用域在某些语言中，名字的属性有时容许是隐约定的 对于具有静态性质的名字，编译时应该对它们引用的合法性进行检查对于具有动态性质的名字，应该在程序运行时收集和确定他们的性质，并进行必要的类型转换 ——数据结构——1.数组一个数组是由同一类型数据所组成的某种n维矩形结构 2.记录从逻辑上来说，记录结构是由已知类型的数据组合起来的一种结构记录结构最简单的存储表示方式是连续存放 3.字符串，表格，和队列 ——抽象数据类型——一个抽象数据类型包括:1.数据对象的一个集合2.作用于这些数据对象的抽象运算的集合3.这种类型对象的封装 C++和Java中的类(class)对抽象数据类型提供支持 语句与控制结构一个表达式是由运算量（操作数）和算符组成的算符的代数性质（交换律，结合律，分配律）常常可以用来优化目标程序的质量 语句不同程序语言含有不同形式和功能的各种语句从功能上来说，语句大体分为：执行性语句和说明性语句 两大类 执行性语句：描述程序的动作可分为赋值句，控制句和输入/输出句名字的左值：指它所代表的存储单元的地址右值：该单元内容变量既持有左值又持有右值常数和带有算符的表达式一般认为只持有右值 说明性语句：定义各种不同数据类型的变量或者运算 简单句：指那些不包含其他语句成分的基本句]]></content>
      <categories>
        <category>specialized-course</category>
      </categories>
      <tags>
        <tag>principle</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[编译原理学习笔记（一）]]></title>
    <url>%2Fhfuter7712.github.io%2F2019%2F09%2F03%2FcomplieL1%2F</url>
    <content type="text"><![CDATA[来自MOOC哈工大教程编译：将高级语言翻译成汇编语言或机器语言的过程 通过分析源语言获得句子的语义：语义分析通常从划分句子成分入手 分析部分/前端:与源语言有关综合部分/后端:与目标语言有关 常用的中间表达形式：1.三地址码2.语法结构树/语法树 课后习题错题笔记：编译是对高级语言的翻译源程序是句子的集合，树可以较好地反映句子的结构]]></content>
      <categories>
        <category>specialized-course</category>
      </categories>
      <tags>
        <tag>principle</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jQuery复习（一）]]></title>
    <url>%2Fhfuter7712.github.io%2F2019%2F09%2F02%2Fjquery1%2F</url>
    <content type="text"><![CDATA[在开头&lt;head&gt;标签中加入如下语句 &lt;script src=&quot;https://cdn.staticfile.org/jquery/2.0.0/jquery.min.js&quot;&gt; &lt;/script&gt; 元素选择器https://www.runoob.com/jquery/jquery-selectors.html 对某个标签的所有元素进行选取:example:选取所有元素$(&quot;p&quot;) 根据id来选取元素$(&quot;#ident&quot;)选取id为ident的元素 根据class选取元素$(&quot;.classF&quot;)选取class为classF的元素 事件example:点击p元素后触发某函数 $(&quot;p&quot;).click(function(){ //要执行的代码 }); $(document).ready()该方法允许我们在文档完全加载完后执行函数 click() 点击按钮触发dblclick() 双击触发mouseenter() 鼠标指针穿过元素时触发mouseleave() 鼠标指针从元素上移开时触发 mousedown() 当鼠标指针移动到元素上方并按下鼠标按键时触发mouseup() 在元素上松开鼠标按钮hover() 模拟光标悬停（分两个函数，一个是光标移到元素上，一个是从元素上移开)example: $(&quot;#p1&quot;).hover( function(){ alert(&quot;鼠标移入&quot;); }, function(){ alert(&quot;鼠标移开&quot;); } ); focus()当元素获得焦点时触发（一般用于文本框输入，比如姓名，点击输入框，输入框变色)blur()和上一个相反，失去焦点时触发 隐藏与显示hide()将会隐藏一个元素show()将会显示一个隐藏的元素可以详细设置参数hide(speed,callback)speed是隐藏或显示的速度，”slow”,”fast”或者毫秒callback是隐藏或显示完成所执行的函数名称 toggle()相当于一个开关，可以在hide()和show()之间切换，如果元素处于隐藏状态，触发之后会将元素显示，反之会隐藏 淡入淡出fadeIn(speed,callback) 淡入fadeOut(speed,callback) 淡出speed同样是速度，取值同样是”slow”,”fast”或者毫秒callback是淡入淡出后执行的函数 fadeToggle()同样是起到开关的作用，在上述两种淡入淡出之间切换fadeTo(speed,opacity,callback)speed:规定效果的时长，”slow”,”fast”或毫秒opacity:目标不透明度(0~1)callback:执行完后的函数名称 滑动slideDown(speed,callback)slideUp(speed,callback)向上滑动与向下滑动speed与callback与淡入淡出的一样slideToggle()也是相当于开关，在上述两种效果间切换 动画https://www.runoob.com/jquery/jquery-animate.html 停止动画: stop(stopAll,gotoEnd)stopAll参数规定是否应该清除动画队列，默认是falsegoToEnd参数规定是否立即完成当前动画，默认是false因此默认情况下stop()函数会清除在被选元素上指定的动画 捕获text() 设置或者返回所选元素的文本内容html() 设置货返回所选元素的内容（包括HTML标记)val() 设置或返回表单字段的值attr() 属性 对比列子:&lt;p id=&quot;as&quot;&gt;&lt;em&gt;啊啊啊&lt;/em&gt;&lt;span&gt;我的头&lt;/span&gt;&lt;/p&gt;通过分别对id等于”as”获取其text以及html，结果为可以看出html还返回了内容中的html标签等 修改 $(document).ready(function(){ $(&quot;.text&quot;).click(function(){ $(&quot;#as&quot;).html(&quot;&lt;em&gt;疑是地上霜&lt;/em&gt;&quot;); }); 修改id为”as”的html效果图: 本人最喜欢的还是接下来这个功能，修改属性值 $(document).ready(function(){ $(&quot;.text&quot;).click(function(){ $(&quot;#as&quot;).attr({ &quot;href&quot;:&quot;https://www.bilibili.com/&quot; }); }); 点击class为text的按钮后id为as的链接href就从其他转变为B站网址了 添加append()在被选元素的结尾插入内容比如$(&quot;p&quot;).append(&quot;gkd&quot;);是在p元素的末尾添加”gkd” prepend()在被选元素的开头插入内容比如$(&quot;p&quot;).prepend(&quot;yes&quot;);是在p元素的开头添加”yes” after()在被选元素之后插入内容 before()在被选元素之前插入内容这四个函数都允许多参数example:$(&quot;#as&quot;).append(txt1,txt2,txt3); 删除remove()删除被选元素及其子元素 empty()删除被选元素的子元素remove()和empty()的差别就是remove()删除被选元素，而empty()不删除]]></content>
      <categories>
        <category>Coding(Front End)</category>
      </categories>
      <tags>
        <tag>jQuery</tag>
        <tag>Javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[编译原理预习笔记（一）]]></title>
    <url>%2Fhfuter7712.github.io%2F2019%2F09%2F02%2FcomplieP1%2F</url>
    <content type="text"><![CDATA[世界上第一个编译程序：FORTRAN编译程序于20世纪50年代中期研制成功 编译程序的工作一般可划分为五个阶段（编译程序工作时的动态特征）：1.词法分析任务：输入源程序，对构成源程序的字符串进行扫描和分解 ，识别出单词 2.语法分析任务： 在词法分析的基础上，根据语言的语法规则，把单词符号串分解为各类语法单位通过语法分析：确定整个输入串是否构成语法上正确的“程序”语法分析依循的是语言的语法规则语法规则通常用上下文无关文法描述 3.语义分析与中间代码产生任务：对语法分析所识别出的各类语法范畴，分析其含义，并进行初步翻译（产生中间代码） 4.优化任务：对前端产生的中间代码进行加工变换，以期在最后阶段能产生吃醋更为高效的目标代码 5.目标代码生成任务：把中间代码变换成特定机器上的低级语言代码 注：并非所有编译程序都分为五阶段 编译程序的结构：1.词法分析器（扫描器）输入源程序，进行词法分析，输出单词符号 2.语法分析器（分析器）对单词符号串进行语法分析 3.语义分析与中间代码产生器按照语义规则对语法分析器归约出的语法单位进行语义分析后把它们翻译成一定形式的中间代码 4.优化器对中间代码进行优化处理 5.目标代码生成器把中间代码翻译成目标程序 表格编译程序在工作过程中需要保持一些列的表格，用于登记源程序的各类信息和编译各阶段的进展情况在编译程序使用的表格中，最重要的是符号表 出错处理源程序中的错误通常分为语法错误和语义错误两大类语法错误：源程序中不符合语法规则的错误语义错误：源程序中不符合语义规则的错误 遍对源程序或源程序的中间结果从头到尾扫描一次 ，并作有关的加工处理，生成新的中间结果或目标程序当一遍中包含若干阶段时，各阶段的工作是穿插进行的 要在某一台机器上为某种语言构造一个编译程序，必须掌握下述三方面内容：1.源语言深刻理解其结构和含义 2.目标语言 3.编译方法 任何语言实现的基础是语言定义一个程序语言只使用一个有限字符集作为字母表单词符号是语言中具有独立意义的最基本结构语法单位比单词符号具有更丰富的意义 高级语言分类:1.强制式语言（过程式语言）特点：命令驱动，面向语句 2.应用式语言更注重程序所表示的功能，开发过程：从前面已有的函数触发构造出更复杂的函数 3.基于规则的语言执行过程：检查一定的条件，当他满足值时，执行适当的动作 4.面向对象语言主要特征：封装性，多态性，继承性等]]></content>
      <categories>
        <category>specialized-course</category>
      </categories>
      <tags>
        <tag>principle</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[计算机组成原理预习笔记（一）]]></title>
    <url>%2Fhfuter7712.github.io%2F2019%2F09%2F02%2FcomputerOrgan%2F</url>
    <content type="text"><![CDATA[来自MOOC电子科技大学课程+教材 电子计算机：可以存储程序，可以通过执行程序指令，可以自动，高速精确地对数字信息进行各种复杂处理 ，然后输出运算结果关键词：存储程序，执行程序，复杂处理，输出运算结果 5个逻辑设备(计算机五大件)： 输入设备，存储器，运算器，控制器，输出设备通过数据通路和控制通路相互连接形成有机整体由于运算器和控制器在逻辑关系和电路结构联系上十分紧密，因此两部往往结合在同一芯片上，合起来统称为中央处理器（Central Processing Unit，CPU）把输入设备与输出设备称为I/O设备 因此现代计算机可认为由三大部件组成：CPU，I/O设备，主存储器 CPU与主存储器合起来称为主机I/O设备又称为外部设备 主存储器是存储子系统中的一类，用来存放程序与数据，可直接与CPU交换信息另一类称为副主存储器，简称辅存，也称外存ALU和CU是CPU的核心部件 ALU（Arithmetic Logic Unit）:算术逻辑单元作用：完成算术逻辑运算以全加器为核心 CU（Control Unit）：控制单元作用：用来解析存储器中的指令，发出各种操作命令来执行命令 I/O设备受CU控制 信息的数字化表示1.在计算机中用数字代码（二进制代码）表示各种信息2.在物理机制上用数字信号表示数字代码 信息数字化优点：1.物理上容易实现信息的表示与存储2.抗干扰能力强，可靠性高3.数值表示范围大，精度高4.可标识的信息类型广泛5.能用数字逻辑技术进行处理 计算机从总体上来说分为两大类：模拟计算机和数字计算机模拟计算机：由模拟运算器件构成，处理在实践和数值上连续的模拟量数字计算机：由数字逻辑器件构成，处理离散数字量 机器字长：值CPU一次能处理数据的位数，通常与CPU的寄存器位数有关，机器字长的确定不能单从精度和数的标识范围来考虑 存储容量：主存容量+辅存容量存储容量 = 存储单元格数 * 存储字长用字节数来描述容量的大小 EDVAC 电子离散变量计算机（冯诺依曼思想）: 宣告电子计算机时代即将来临，在该指定的计划中首次提出了存储程序的概念第一台严格意义上的电子计算机： ENIAC 并夕法尼亚大学，1946年2月 冯诺依曼体系：1.用二进制代码表示程序与数据2.采用存储程序的工作方式3.新型的现代计算机硬件组成 主要器件第一代计算机（1946-1957）:电子管第二代计算机（1958-1964）:晶体管第三代计算机（1965-1971）:中小规模集成电路（速度达到MIPS级）第四-五代计算机（1972-今）：大规模，超大规模集成电路（速度高达GIPS甚至TIPS级别）（具体是1972-1977是第四代，1978-今是第五代） 未来发展趋势：1.巨型化方向2.微型化方向3.多媒体化方向4.网络化方向5.智能化方向 硬件：构成计算机系统的实体和装置之类的有形设备，是组成计算机系统的物质基础软件：由硬件所表达的各种内在信息，包括数据与控制程序，无形 系统软件：主要用来管理整个计算机系统，监事服务，使得系统资源得到合理调度，高效运行应用软件：用户根据任务需要所编制的各种程序 总线能为多个部件分时共享的一组信息传送通路计算机五大部件之间的互联方式有两种：1、各部件之间使用单独的连线，称为分散连接2、将各部件连到一组公共信息传输线上，称为总线连接 接口为了将总线与各类外设连接，需在两者之间设置的一些部件，具有缓冲，转换，连接等接口如VGA接口 计算机硬件的典型架构微型计算机：南-北桥架构小型计算机：多处理器架构超级计算机：集群式架构]]></content>
      <categories>
        <category>specialized-course</category>
      </categories>
      <tags>
        <tag>principle</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Jena javadoc 探索(二)]]></title>
    <url>%2Fhfuter7712.github.io%2F2019%2F09%2F02%2Fjenadoc2%2F</url>
    <content type="text"><![CDATA[Rule用来代表一般推理规则 规则范例: [ (?C rdf:type *), guard(?C, ?P) -&gt; (?c rb:restriction some(?P, ?D)) ]. [ (?s owl:foo ?p) -&gt; [ (?s owl:bar ?a) -&gt; (?s ?p ?a) ] ]. [name: (?s owl:foo ?p) -&gt; (?s ?p ?a)]. *代表通配符节点（wildcard node 可以匹配一切），?p代表变量，name(node ... node)代表一个仿函数(functor),(node,node,node)是一个三元模式，[..]是一个嵌入式规则(embedded rule) List rules=parseRules(String source)将一串字符串作为规则 用法(注:rules是String类型的字符串)： java.util.List&lt;Rule&gt; rules = Rule.parseRules(ruleSrc); GenericRuleReasoner一种能够援引各种有用的规则引擎结合，可以设置前向（forward），反向（backward）或者是混合（hybird）一般用法:Reasoner reasoner = new GenericRuleReasoner(Rule.parseRules(rules));个人理解：GenericRuleReasoner里面的参数是Rule组成的List,通过这些rules构成建Reasoner]]></content>
      <categories>
        <category>Coding(Project)</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Jena</tag>
        <tag>javadoc</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[FontAwesome图标字体库]]></title>
    <url>%2Fhfuter7712.github.io%2F2019%2F09%2F01%2FfontAwesome%2F</url>
    <content type="text"><![CDATA[(内容来自菜鸟教程，本博客为笔记)国内推荐CDN&lt;link rel=&quot;stylesheet&quot; href=&quot;https://cdn.staticfile.org/font-awesome/4.7.0/css/font-awesome.css&quot;&gt;使用fa前缀来放置Font Awesome设置class为fa fa-car可以设置汽车图标通过style设置图标大小和颜色font-size设置大小color设置颜色 列表图标设置类为fa-li fa外加第三个类为fa-check-square 为黑色打钩框框外加第三个类为fa-spinner fa-spin 为动态黑色转圈圈外加fa-square 为黑色实心正方形 动态图标设置类fa-spin可以让图标旋转设置类fa-pulse 让图标以8步为周期进行旋转 堆叠图标在&lt;span&gt;的class中添加类fa-stack即可然后依次键入需要堆叠的图标，越上面语句所产生的图像越在下层example:禁止照相 &lt;span class=&quot;fa-stack fa-lg&quot;&gt; &lt;i class=&quot;fa fa-camera fa-stack-1x&quot;&gt;&lt;/i&gt; &lt;i class=&quot;fa fa-ban fa-stack-2x text-danger&quot; style=&quot;color:red;&quot;&gt;&lt;/i&gt; &lt;/span&gt; 效果: 品牌图标大全网址:https://www.runoob.com/font-awesome/fontawesome-icons-brand.html个人喜好图标:fa fa-android 安卓图标fa fa-apple 苹果图标fa fa-edge edge图标fa fa-deviantart deviantart图标fa-fa-chrome chrome图标fa fa-facebook 脸书图标fa fa-facebook-official 脸书官方图标fa fa-free-code-camp freecodecamp图标fa fa-git git图标fa fa-github github图标fa fa-google 谷歌图标fa fa-html5 HTML5图标fa fa-internet-explorer IE图标fa fa-qq QQ图标fa fa-safari safari图标fa fa-share-alt 分享图标fa fa-steam steam图标fa fa-twitter 推特图标fa fa-usb usb图标fa fa-wechat 微信图标fa fa-weibo 微博图标fa fa-wikipedia-w 维基百科图标fa fa-windows 微软图标fa fa-youtube-play 油管图标 货币图标https://www.runoob.com/font-awesome/fontawesome-icons-currency.htmlfa fa-rmb人民币fa fa-eur欧元fa fa-usd美元 方向图标https://www.runoob.com/font-awesome/fontawesome-icons-directional.html 表单图标fa fa-check-square 黑框框里面一个√ 手势图标fa fa-thumbs-down 一个向下的大拇指(可以代表踩）fa fa-thumbs-up 一个向上的大拇指（可以代表赞)fa fa-thumbs-o-down 白色的赞fa fa-thumbs-o-up 白色的踩 付款图标https://www.runoob.com/font-awesome/fontawesome-icons-payment.html 加载图标https://www.runoob.com/font-awesome/fontawesome-icons-spinner.html Font Awesome参考手册https://www.runoob.com/font-awesome/fontawesome-reference.html 总结：是一个很好的图标库，可以有效地帮助我们改善某些小组件的设计]]></content>
      <categories>
        <category>Coding(Front End)</category>
      </categories>
      <tags>
        <tag>HTML</tag>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Jena javadoc 探索(一)]]></title>
    <url>%2Fhfuter7712.github.io%2F2019%2F09%2F01%2FJenadoc1%2F</url>
    <content type="text"><![CDATA[官方javadoc:http://jena.apache.org/documentation/javadoc/jena/ (PS:谷歌翻译在这里面无效，全都是阅读理解得来的) ModelFactory createDefaultModel具体用法: Model model=ModelFactory.createDefaultModel();用于返回一个默认规格的新模型（fresh model） createInfModel(InfGraph g)从推理图表g中获取一个推理模型 createInfModel(Reasoner reasoner, Model model)将给定的RDF模型model附加到给定的推理器reasoner上来获取一个推理模型具体用法:InfModel infmodel=ModelFactory.createInfModel(reasoner,data); createInfModel(Reasoner reasoner, Model schema, Model model)（官方函数解释和上面一个函数一致，但是参数多了一个schema模型，目前不确定是什么意思，在后续会实践验证) createOntologyModel()返回一个加载了用默认本体语言（OWL）表达的内存模型的本体模型（可以理解为默认OnModelSpec spec参数为OWL) createOntologyModel(OntModelSpec spec)根据所给定的参数设定建立新的本体模型 createOntologyModel(OntModelSpec spec, Model base)根据所给定的参数设定建立新的本体模型，并且以给定的模型base中的数据作为初始数据 createRDFSModel(Model model)在所给模型model中所有可导出的RDFS语法(RDFS entailments derivable)都可行的情况下返回一个模型 createRDFSModel(Model schema, Model model)在模型schema和model的可导出RDFS语法(RDFS entailments derivable)都可行的情况下返回模型 Interface Reasoner bindSchema(Graph tbox)将一个本体(ontology)附加到一个推理器(reasoner)上的最普遍方法 bindSchema(Model tbox)与上述函数同理用法: reasoner=reasoner.bindSchema(schema); setDerivationLogging(boolean logOn) 设置drivation logging的开关 setParameter(Property parameterUri, Object value)设置推理器的参数比如设置RDFS推理器的等级 reasoner.setParameter(ReasonerVocabulary.PROPsetRDFSLevel, ReasonerVocabulary.RDFS_SIMPLE); FileManager 可以从一个系统资源加载RDF数据到一个已经存在的模型或者新建立的模型FileManage和LocationMapper一同工作 get()获取全局文件管理者（global file manager） loadModel(String filenameOrURI)loadModel(String filenameOrURI, String rdfSyntax)loadModel(String filenameOrURI, String baseURI, String rdfSyntax) 用法（来自Jena官方文档推理api）:Model schema = FileManage.get().loadModel(&quot;file:data/owlDemoSchema.owl&quot;); 从一个文件中加载模型参数解释:baseURI:加载RDF模型的基本URIrdfSynatax: RDF Serialization synatax—-RDF序列化语法（翻译自百度翻译) readModel(Model model, String filenameOrURI)readModel(Model model, String filenameOrURI, String rdfSyntax)readModel(Model model, String filenameOrURI, String baseURI, String syntax)读取若干RDF数据并导入模型model中参数解释同上述loadModel Model InfModel 在Jena中推理的主要作用是给RDF数据集增加限制,这些需求只是以推理模型中附加的RDF数据的形式出现举个例子：如果一个推理引擎可以确定一个叫做“foo”的资源是“fooClass”那么当三元组 foo rdf:type fooClass .在数据集中时 ，所有Model API 比如说listStatments或者getProperty应当act(不知道咋翻译) listStatements(Resource subject, Property predicate, RDFNode object, Model posit)返回一个迭代器，包含该模型中所有的statements参数：subject：主语predicate:谓语object:宾语类似于三元组的(s,p,o) Model RDF模型 add(List&lt;Statement&gt; statements)将List中所有的statement都添加到模型中 add(Model m)将模型m中所有的statement都添加到当前模型中 add(Statement s)单单添加s语句到模型中 add(StmtIterator iter)将该迭代器中所有statements添加到当前模型中 close()关闭模型并释放资源所占用的内存 contains(Resource s, Property p)布尔型函数，判断模型中是否含有resource为s，property为p的statement contains(Resource s, Property p, RDFNode o)布尔型函数，判断模型中是否含有(s,p,o)模式的语句 contains(Statement s)布尔型函数，判断模型中是否含有该语句 containsAll(Model model)布尔型函数，判断当前model是否包含参数中model的所有语句（个人感觉应该是用来判断是否包含） createResource()创建一个新的匿名Resource具体用法(注:rdfsExample是一个Model实例):rdfsExample.createResource(NS+&quot;a&quot;) createStatement(Resource s, Property p, RDFNode o)创建一个新的statement difference(Model model)创建一个新的，独立的模型包含当前模型所有的而参数中模型中没有的statements getProperty(Resource s, Property p)返回一个resource为s，Property为p的statement（s,p,?o) getResource(String uri)根据参数中的url返回对应的资源resource independent()布尔型函数，判断该模型是否独立 isEmpty()布尔型函数，判断模型是否为空 listObjects()列举出模型中所有的object（类型为NodeIterator) listStatements(Resource s, Property p, RDFNode o)列举出满足特定条件的所有statement（类型为StmtIterator) listSubjects()列举出模型中所有的subject（类型为ResIterator) query(Selector s)创建一个包含满足某个特定查询的所有语句的新模型 read(InputStream in, String base)从指定输入流文档中读取statements remove(List&lt;Statement&gt; statements)将该List中所有的statement从模型中移去（适用于一次性移去大规模statement) remove(Statement s)将s从该模型中移去 removeAll()将当前模型中所有语句都移除 setNsPrefix(String prefix, String uri)为指定URI prefix设定prefix name size()返回当前模型的大小（statement语句的数量） union(Model model)将当前模型和参数中的model进行联合 write(Writer writer)将当前模型写成XML文档 ReasonerRegistry感觉和ModelFactory类似，用于reasoner的注册（即创建）一般用法:Reasoner reasoner = ReasonerRegistry.getRDFSReasoner(); getOWLReasoner()预建立一个标准配置的默认OWL推理器 getRDFSReasoner()预建立一个标准配置的默认RDFS推理器 create(String uri, Resource configuration)创建并返回一个被给定uri标记的reasoner 创建配置资源格式: Resource config = ModelFactory.createDefaultModel() .createResource() .addProperty(ReasonerVocabulary.PROPsetRDFSLevel, &quot;simple&quot;);]]></content>
      <categories>
        <category>Coding(Project)</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Jena</tag>
        <tag>javadoc</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[计算机基础笔记（freecodecamp)]]></title>
    <url>%2Fhfuter7712.github.io%2F2019%2F08%2F31%2FcomputerB%2F</url>
    <content type="text"><![CDATA[计算机由四个基本部分组成：输入，输出，CPU和存储器CPU对存储器具有独占访问权，无法通过输入和输出来访问内存而不适用CPU存储器可以分为短期存储器（RAM）和长期存储器 ，长期存储器通常是硬盘主板是连接硬件的东西，当数据导出流动试图找出该去哪里的时候，主板起到的是一个导流作用扩展卡：声卡、显卡之类的可以提升用户体验的东西电源：给计算机提供电力一个芯片由成千上万个晶体管（只能是0或1的开关）组成 ，所有这些晶体管塞进了一个芯片里一个芯片上集成的晶体管数量决定了芯片的大小与速度摩尔定律：观察到自从1965年芯片上的晶体管数量每两年增加一倍的一种规律（但是在近几年增加速度逐渐减慢） 数据的大小数据大小是按字节来计算的 最小的单位称之为1比特(bit)比特只能是0或14比特(bit)8比特(bit)，字节KB，1024个字节MB，1024的平方个字节GB，1024的立方个字节TB，1024的四次方个字节PB，1024的五次方个字节数据的速度数据速率是按照比特来计算的 音频下载中，用的是KB/s网速用的是MB/s网络中用GB/s此外，如果你看到你的网速有多少多少比特每秒，记住它永远比按你提到数据大小时的字节小8倍 所有数字（255及以下），字母和符号都可以被转化为计算机所理解的字节 —错题：“记住这些转化是一种很好的做法”我选择了true，但是其实是false，理由是“你只需要查阅就好了” 计算机的种类最大的一个类型称为超级计算机，一种使用一种叫做 并行处理 的技术同理用很多CPU处理同一问题的计算机下一种类型叫做服务器，服务器拥有并访问大量的数据或程序其次是工作站，一种和个人电脑非常类似的计算机，但是更耗能而且贵得多然后是个人电脑最后是微控制器 主板主板的构成是处理器和内存之间的桥梁扩展槽：可以插入任意提高计算及性能的东西 数据网络三种类型分别为局域网（LAN），广域网（WAN），虚拟专用网（VPN）局域网就像是一小组计算机连接在了一起。特征：离的很近广域网：两个以上的局域网长距离的连接起来一个广域网通常租用来自因特网公司的电缆来创建连接同样是连接局域网，广域网使用租用的电缆而VPN使用互联网 IP地址是基于位置分配的如果一个设备没有IP地址，因特网无法向它发送数据IP地址由位置所决定，起始于5个大型国际地区 软件软件是程序或者在硬件上运行的程序软件是写入硬件的代码有三个主要的操作系统： Windows，Max和Linux CDN（内容传递网络)CDN是一种分布式服务器，基于用户的地理位置向用户分发网页和其他Web内容目标：建立更高质量的网络连接 采样一个模拟声波看起来像任何东西计算机采集和测量很多不同的点，把他们转化成数字，就是所谓的采样 数据压缩压缩声音的一种常用方法是以更低的频率采样，另一种方式是从一个重点而不是从0开始采样，因此采集的声音更小在图像中：通过测量一组16个的像素来压缩，而不是独立的 路由器是连接不同的小范围网络的东西路由器甚至不必有完整的包的信息倘若一台电脑正试图将信息发送到另一个电脑时，数据可能会在不同的路由器之间分开，但是没关系，计算机仍然知道如何正确的把信息重新组合到一起所发送信息的小碎片称为数据包 包实际上是一小段二进制代码 源代码本身是程序员创建的文本文档编译器与解释器不同，编译器将其所有的工作都放在了程序员的端上 开源：意味着所有的文档和源代码是开放及可以访问的 控制台常用于显示系统管理级的消息 计算机安全字典攻击：尝试字典里的每一个字词，或者是它自己数据库中的常见词汇和很多人使用过的密码创建密码时，使用不同的类型，数字和符号，不要使用序列号学习加密和HTTPS来免受这些攻击HTTPS相比HTTP更加安全 ，因为向该网站所发送的密码和其他信息都被加密 DOM(Document Object Model)DOM是浏览器的内部，网页的程序化称呼，JS允许修改网页的DOM结构从技术上来讲，DOM是一种API DOM会告诉浏览器，一旦HTML被加载，他就已经准备好了，但是有时候CSS和JS还没进来 MDN（Mozilla Developer Network)是一个很棒的开源项目，不仅有JS相关文档，还有其他语言和主题的文档]]></content>
      <categories>
        <category>Coding(basic)</category>
      </categories>
      <tags>
        <tag>计算机</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[502 Bad Gateway]]></title>
    <url>%2Fhfuter7712.github.io%2F2019%2F08%2F31%2F502%2F</url>
    <content type="text"><![CDATA[今天在访问某站时出现了 502 Bad Gateway的错误提示上网搜索后知道如下该类错误是指错误网关，无效网关，并不是意味着上游服务器已关闭，而是上游服务器和网关/代理使用不一致的协议交换数据一般原因：向服务器发送请求，由于服务器当前链接过多，导致服务器方面无法给予正常相应（来自百度词条）]]></content>
      <categories>
        <category>coding</category>
      </categories>
      <tags>
        <tag>术语</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bootstrap学习]]></title>
    <url>%2Fhfuter7712.github.io%2F2019%2F08%2F30%2Fbootstrap1%2F</url>
    <content type="text"><![CDATA[网格系统example: &lt;div class=&quot;row&quot;&gt; &lt;div class=&quot;col-sm-3&quot;&gt;.col-sm-3&lt;/div&gt; &lt;div class=&quot;col-sm-3&quot;&gt;.col-sm-3&lt;/div&gt; &lt;div class=&quot;col-sm-3&quot;&gt;.col-sm-3&lt;/div&gt; &lt;div class=&quot;col-sm-3&quot;&gt;.col-sm-3&lt;/div&gt; &lt;/div&gt; 效果（每个div都赋予了不同颜色以分辨）:超小设备 .col-平板 .col-sm-桌面显示器 col-md- &lt;div class=&quot;row&quot;&gt; &lt;div class=&quot;col-sm-3 first&quot;&gt;.col-sm-3&lt;/div&gt; &lt;div class=&quot;col-sm-3 offset-sm-3 second&quot;&gt;.col-sm-3&lt;/div&gt; &lt;/div&gt; offset-sm-3相当于偏移一个col-sm-3效果: 颜色文本颜色(个人感觉可用于连接) &lt;p class=&quot;text-muted&quot;&gt;柔和的文本。&lt;/p&gt; &lt;p class=&quot;text-primary&quot;&gt;重要的文本。&lt;/p&gt; &lt;p class=&quot;text-success&quot;&gt;执行成功的文本。&lt;/p&gt; &lt;p class=&quot;text-info&quot;&gt;代表一些提示信息的文本。&lt;/p&gt; &lt;p class=&quot;text-warning&quot;&gt;警告文本。&lt;/p&gt; &lt;p class=&quot;text-danger&quot;&gt;危险操作文本。&lt;/p&gt; &lt;p class=&quot;text-secondary&quot;&gt;副标题。&lt;/p&gt; &lt;p class=&quot;text-dark&quot;&gt;深灰色文字。&lt;/p&gt; &lt;p class=&quot;text-light&quot;&gt;浅灰色文本（白色背景上看不清楚）。&lt;/p&gt; &lt;p class=&quot;text-white&quot;&gt;白色文本（白色背景上看不清楚）。&lt;/p&gt; 表格提供了特色表格，通过定义&lt;table class=&quot;table&quot;&gt; 来设置设置前:设置后:设置带条纹的表格:在table类的基础上再添加一个.table-striped黑色的表格（逼格) 添加类table-dark将上述两个合起来得到本人认为最霸气的表格可以通过设定其中不同的tr来实现在一个表格中有不同的效果 响应式图片图片的大小需要根据屏幕的大小自动适应添加类.img-fluid即可（本质是将图片的max-width设置为100%，height设为auto) 按钮来自菜鸟教程 &lt;button type=&quot;button&quot; class=&quot;btn&quot;&gt;基本按钮&lt;/button&gt; &lt;button type=&quot;button&quot; class=&quot;btn btn-primary&quot;&gt;主要按钮&lt;/button&gt; &lt;button type=&quot;button&quot; class=&quot;btn btn-secondary&quot;&gt;次要按钮&lt;/button&gt; &lt;button type=&quot;button&quot; class=&quot;btn btn-success&quot;&gt;成功&lt;/button&gt; &lt;button type=&quot;button&quot; class=&quot;btn btn-info&quot;&gt;信息&lt;/button&gt; &lt;button type=&quot;button&quot; class=&quot;btn btn-warning&quot;&gt;警告&lt;/button&gt; &lt;button type=&quot;button&quot; class=&quot;btn btn-danger&quot;&gt;危险&lt;/button&gt; &lt;button type=&quot;button&quot; class=&quot;btn btn-dark&quot;&gt;黑色&lt;/button&gt; &lt;button type=&quot;button&quot; class=&quot;btn btn-light&quot;&gt;浅色&lt;/button&gt; &lt;button type=&quot;button&quot; class=&quot;btn btn-link&quot;&gt;链接&lt;/button&gt; 这些按钮的类还可以用于&lt;a&gt;和&lt;input&gt;中 禁用按钮(个人感觉以后可以用于特定条件下的按钮设定，通过JS改变按钮的可用性，比如说要输入用户名才能点击下一步，否则禁用)添加类.disabled徽章我觉得这个可以有 &lt;p class=&quot;badge badge-danger&quot;&gt;警告&lt;/p&gt; &lt;p class=&quot;badge badge-dark&quot;&gt;失效&lt;/p&gt; &lt;p class=&quot;badge badge-info&quot;&gt;新消息&lt;/p&gt; &lt;p class=&quot;badge badge-light&quot;&gt;温馨提示&lt;/p&gt; &lt;p class=&quot;badge badge-primary&quot;&gt;主要&lt;/p&gt; &lt;p class=&quot;badge-secondary badge&quot;&gt;次要&lt;/p&gt; &lt;p class=&quot;badge-success badge&quot;&gt;注册成功&lt;/p&gt; &lt;p class=&quot;badge badge-warning&quot;&gt;warning&lt;/p&gt; 效果: 分页在&lt;ul&gt;标签中添加.pagination类，然后在下属&lt;li&gt;中添加.page-item类，然后在li下属的&lt;a&gt;中添加.page-link类 &lt;ul class=&quot;pagination&quot;&gt; &lt;li class=&quot;page-item&quot;&gt;&lt;a class=&quot;page-link&quot;&gt;Previous&lt;/a&gt;&lt;/li&gt; &lt;li class=&quot;page-item&quot;&gt;&lt;a class=&quot;page-link&quot;&gt;1&lt;/a&gt;&lt;/li&gt; &lt;li class=&quot;page-item&quot;&gt;&lt;a class=&quot;page-link&quot;&gt;2&lt;/a&gt;&lt;/li&gt; &lt;li class=&quot;page-item&quot;&gt;&lt;a class=&quot;page-link&quot;&gt;3&lt;/a&gt;&lt;/li&gt; &lt;li class=&quot;page-item&quot;&gt;&lt;a class=&quot;page-link&quot;&gt;4&lt;/a&gt;&lt;/li&gt; &lt;li class=&quot;page-item&quot;&gt;&lt;a class=&quot;page-link&quot;&gt;next&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; 效果: 同样的道理，如果想要设置链接不可点击，只要在li的class添加.disabled类即可 ———-分割线———- 以下内容需要添加下属语句 &lt;script src=&quot;https://cdn.staticfile.org/jquery/3.2.1/jquery.min.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;https://cdn.staticfile.org/popper.js/1.15.0/umd/popper.min.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;https://cdn.staticfile.org/twitter-bootstrap/4.3.1/js/bootstrap.min.js&quot;&gt;&lt;/script&gt; 在原先bootstrap link添加即可折叠内容 &lt;div class=&quot;container&quot;&gt; &lt;button type=&quot;button&quot; class=&quot;btn btn-primary&quot; data-toggle=&quot;collapse&quot; data-target=&quot;#demo&quot;&gt;简单的折叠&lt;/button&gt; &lt;div id=&quot;demo&quot; class=&quot;collapse&quot;&gt; this is a card which can hide yeah this is second paragraph third fourth &lt;/div&gt; &lt;/div&gt; 一开始进入的时候内容会隐藏，点击按钮后有一个下滑动画，显示出内容 下拉列表初始状态是一个带着下三角的按钮，点击会下拉一个列表example: &lt;div class=&quot;container&quot;&gt; &lt;div class=&quot;dropdown&quot;&gt; &lt;button type=&quot;button&quot; class=&quot;btn btn-primary dropdown-toggle&quot; data-toggle=&quot;dropdown&quot;&gt;省份&lt;/button&gt; &lt;div class=&quot;dropdown-menu&quot;&gt; &lt;a class=&quot;dropdown-item&quot; href=&quot;#&quot;&gt;福建&lt;/a&gt; &lt;a class=&quot;dropdown-item&quot; href=&quot;#&quot;&gt;湖北&lt;/a&gt; &lt;a class=&quot;dropdown-item&quot; href=&quot;#&quot;&gt;安徽&lt;/a&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; 效果: 导航(个人偏好的一种) 大体代码: &lt;div class=&quot;container&quot;&gt; &lt;ul class=&quot;nav nav-tabs&quot;&gt; &lt;li class=&quot;nav-item&quot;&gt; &lt;a class=&quot;nav-link&quot; data-toggle=&quot;tab&quot; href=&quot;#WH&quot;&gt;武汉&lt;/a&gt; &lt;/li&gt; &lt;li class=&quot;nav-item&quot;&gt; &lt;a class=&quot;nav-link&quot; data-toggle=&quot;tab&quot; href=&quot;#QZ&quot;&gt;泉州&lt;/a&gt; &lt;/li&gt; &lt;li class=&quot;nav-item&quot;&gt; &lt;a class=&quot;nav-link&quot; data-toggle=&quot;tab&quot; href=&quot;#XC&quot;&gt;宣城&lt;/a&gt; &lt;/li&gt; &lt;li class=&quot;nav-item&quot;&gt; &lt;a class=&quot;nav-link&quot; data-toggle=&quot;tab&quot; href=&quot;#SH&quot;&gt;上海&lt;/a&gt; &lt;/li&gt; &lt;/ul&gt; &lt;div class=&quot;tab-content&quot;&gt; &lt;div class=&quot;container tab-pane active&quot; id=&quot;QZ&quot;&gt; 泉州市隶属于福建，地级市 &lt;/div&gt; &lt;div class=&quot;container tab-pane fade&quot; id=&quot;WH&quot;&gt; 武汉市隶属于湖北，省会 &lt;/div&gt; &lt;div class=&quot;container tab-pane fade&quot; id=&quot;XC&quot;&gt; 宣城市隶属于安徽，地级市 &lt;/div&gt; &lt;div class=&quot;container tab-pane fade&quot; id=&quot;SH&quot;&gt; 上海，直辖市 &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; 效果图: 面包屑导航是一种基于网络层次信息的显示方式代码如下: &lt;div class=&quot;container&quot;&gt; &lt;ol class=&quot;breadcrumb&quot;&gt; &lt;li class=&quot;breadcrumb-item&quot;&gt;&lt;a href=&quot;#&quot;&gt;文档&lt;/a&gt;&lt;/li&gt; &lt;li class=&quot;breadcrumb-item&quot;&gt;&lt;a href=&quot;#&quot;&gt;功能性文档&lt;/a&gt;&lt;/li&gt; &lt;li class=&quot;breadcrumb-item active&quot;&gt;C++&lt;/li&gt; &lt;/ol&gt; &lt;/div&gt; 效果图: 幻灯片切换效果链接:https://www.runoob.com/bootstrap4/bootstrap4-carousel.html]]></content>
      <categories>
        <category>Coding(Front End)</category>
      </categories>
      <tags>
        <tag>HTML</tag>
        <tag>Bootstrap</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[.org--互联网的通用顶级域之一]]></title>
    <url>%2Fhfuter7712.github.io%2F2019%2F08%2F30%2Forg%2F</url>
    <content type="text"><![CDATA[.org域名是互联网的通用顶级域之一，适用于各类组织机构，全称为Origanizations.ORG任何人（包括盈利组织，个人，非营利组织等）都可以注册 规则(来自百度百科):1.只提供英文字母（大小写皆可），数字以及连接符-2.-不能用作开头和结尾3.长度不能超过63个字符]]></content>
      <categories>
        <category>coding</category>
      </categories>
      <tags>
        <tag>术语</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Jena全面学习+小细节]]></title>
    <url>%2Fhfuter7712.github.io%2F2019%2F08%2F29%2FJenaL%2F</url>
    <content type="text"><![CDATA[Jena实例代码二中有一个VCARD类，去官方javadoc看了也没解释是干啥的，后来在网上查了原来是电子名片的意思]]></content>
      <categories>
        <category>Coding(Project)</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Jena</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端页面设计时的那些乱七八糟的注意事项]]></title>
    <url>%2Fhfuter7712.github.io%2F2019%2F08%2F26%2Ffront-end%20first%20notice%2F</url>
    <content type="text"><![CDATA[各种RGB颜色:https://www.runoob.com/html/html-colornames.htmlHTML速查表:https://www.runoob.com/html/html-quicklist.htmlHTML标签列表:https://www.runoob.com/tags/html-reference.htmlHTML事件列表:https://www.runoob.com/tags/ref-eventattributes.htmlHTML拾色器:https://www.runoob.com/tags/html-colorpicker.html CSS参考手册:https://www.runoob.com/cssref/css-reference.htmlCSS Web安全字体:https://www.runoob.com/cssref/css-websafe-fonts.html XHTML是以XML格式编写的HTML注意:在XHTML中空元素必须包含关闭标签example: 不能写&lt;br&gt;,而是&lt;br /&gt;]]></content>
      <categories>
        <category>Coding(Front End)</category>
      </categories>
      <tags>
        <tag>HTML</tag>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Jena2]]></title>
    <url>%2Fhfuter7712.github.io%2F2019%2F08%2F11%2FJena2%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[mysql+D2RQ+D2R+sparql第一次实践]]></title>
    <url>%2Fhfuter7712.github.io%2F2019%2F08%2F07%2FmysqlD2RQ1%2F</url>
    <content type="text"><![CDATA[因为大创需求，需要将数据库中的内容转换成rdf然后给Apache Jena进行推理，因此对一系列的知识进行了学习，今天终于迎来了第一次综合实践首先我在mysql中构建了一个叫做test的数据库，然后建立了一个叫做metal的表随随便便输入了几个数据如下然后开始运用D2RQ处理进入D2RQ根目录打开cmd输入以下语句.\generate-mapping -u root -p yyn321 -o test.ttl jdbc:mysql:///test?useSSL=falseyyn321是数据库密码test.ttl是要生成的ttl文件的名字mysql:///后面跟的是需要进行处理的数据库的名字比如你的数据库名字是test,就这样写:jdbc:mysql:///test?是metro的话就jdbc:mysql:///metro?回车之后没有任何提示直接进入下一个语句在根目录下生成了对应的ttl文件，这个就是默认的mapping language映射文件打开可以看到一系列代码可以选择手工修改，本人这里暂时不动（先熟悉操作）再在刚刚的cmd中继续输入下列代码dump-rdf -o test.nt test.ttl和第一条语句一样，并没有提示任何东西，在根目录下生成了一个同名nt文件打开看到大量代码，这个就是所谓的RDF文件了，仔细观察都是三个一组接下来的操作便是通过这个文件打开D2R服务器在cmd中输入d2r-server test.ttl显示在服务器在2020端口 打开 在浏览器上进入2020端口显示页面如下单击metal,进入界面如下单击metal#1界面如下 返回主界面，点击最下列sparql窗口的链接即可进入sparql查询界面 在其中输入sparql语句即可进行查询 查询人数大于4的乐队查询乐队nightwish的歌曲]]></content>
      <categories>
        <category>Coding(Project)</category>
      </categories>
      <tags>
        <tag>D2RQ</tag>
        <tag>Sparql</tag>
        <tag>mysql</tag>
        <tag>D2R</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mysql数据库基础学习（一）]]></title>
    <url>%2Fhfuter7712.github.io%2F2019%2F08%2F07%2Fmysql1%2F</url>
    <content type="text"><![CDATA[启动mysql数据库以管理员身份打开cmd命令行工具,切换目录到mysql根目录的bin文件夹下初始化数据库mysqld --initialize --console执行完毕后，会输出root用户的默认密码输入安装命令mysqld install —启动mysql命令—net start mysql —登录本机的mysql数据库—mysql -u root -p之后会要求输入密码，输入即可输入exit或者quit退出登录 —-数据库操作—- USE 数据库名选择要操作的Mysql数据库，使用该命令后所有命令都只针对该数据库 SHOW DATABASES列出mysql数据库管理系统的数据库列表 SHOW TABLES列出指定数据库的所有表 CREATE 数据库可在登陆MySQL服务后使用create创建数据库CREATE DATEBASE 数据库名;如 CREATE DATEBASE TEST; DROP 数据库用drop命令删除数据库drop database 数据库名;以下是创建并删除一个数据库的实践 CREATE 数据表CREATE TABLE table_name(column_name column_type);column_name是表单名字，column_type是内容的数据类型example(来自菜鸟教程): CREATE TABLE IF NOT EXISTS `runoob_tbl`( `runoob_id` INT UNSIGNED AUTO_INCREMENT, `runoob_title` VARCHAR(100) NOT NULL, `runoob_author` VARCHAR(40) NOT NULL, `submission_date` DATE, PRIMARY KEY ( `runoob_id` ) )ENGINE=InnoDB DEFAULT CHARSET=utf8; DROP 数据表DROP TABLE table_name在进行删除表操作的时候要非常小心，因为执行删除命令后所有数据都会消失 INSERT INTO使用该语句向数据表中插入数据 INSERT INTO table_name(field1,field2,...fieldN) VALUES (value1,value2,...valueN); example(亲自实践):该操作向数据库中添加了一组数据，结果显示成功 SELECT 查询数据语法: SELECT column_name,column_name FROM table_name [WHERE Clause] [LIMIT N][ OFFSET M] example:该查询选择了曲目名字和乐队名字，乐队成员大于5且限制输出2条匹配 WHERE 提供条件查询 SELECT field1, field2,...fieldN FROM table_name1, table_name2... [WHERE condition1 [AND [OR]] condition2..... 可以用AND 或者OR制定一个或多个条件 UPDATE 更新用于更新也就是修改MySQL中的数据 UPDATE table_name SET field1=new-value1, field2=new-value2 [WHERE Clause] 注意，必须谨慎操作，因为如果少了WHERE条件语句，你的所有相应数据都会被修改将id为8的曲目submission_data更新为1999-08-04 DELETE 删除用于删除MySQL中的数据DELETE FROM table_name [WHERE Clause]和update一样，这两个语句必须谨慎操作，没有where语句的情况下，所有相应数据都会被删除 LIKE 字符串匹配用于WHERE语句中，主要适用于字符串类型的数据的选择 SELECT field1, field2,...fieldN FROM table_name WHERE field1 LIKE condition1 [AND [OR]] filed2 = &apos;somevalue&apos; example: &apos;%a&apos; 以a结尾 &apos;a%&apos; 以a开头 &apos;%a%&apos; 含有a &apos;_a_&apos; 三位字符串且a位于中间位置 &apos;_a&apos; 两位字符串且a位于末尾 &apos;a_&apos; 两位字符串且a位于开头 UNION用于连接两个以上的SELECT语句的结果到一个结果集合中，多个SELECT语句会删除重复的数据 SELECT expression1, expression2, ... expression_n FROM tables [WHERE conditions] UNION [ALL | DISTINCT] SELECT expression1, expression2, ... expression_n FROM tables [WHERE conditions]; DISTINCT:删除结果集中重复的数据ALL:返回所有数据集，包括重复的数据 ORDER BY 排序 SELECT field1, field2,...fieldN FROM table_name1, table_name2... ORDER BY field1 [ASC [DESC][默认 ASC]], [field2...] [ASC [DESC][默认 ASC]] 默认是ASC 升序排列，可以使用DESC修饰符来进行降序排列example:按照乐队名字降序排序按照乐队成员升序排序 GROUP BY 分组该语句根据一个或者多个列对结果进行分组 SELECT column_name, function(column_name) FROM table_name WHERE column_name operator value GROUP BY column_name; 使用WITH ROLLUP可以实现在分组统计数据基础上再进行相同的统计（SUM,AVG,COUNT…)example: 按照出现过的数字总和，并在最后求和按照出现过的数组求平均值按照每个乐队出现过的次数 MySQL菜鸟教程：https://www.runoob.com/mysql/mysql-tutorial.html]]></content>
      <categories>
        <category>Coding(Database)</category>
      </categories>
      <tags>
        <tag>数据库</tag>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[D2RQ数据导出-从数据库到RDF mapping language学习(一)]]></title>
    <url>%2Fhfuter7712.github.io%2F2019%2F08%2F06%2FD2RQLearn1%2F</url>
    <content type="text"><![CDATA[官方文档:R2RQ的映射结构:;模板:以下实例D2RQ映射将数据库中的表会议与本体中的类会议相关联，可以使用地图作为模板来编写自己的地图 # D2RQ Namespace @prefix d2rq: &lt;http://www.wiwiss.fu-berlin.de/suhl/bizer/D2RQ/0.1#&gt; . # Namespace of the ontology @prefix : &lt;http://annotation.semanticweb.org/iswc/iswc.daml#&gt; . # Namespace of the mapping file; does not appear in mapped data @prefix map: &lt;file:///Users/d2r/example.ttl#&gt; . # Other namespaces @prefix rdfs: &lt;http://www.w3.org/2000/01/rdf-schema#&gt; . @prefix xsd: &lt;http://www.w3.org/2001/XMLSchema#&gt; . map:Database1 a d2rq:Database; d2rq:jdbcDSN &quot;jdbc:mysql://localhost/iswc&quot;; d2rq:jdbcDriver &quot;com.mysql.jdbc.Driver&quot;; d2rq:username &quot;user&quot;; d2rq:password &quot;password&quot;; . # ----------------------------------------------- # CREATE TABLE Conferences (ConfID int, Name text, Location text); map:Conference a d2rq:ClassMap; d2rq:dataStorage map:Database1; d2rq:class :Conference; d2rq:uriPattern &quot;http://conferences.org/comp/confno@@Conferences.ConfID@@&quot;; . map:eventTitle a d2rq:PropertyBridge; d2rq:belongsToClassMap map:Conference; d2rq:property :eventTitle; d2rq:column &quot;Conferences.Name&quot;; d2rq:datatype xsd:string; . map:location a d2rq:PropertyBridge; d2rq:belongsToClassMap map:Conference; d2rq:property :location; d2rq:column &quot;Conferences.Location&quot;; d2rq:datatype xsd:string; . 属性:D2RQ : jdbcDSN JDBC数据库URL，是一个表单的字符串D2RQ : jdbcDriver 数据库的JDBC驱动程序类名称D2RQ : username 若数据库有要求，用户名D2RQ : password 若数据库有要求，密码D2RQ : resultSizeLimit 整数值，作为LIMIT添加到所有SQL查询中，设置从大型数据库返回结果数的上限D2RQ : FETCHSIZE 整数值，指定每个数据库请求要求检索的行数D2RQ : startupSQLScript 启动的时候要执行的SQL脚本的URL，用于初始化连接与测试 示例一：连接mysql数据库 map:Database1 a d2rq:Database; d2rq:jdbcDSN &quot;jdbc:mysql://localhost/iswc&quot;; d2rq:jdbcDriver &quot;com.mysql.jdbc.Driver&quot;; d2rq:username &quot;user&quot;; d2rq:password &quot;password&quot;; . 保持长期的连接某些数据库服务器可能会在一段时间后关闭客户端连接（如mysql，为8小时），为了保持长期的连接（可能是为了转换数据），可以将D2R配置为定期运行“noop”查询，可以使用特殊属性启用该功能jdbc:keepAliveexample: @prefix jdbc: &lt;http://d2rq.org/terms/jdbc/&gt; . map:database a d2rq:Database; # ... other database configuration ... jdbc:keepAlive &quot;3600&quot;; # value in seconds jdbc:keepAliveQuery &quot;SELECT 1&quot;; # (optionally to override default noop query) . 映射引擎的全局配置d2rq : Configuration控制D2RQ的全局行为D2RQ : serveVocabulary 是否提供推断和用户提供的词汇数据D2RQ : useAllOptimizations 是否使用出血边缘优化(bleeding edge optimizations) 创建RDF资源d2rq :ClassMap 表示OWL本体或者RDFS模式的类或一组类似类，类映射定义了如何识别类的实例，它连接到a d2rq : Database 并且具有一组d2rq:PropertyBridges附加属性的实例 d2rq:ClassMap属性 example: —–使用URI模式标识类映射实例—– map:PaperClassMap a d2rq:ClassMap; d2rq:uriPattern &quot;http://www.conference.org/conf02004/paper#Paper@@Papers.PaperID@@&quot;; d2rq:class :Paper; d2rq:classDefinitionLabel &quot;paper&quot;@en; d2rq:classDefinitionComment &quot;A conference paper.&quot;@en; d2rq:dataStorage map:Database1; . 涉及到的d2rq:uriPattern 指定将用于标识此类映射实例的URI模式d2rq:class RDFS或者OWL类，该ClassMap生成的所有资源都是此类的实例d2rq:classDefinitionLabel 指定将rdfs:label用于所有关联类定义的标签，支持多个标签d2rq:classDefinitionComment 指定将作为rdfs:comment所有关联类定义的标签d2rq:dataStorage 引用d2rq:Database存储实例数据的位置 —–具有空白节点的类映射实例—– map:Topic a d2rq:ClassMap; d2rq:bNodeIdColumns &quot;Topics.TopicID&quot;; d2rq:class :Topic; d2rq:classDefinitionLabel &quot;topic&quot;@en; d2rq:classDefinitionComment &quot;A topic.&quot;@en; d2rq:dataStorage map:Database1; . d2rq:bNodeIdColumns用”TableName.ColumnName”符号表示的逗号分隔的列名列表 ,此类映射的实例将是空白节点，这些列的每个不同元组有一个不同的空白节点 d2rq:PropertyBridge属性用途，向资源添加属性example: map:PaperTitle a d2rq:PropertyBridge; d2rq:belongsToClassMap map:Paper; d2rq:property :title; d2rq:column &quot;Papers.Title&quot;; d2rq:lang &quot;en&quot;; d2rq:propertyDefinitionLabel &quot;title&quot;@en; d2rq:propertyDefinitionComment &quot;A paper&apos;s title.&quot;@en; . 一个简单的property bridge该例子将:title属性添加到所有由map:Paper类映射产生的资源d2rq:column对于具有文字值的属性，包含文字值的数据库列，列名必须在表单中给出”TableName.ColumnName”d2rq:property 连接ClassMap与桥创建的对象或者文字的RDF属性，必须为每个属性桥指定 d2rq 映射语言官方文档：http://d2rq.org/d2rq-language]]></content>
      <categories>
        <category>Coding(project)</category>
      </categories>
      <tags>
        <tag>D2RQ</tag>
        <tag>RDF</tag>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo博文图片添加测试]]></title>
    <url>%2Fhfuter7712.github.io%2F2019%2F08%2F06%2FimageTest%2F</url>
    <content type="text"><![CDATA[.PNG格式 .JPG格式 .CR2格式结果：加载失败，233，果然相机导出的raw格式确实很难搞，连adobe pr也不支持]]></content>
      <categories>
        <category>Coding(test)</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Jena推理学习（一）]]></title>
    <url>%2Fhfuter7712.github.io%2F2019%2F08%2F05%2FJenaInterface%2F</url>
    <content type="text"><![CDATA[官方文档: Jena推理子系统旨在将一系列推理引擎或者推理器插入Jena，这些引擎用于导出额外的RDF断言（RDF assertions）这些RDF断言来自某些基本RDF以及任何可选的本体信息以及与推理器相关联的公理和规则支持使用RDF和OWL语言这些语言允许从实例数据和类描述中推理出其他事实这个机制（machinery）设计的非常通用，它包括一个通用规则引擎，可用于许多RDF处理或转换任务 在RDF中，模式（schema，也称为Ontology AKA tbox）数据和实例（instance，也称为AKA abox)之间没有强烈分离(strongly)，因此任何数据无论是类相关还是实例相关，都可包含在bind或者在bindSchema中 通用推理器对于每种类型的推理器，都有一个工厂类(factory class)，其实例可以用来创建关联实例Reasoner，可以通过直接转到已知工厂类并使用theInstance()静态方法或者从全局检索来定位ReasonerRegistry工厂实例，该全局存储着由分配给推理的URI索引的工厂实例(存储实例）构建reasoners的工厂对象就是为了简化注册表服务的设计和扩展，一旦有了一个推理器实例，同一个实例可以在不同的数据集起作用并多次重复使用，而不会互相影响个人总结：定义了一个推理器实例便可以通用，多用一旦有了推理器实例，就可以将其附加到一组RDF数据上创建推理模型，可以通过将所有RDF数据放入一个模型中或分成两个组件（模式schema与实例数据instance）来完成,官方PS：一些外部reasoners可能需要硬分离，对于所有内置reasoners，分离是任意的这种分离的主要价值是 允许从一组数据中的一些推论有效的应用在几个辅助数据集中（一般是实例数据集） —–推理模型的操作—–对于大部分应用程序，只需要创建一个包含一些推理步骤的模型，使用ModelFactory方法然后运行在标准Jena Model API中所包含的语句即可，但是有时候需要获得虚拟三元组所没有的更多控制处理以及额外的推理器性能（sometimes it is necessary to gain more control over the processing or to access additional reasoner features not available as virtual triples.）为了使用推理器测试数据集的不一致性，使用InfModel.validate接口，该接口将对架构和实例数据进行全局检查，查找不一致性它包括一个简单的通过/失败标志ValidityReport.isValid()和一个特定报告列表ValidityReport.Report 接口的实例,详细说明任何检测到的不一致 RDFS推理器Jena包含一个RDFS推理器，它支持RDF核心工作组（RDF Semantics）描述的几乎所有RDFS蕴含要访问该推理器可以使用ModelFactory.createRDFSModel或者手动访问ReasonerRegistery.getRDFSReasoner() 在Jena中，可以通过将包含空白节点的图形转换为包含变量代替空白节点的等效查询来实现简单包含，这样的查询可以直接匹配文字节点，RDF API可以用于提取文字的数据类型分为三种配置—Full(完整)—实现了所有的RDFS公理和闭包规则， 除了exception of bNode entailments and datatypes (rdfD 1) ，是极其昂贵的模式，因为需要检查数据图中所有语句是否可以使用容器成员资格属性 —Default(默认)—省略了对容器成员资格属性的昂贵检查，使用“一切都是资源”以及“用作属性的所有东西都是一个”规则，该模式仍然包含所有公里规则 —Simple(简单)—省略了所有公理，实现了SubPropertyOf和subClassOf关系的传递闭包，域和范围蕴涵（the domain and range entailments）以及SubPropertyOf和subClassOf的含义 Jena RDFS实现尚未通过数据库模型进行测试和评估，Jena架构使构建此类模型变得容易，但是在没有缓存的情况下，预计性能会很差]]></content>
      <categories>
        <category>大创</category>
      </categories>
      <tags>
        <tag>Jena</tag>
        <tag>知识推理</tag>
        <tag>知识图谱</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Javascript+jQuery+API]]></title>
    <url>%2Fhfuter7712.github.io%2F2019%2F08%2F05%2FJavascript4%2F</url>
    <content type="text"><![CDATA[$(document).ready()该函数中的代码只会在页面加载的时候运行一次 API(Application Programming Interface) 应用程序接口 可以通过浏览器navigator获取我们当前所在的位置 geolocation位置的信息包括longitude和latitude样例代码如下，将会看到一个是否允许获取当前位置的提示，如果允许，输出的将是当前位置所在的经纬度 if (navigator.geolocation) { navigator.geolocation.getCurrentPosition(function(position) { $(&quot;#data&quot;).html(&quot;latitude: &quot; + position.coords.latitude + &quot;&lt;br&gt;longitude: &quot; + position.coords.longitude); }); }]]></content>
      <categories>
        <category>Coding(basic)</category>
      </categories>
      <tags>
        <tag>jQuery</tag>
        <tag>Javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Javascript中关于sort()函数的注意事项]]></title>
    <url>%2Fhfuter7712.github.io%2F2019%2F08%2F05%2FJSsort%2F</url>
    <content type="text"><![CDATA[JS中用于数组的sort()函数，咋一看是排序数组，但是和C中的sort()函数不同，sort（）若没有生命参数，是默认按照字符编码的顺序进行排序的，并不是按照从大到小或从小到大，如果要按照顺序排序的话，需要另外定义一个函数用于实现功能从小到大排序: function sortNumber(a,b) { return a-b; }]]></content>
      <categories>
        <category>Coding(basic)</category>
      </categories>
      <tags>
        <tag>Javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Javascript中剔除数组中的假值]]></title>
    <url>%2Fhfuter7712.github.io%2F2019%2F08%2F05%2FJSArrayN%2F</url>
    <content type="text"><![CDATA[刚刚在网上做一个题目，实则感慨就是题目很简单，就是要剔除一个数组中所有假值包括false、null、0、&quot;&quot;、undefined 和 NaN打算用.filter()外加过滤check函数做的一开始写的check函数如下return !(member === false || member === null || member === 0 || member === undefined || isNaN(member));很复杂，而且还有bug就是当正常的字符串成员出现的时候也会被滤掉后来发现是isNaN()这个地方有问题，上网查阅发现只要不是数字的一律都会被这个函数判定为true刷掉这下坏了，玩意isNaN和正常字符串一起出现呢。。NaN这玩意可是连自己本身都不相等的呢后来想了想，假值，，，emmmmm…做点小修改return member;成功AC只要member是假值，return的就会是false,因此可以顺利剔除所有假值]]></content>
      <categories>
        <category>Coding(basic)</category>
      </categories>
      <tags>
        <tag>Javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Javascript用正则表达式替代字符串中的标点符号]]></title>
    <url>%2Fhfuter7712.github.io%2F2019%2F08%2F05%2FJSreg%2F</url>
    <content type="text"><![CDATA[当在处理字符串的时候要对其中的标点符号进行处理时，用if==&amp;&amp;肯定是行不通的，因为太麻烦了，这时候正则表达式就派上用场了正则表达式以/开始，以/结尾[]表示匹配其中所有内容记住标点符号要用转义符号，之间用|间隔/[\-|\_|\(|\)|\+|\=|\{|\[|\]|\}|\;|\:|\&#39;|\&quot;|\,|\.|\/|\?]/gg代表全局模式，运用于所有字符串，即匹配所有符合条件的字符]]></content>
      <categories>
        <category>Coding(basic)</category>
      </categories>
      <tags>
        <tag>Javascript</tag>
        <tag>正则表达式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[佳能EOS M10 刷魔灯实践]]></title>
    <url>%2Fhfuter7712.github.io%2F2019%2F08%2F03%2FCanonM10-tecdee%2F</url>
    <content type="text"><![CDATA[结果显而易见的失败了！虽然本人努力的查阅资料和尝试首先先把魔灯最新版下了（很有野心），然后查看相关文档需要佳能2.02固件，进相机一看，1.10，不行啊就去官网查阅了一下，M系列！记住这个系列固件已经升级到2.03了，作为M10，肯定是要下的啊按照操作，格式化了一张64G的存储卡将固件文件放入其中，然后，，，点击升级没反应怎么可能，M系列啊！以为是存储卡的问题，换了一张16G的存储卡，也进行了格式化没反应、、后来在晚上继续查阅，在官网M10介绍下看到了一条消息如果固件为1.10则不用继续升级what?于是临时又去官网搜了搜，最后终于发现了一个很现实的事实佳能有一个M系列的2.03固件升级，同时还有一个M10的1.10升级！也就是说M10被孤立了、、、好吧，入门中的入门机果然是没人权的也不用折腾了，233，还是等以后有钱了换机子吧，醉了]]></content>
      <categories>
        <category>photograph</category>
      </categories>
      <tags>
        <tag>摄影</tag>
        <tag>魔灯</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RDF结合Jena初步基础学习（一)]]></title>
    <url>%2Fhfuter7712.github.io%2F2019%2F08%2F03%2FRDF%2BJena%2F</url>
    <content type="text"><![CDATA[资源具有属性Jena是一个Java API，可用于创建和操作RDF图，Jena有对象类表示图形，资源，属性和文字表示资源的接口: Resource表示属性的接口: Property表示文字的接口: Literal在Jnea中，图形称为模型，由接口 Model 表示 Model model = ModelFactory.createDefaultModel();使用该方法创建基于内存的模型Resource joinSmith = model.createResource(personURI);使用该方法创建资源 “常量”类:VCARD，该类保存表示VCARD模式中所有定义的对象 joinSmith.addProperty(VCARD.FN, fullName);给资源添加属性 创建资源和添加属性还可以更紧凑的以级联样式编写: Resource joinSmith = model.createResource(personURI) .addProperty(VCARD.FN , fullName); 可定义空节点model.createResource()括号内不含参数即可定义一个空节点 RDF模型中一般一个语句包含三个部分subject:箭头出发点predicate:箭头object: 箭头目的地可称为主语，谓语和宾语主语——谓语——&gt;宾语 example: // list the statements in the Model StmtIterator iter = model.listStatements(); // print out the predicate, subject and object of each statement while (iter.hasNext()) { Statement stmt = iter.nextStatement(); // get next statement Resource subject = stmt.getSubject(); // get the subject Property predicate = stmt.getPredicate(); // get the predicate RDFNode object = stmt.getObject(); // get the object System.out.print(subject.toString()); System.out.print(&quot; &quot; + predicate.toString() + &quot; &quot;); if (object instanceof Resource) { System.out.print(object.toString()); } else { // object is a literal System.out.print(&quot; \&quot;&quot; + object.toString() + &quot;\&quot;&quot;); } System.out.println(&quot; .&quot;); } listStatements() 方法该方法返回一个StmIterator, 一种可以遍历模型中所有语句的迭代器(这里的谷歌翻译真是醉了，还好切回英文读懂了，不然简直了) nextStatement() 方法该方法从迭代器中返回当前的下一个语句使用Statement 进行一个语句的初始化Statement stmt = iter.nextStatement();在此基础上分别通过.getSubject()获取该语句的主语subject.getPredicate() 获取该语句的谓语Predicate.getObject()获取该语句的宾语Object iter.hasNext()个人理解: iter即当前迭代器，`hasNext（）是一个布尔型函数，如果迭代器当前位置之后没有语句了，就返回false,否则返回true .write(System.out)方法 将一个模型以RDF的形式写出来model.write(System.out); 要写入大文件并保留空白节点，请以N-TRUPLES格式写入model.write(System.out,&quot;N-TRIPLES&quot;); ===从文件中读取RDF===example: // create an empty model Model model = ModelFactory.createDefaultModel(); // use the FileManager to find the input file InputStream in = FileManager.get().open( inputFileName ); if (in == null) { throw new IllegalArgumentException( &quot;File: &quot; + inputFileName + &quot; not found&quot;); } // read the RDF/XML file model.read(in, null); // write it to standard out model.write(System.out); 使用.read()函数来对文件进行读取model.read(in,null);in为创建的输入流 setNsPrefix(String prefix,String URI)声明命名空间URI可以缩写成prefix(为了方便，因为有些命名空间真的太长了，每次写非常麻烦)，Jena要求prefix是一个合法的XML命名空间名称，并URI以非名称字符结尾 给定资源的URI，可以用下列方法从模型中检索资源对象Resource name = model.getResource(johnSmithURI);访问资源的属性如下Resource.getProperty(Property p); —查询模型—Model.listStatements() 列出模型中所有语句，但是不适用于数据量大的模型 Model.listStatementWithProperty(Property p,RDFNode o)将会返回一个迭代器，包含所有含有属性p，并且value是o的资源 选择器Selector selector = new SimpleSelector(subject, predicate, object);如果三个参数中任意一个为null,将相当于Sparql中的SELECT *如果三个参数都为null,则选择模型中的所有语句Selector selector = new SimpleSelector(null,VCARD.FN,null);将选择谓语是VCARD.FN的所有语句 容器 Bag是无序集合 ALT是一种旨在代表替代品的无序集合 SEQ是有序集合 创建一个Bag容器Bag smiths = model.createBag();容器接口提供一个迭代器来列出容器的内容NodeIterator iter2 = smiths.iterator();可以像上述那样用迭代器遍历 if (iter2.hasNext()) { System.out.println(&quot;The bag contains:&quot;); while (iter2.hasNext()) { System.out.println(&quot; &quot; + ((Resource) iter2.next()) .getProperty(VCARD.FN) .getString()); } } else { System.out.println(&quot;The bag is empty&quot;); } 官方教程之一: http://jena.apache.org/tutorials/rdf_api.html如何在Eclipse中配置Jena : http://jena.apache.org/tutorials/using_jena_with_eclipse.html]]></content>
      <categories>
        <category>Coding(Project)</category>
      </categories>
      <tags>
        <tag>RDF</tag>
        <tag>Java</tag>
        <tag>Jena</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Sparql基础学习（四）]]></title>
    <url>%2Fhfuter7712.github.io%2F2019%2F08%2F03%2FSparqlLearn4%2F</url>
    <content type="text"><![CDATA[四种查询格式 SELECT使用该格式结果直接返回所定义变量和它们绑定的数据，和SQL一样，SELECT *用于选取所有的变量 CONSTRUCT返回由图形模板中一个指定单一的RDF图，通过在解决方案序列中获取每个查询解决方案，替换图形模板的变量，然后合成RDF图（见基础学习（一）中末尾的例子） ASKASK返回的是yes或者no，如果对应的查询有结果的话，结果输出yes如果对应的查询没有结果则返回no DESCRIBE该模式返回包含有关资源的RDF数据的单个结果RDF图该DESCRIBE表单获取解决方案中标识的每个资源以及IRI直接命名的任何资源，并通过任何可以用的信息的“描述”来组装单个RDF图，同理,DESCRIBE *是查询所有变量的缩写 数据类型 类型文字值((typed literals) xsd:integerxsd:decimalxsd:floatxsd:doublexsd:stringxsd:booleanxsd:dateTime Filter函数中的逻辑关系与运算符Filter作为一个过滤器函数也有 ||与&amp;&amp;两种运算符其中有三种对应的值,T(true),F(false)和E(error) 对应关系如下(来自官方文档) A B A || B A &amp;&amp; B T T T T T F T F F T T F F F F F T E T E E T T E F E E F E F E F E E E E bound函数 如果函数中的变量绑定到值(???)个人理解:意思应该是如果匹配中含有该类型变量，则视为绑定成功返回true,否则返回false,若匹配带有NaN或者INF类型的的被视为绑定成功example: data: @prefix foaf: &lt;http://xmlns.com/foaf/0.1/&gt; . @prefix dc: &lt;http://purl.org/dc/elements/1.1/&gt; . @prefix xsd: &lt;http://www.w3.org/2001/XMLSchema#&gt; . _:a foaf:givenName &quot;Alice&quot;. _:b foaf:givenName &quot;Bob&quot; . _:b dc:date &quot;2005-04-04T04:04:04Z&quot;^^xsd:dateTime 查询语句: PREFIX foaf: &lt;http://xmlns.com/foaf/0.1/&gt; PREFIX dc: &lt;http://purl.org/dc/elements/1.1/&gt; PREFIX xsd: &lt;http://www.w3.org/2001/XMLSchema#&gt; SELECT ?name WHERE { ?x foaf:givenName ?givenName . OPTIONAL { ?x dc:date ?date } . FILTER ( bound(?date) ) } 结果: givenName &quot;Bob&quot; 可以看出，结果仅返回了带有date值得的Bob，另外一个例子中使用的是!bound,与改例子相反，匹配的是不含date类型的匹配，因此结果为&quot;Alice&quot; isIRI 函数若果该函数中参数为一个合法IRI，那么返回true即匹配，否则不匹配（用在Filter函数中作为过滤条件) isBlank函数如果函数参数是一个空白节点，返回true，否则返回false同样用在Filter中作为过滤条件 isLiteral若函数参数是一个字符串，返回true，否则返回falseexample: _:a foaf:name &quot;Alice&quot;. _:a foaf:mbox &lt;mailto:alice@work.example&gt; . _:b foaf:name &quot;Bob&quot; . _:b foaf:mbox &quot;bob@work.example&quot; . Alice所含有的mbox是一个IRI，Bob所含有的mbox是一个字符串 str函数个人理解:就是将相应的IRI转化为字符串进行处理example:在对IRI进行筛选时这个函数相当有用regex(str(?mbox), &quot;@work.example&quot;)作用是筛选出带有”@work.example”的IRI，所以要将IRI转换为字符串处理 SPARQL官方文档：https://www.w3.org/TR/rdf-sparql-query/]]></content>
      <categories>
        <category>Coding(Project)</category>
      </categories>
      <tags>
        <tag>Sparql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Javascript基础学习（三）]]></title>
    <url>%2Fhfuter7712.github.io%2F2019%2F08%2F02%2FJavascript3%2F</url>
    <content type="text"><![CDATA[用构造函数创建对象构造函数通常采用大写字母开头，以便把自己和其他普通函数区分开example: var Animal = function(){ this.legs = 4; this.heart = 1; }; this指向被该构造函数创造出来的对象 new 关键字 掉用构造函数构造一个实例的方法var myCar = new Car() 构造函数可添加参数example: var Car = function(wheels,seats,engines){ this.wheels=wheels; this.seats=seats; this.engines=engines; }; 在调用时传入参数即可var myCar = new Car(4,2,5); 在设置构造函数时，在函数体中用var代替this声明变量即可声明私有变量与私有方法 map方法map方法可以方便的迭代数组会迭代数组中的每一个元素，并根据回调函数来处理每一个元素，最后返回一个新数组（不会改变原始数组）example:让数组ArrayA每一项+3,并存储到newArray中 var newArray = ArrayA.map(function(val){ return val+3; }; reduce方法数组方法reduce用来迭代一个数组，并将其累积到一个值中第一个参数是一个累加器回调函数第二个参数是一个可选的参数，比用来设置累加器的初始值example:让ArrayA数组中所有元素都累加: var sum; sum = ArrayA.reduce(function(pre,cur){ return pre + cur; },sum); filter函数话说在学sparql的时候也有这玩意呢，果真过滤器嘛该函数传入一个回调函数，该回调函数会携带一个参数，参数为当前迭代的项所返回表达式中若数组元素使该表达式为真时加入新数组，为假时则不添加example: var newArray = ArrayA.filter(function(val){ return val&lt;6; }); 上述代码将ArrayA数组中小于6的元素传入newArray数组中 reverse方法reverse方法是对一个数组进行翻转，传入一个新的数组中var newArray = ArrayA.reverse() concat方法该方法可以用来把两个数组的内容合并到一个数组中example:连接secondArray到firstArray后面var newArray = firstArray.concat(secondArray); split方法可以按照指定分隔符将字符串分为数组example:将一个字符串按照字符s分割成数组var newArray=ArrayA.split(&quot;s&quot;); join方法可以使用该方法把数组转换成字符串，里面的每一个元素用指定的连接符连接example: ArrayA=[&quot;I&quot;,&quot;Jerry&quot;,&quot;Tom&quot;]; var stringA = ArrayA.split(&quot; and &quot;); //结果stringA=“I and Jerry and Tom&quot;]]></content>
      <categories>
        <category>Coding(basic)</category>
      </categories>
      <tags>
        <tag>Javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Sparql基础学习(三)]]></title>
    <url>%2Fhfuter7712.github.io%2F2019%2F08%2F02%2FSparqlLearn3%2F</url>
    <content type="text"><![CDATA[Filters的作用域FILETER是对其出现的整个组的限制，因此只要大括号内有FILTER，解决方案都是相同的 Basic Garph Patterns Basic Graph Patterns,where a set of triple patterns must match example: { ?x foaf:name ?name . ?x foaf:mbox ?mbox . } 是一组基本图形模式，由两个三重模式组成 { ?x foaf:name ?name . FILTER regex(?name, &quot;Smith&quot;) ?x foaf:mbox ?mbox . } 在上述基础上添加了FILTER 包含可选(OPTIONAL关键字)语法如下:{OPTIONAL{pattern}}个人理解:由于不是所有的RDF图中都具有完整的结构，有些RDF会缺乏部分属性，因此OPTIONAL的作用就是在OPTIONAL的括号内的属性如果匹配，即选上，如果可选部分不匹配，但是其他基础属性都匹配的话，也会认定为是匹配的就比方说上大学，有很多人是有加分项的，有加分项的人可以被录取并标明，但是没有加分项的人也可以被录取，这就是OPTIONAL的功能 example:数据: @prefix foaf: &lt;http://xmlns.com/foaf/0.1/&gt; . @prefix rdf: &lt;http://www.w3.org/1999/02/22-rdf-syntax-ns#&gt; . _:a rdf:type foaf:Person . _:a foaf:name &quot;Alice&quot; . _:a foaf:mbox &lt;mailto:alice@example.com&gt; . _:a foaf:mbox &lt;mailto:alice@work.example&gt; . _:b rdf:type foaf:Person . _:b foaf:name &quot;Bob&quot; . 查询语句: PREFIX foaf: &lt;http://xmlns.com/foaf/0.1/&gt; SELECT ?name ?mbox WHERE { ?x foaf:name ?name . OPTIONAL { ?x foaf:mbox ?mbox } } 结果: name mbox &quot;Alice&quot; &lt;mailto:alice@example.com&gt; &quot;Alice&quot; &lt;mailto:alice@work.example&gt; &quot;Bob&quot; 可见name为Bob的这项匹配即使mbox为空白（即在mbox方面不匹配)也可以在最终被认定为匹配 UNION关键字个人理解：用UNION链接的模式中满足任意一个即可匹配example:数据: @prefix dc10: &lt;http://purl.org/dc/elements/1.0/&gt; . @prefix dc11: &lt;http://purl.org/dc/elements/1.1/&gt; . _:a dc10:title &quot;SPARQL Query Language Tutorial&quot; . _:a dc10:creator &quot;Alice&quot; . _:b dc11:title &quot;SPARQL Protocol Tutorial&quot; . _:b dc11:creator &quot;Bob&quot; . _:c dc10:title &quot;SPARQL&quot; . _:c dc11:title &quot;SPARQL (updated)&quot; . 查询语句 PREFIX dc10: &lt;http://purl.org/dc/elements/1.0/&gt; PREFIX dc11: &lt;http://purl.org/dc/elements/1.1/&gt; SELECT ?title WHERE { { ?book dc10:title ?title } UNION { ?book dc11:title ?title } } 结果 title &quot;SPARQL Protocol Tutorial&quot; &quot;SPARQL&quot; &quot;SPARQL (updated)&quot; &quot;SPARQL Query Language Tutorial&quot; 可以看出，凡是满足三重模式第三项中为”title”的都成功匹配了二而第二项可以为dc10或者dc11，这两个也是UNION连接的两个条件 FROM关键字SPARQL查询可以使用FROM和FROM NAMED字句来指定要用于匹配的数据集，以描述RDF数据集 由许多FROM和FROM NAMED 自己产生的数据集是: 一个默认图谱(graph)，由FROM字句中引用的图谱的RDF合并形成 一组(IRI,图谱)对，每个FROM NAMED字句一个 每个FROM语句都包含一个IRIexample: PREFIX foaf: &lt;http://xmlns.com/foaf/0.1/&gt; SELECT ?name FROM &lt;http://example.org/foaf/aliceFoaf&gt; WHERE { ?x foaf:name ?name } 如果一个查询包含多个FROM，那么最终的默认图谱是这些FROM所引用所有图谱的合并 使用FROM NAMED来匹配RDF数据集中的命名图 GRAPH关键字GRAPH关键字用于将图形模式与数据集中的每个命名图形相匹配，并形成解决方案可将其后面的变量绑定到匹配的图谱的IRIexample: WHERE { GRAPH?src {?x foaf：mbox &lt;mailto：bob@work.example&gt;. ?x foaf：nick?bobNick } } 最终src匹配到的都是类似&lt;http://example.org/foaf/aliceFoaf&gt;的IRI同时GRAPH还可以限制应用于特定图谱的匹配 重复的解决方案如果在查询语句中没有DISTINCT或者REDUCED关键字，重复的解决方案将会被保留，也就是说不同的匹配可能会相同DISTINCT该关键字用法如下SELECT DISTINCT ?name WHERE{ ?x foaf:name ?name }该方法将会消除所有重复的解决方案REDUCED该关键字用法如下SELECT REDUCED ?name WHERE { ?x foaf:name ?name }顾名思义，该方法将会减少重复的次数，范围从1~未使用上述两个关键字之间不等也就是说仍然可能不变，比如重复的匹配有4个，那么使用REDUCED后可能就剩1个，2个，3个甚至仍然还是四个 OFFSET关键字该关键字定义在特定的偏移数量后的方法，顾名思义，OFFSET即偏移，OFFSET 0没有实际作用 LIMIT关键字这个关键字想必也不难理解，就是限制结果显示匹配的数量，假设有10个满足条件匹配成功，使用LIMIT 5使得最终结果只显示5个匹配 SPARQL官方教程（英文）：https://www.w3.org/TR/rdf-sparql-query/]]></content>
      <categories>
        <category>Coding(Project)</category>
      </categories>
      <tags>
        <tag>Sparql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS对象数组操作属性小雷区]]></title>
    <url>%2Fhfuter7712.github.io%2F2019%2F08%2F01%2FJSwrong1%2F</url>
    <content type="text"><![CDATA[在网上学习实践的时候遇到了一个bug，de了好长时间，后来终于de出来了内容是这样的，首先有个存储着通讯录的对象数组如下 var contacts = [ { &quot;firstName&quot;: &quot;Akira&quot;, &quot;lastName&quot;: &quot;Laine&quot;, &quot;number&quot;: &quot;0543236543&quot;, &quot;likes&quot;: [&quot;Pizza&quot;, &quot;Coding&quot;, &quot;Brownie Points&quot;] }, { &quot;firstName&quot;: &quot;Harry&quot;, &quot;lastName&quot;: &quot;Potter&quot;, &quot;number&quot;: &quot;0994372684&quot;, &quot;likes&quot;: [&quot;Hogwarts&quot;, &quot;Magic&quot;, &quot;Hagrid&quot;] }, { &quot;firstName&quot;: &quot;Sherlock&quot;, &quot;lastName&quot;: &quot;Holmes&quot;, &quot;number&quot;: &quot;0487345643&quot;, &quot;likes&quot;: [&quot;Intriguing Cases&quot;, &quot;Violin&quot;] }, { &quot;firstName&quot;: &quot;Kristian&quot;, &quot;lastName&quot;: &quot;Vos&quot;, &quot;number&quot;: &quot;unknown&quot;, &quot;likes&quot;: [&quot;Javascript&quot;, &quot;Gaming&quot;, &quot;Foxes&quot;] } ]; 在函数中定义了一个函数用于操作，如下 function lookUp(firstName, prop){ // 请把你的代码写在这条注释以下 var firstE=0; var propE=0; var index=0; for(var i=0;i&lt;contacts.length;i++) { if(contacts[i].firstName==firstName){ firstE=1; index=i; break; } } if(contacts[index].hasOwnProperty(prop)) propE=1; if(propE&amp;&amp;firstE) return contacts[index][prop]; else if(!firstE) return &quot;No such contact&quot;; else if(!propE) return &quot;No such property&quot;; // 请把你的代码写在这条注释以上 } 具体功能就是先查询对象数组中有没有firstName属性为firstName(参数)的成员找到之后再查询这个对象里面有没有一个叫做prop(参数)的属性如果两者同时满足，返回该对应成员对应属性的内容，否则进行相关说明 注意这条语句return contacts[index][prop];一开始我不是这么写的，一开始我是这样写的return contacts[index].prop;导致符合两个条件但是最终输出却为空白在检查了前面一系列节点发现都没有问题，检查到这条语句的时候，我尝试把.prop换成.firstName，是有正常输出的，因此本人断定一定是在这条语句上出了问题后来决定换一种表达形式，由.换到[]形式，输出果然正常了在这里要说明一下，引入的两个参数都是字符串类型，比如”adobe” ,本人觉得应该是.prop的时候相当于是.&quot;属性名称&quot;,而不是.属性名称,多了一对双引号导致了这次bug的产生，因此本人建议，以后属性的类型是字符串的，最好用中括号对对象属性进行操作，避免不必要的bug]]></content>
      <categories>
        <category>Coding(Front End)</category>
      </categories>
      <tags>
        <tag>Javascript</tag>
        <tag>误区</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Javascript基础学习+JSON]]></title>
    <url>%2Fhfuter7712.github.io%2F2019%2F08%2F01%2FJavascript2%2F</url>
    <content type="text"><![CDATA[JSON(JavaScript Object Notation) 使用Javascript对象的格式来存储数据允许数据结构是字符串，数字，布尔值和对象的任意组合(string、number、boolean与Object的任意组合)JSON对象可以嵌套对象和数组,用中括号操作符同样可以访问嵌套数组 产生指定范围内的随机整数(方法来自freecodecamp)Math.random() 产生随机小数Math.floor() 在目前的小数向下取证产生0~19内的整数Math.floor(Math.random()*20)产生a~b内的整数Math.floor(Math.random() * (b - a + 1)) + a 正则表达式是一种根据某种匹配方式来寻找strings中的某些单词在字符串中寻找单词the，可使用下列正则表达式 文本 /the/gi/是正则表达式的头部第二个/时候正则表达式的尾部g代表着global,意味着返回所有的匹配而不仅仅是第一个i代表忽略大小写 数字 数字选择器\d用法:/\d/g在选择器后加上一个加号/\d+/g允许这个正则表达式匹配一个或更多的数字 空白 空白字符有&quot; &quot;（空格符）,\r（回车符）,\n（换行符）,\t（制表符）,\f（换页符）空白选择器\s空白正则表达式类似于/\s+/g 有趣的是，以上两个选择器将小写转化为大写的话，就会匹配与原来相反的字符比如\S是匹配任何非空白字符]]></content>
      <categories>
        <category>Coding(basic)</category>
      </categories>
      <tags>
        <tag>Javascript</tag>
        <tag>JSON</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Javascript基础复习+学习（一）]]></title>
    <url>%2Fhfuter7712.github.io%2F2019%2F08%2F01%2FJavascript1%2F</url>
    <content type="text"><![CDATA[终于开始复习JS了，哈哈，最早开始的时候JS学到一半没学完，这次一定要肝完 注释 javascript的注释和C语言的注释相同//这是一个注释 /*这是一段注释 没错，就是一段*/ 数据类型 JS提供七种不同的数据类型 undefined null boolean string symbol number object 当你对一个值为undefined的变量进行运算操作时，算出的结果将会是NaN当用一个没有定义的变量来做字符串连接操作时，他会如实的输出undefined 驼峰命名法变量名的第一个单词的首写字母小写，后面的单词的第一个字母大写 取余符号%使用%运算符来对一个数进行取余example: 5 % 2 = 1 在字符串中使用单引号和双引号可以使用转义字符串如要使用单引号，在前面加上反斜杠\&#39;双引号同理 \&quot;但是如果字符串内容中的符号与字符串起始终止所修饰的符号不同，可以不用比如字符串用双引号表示，内容包含单引号，可以不用转义 在JS中，字符串的值是不可变的，这意味着一旦字符串被创建就不能被改变但是可以通过重新赋值的形式来整体改变字符串 var Str1=&quot;3erf&quot;; Str1=&quot;34tc&quot;; 仍然是可以的 JS中的数组用法可以用数组名.push()来往数组中添加内容可以使用数组名.pop()来移除数组中的最后一条使用数组名.shift()来移除数组中的第一项同时也可以使用数组名.unshift()来在数组头部添加元素 使用函数console.log()来往开发控制台上打印内容 一个程序中可能有相同名称的局部变量和全局变量，在这种情况下局部变量将会优先于全局变量 严格相等运算符 ===与==不同的是，它会同时比较元素的值和数据类型因此如果比较的两个对象类型不同，那就直接返回false了 严格不相等运算符 !==与严格相等运算符类似，不仅比较元素的值，还要看他们的数据类型 JS Objects对象和数组相似，数组是通过索引来访问和修改数据，对象是通过属性来访问和修改数据的example: var Person{ &quot;first name&quot;: &quot;Ken&quot;, &quot;last name&quot;: &quot;Smith&quot;, &quot;weight&quot;: 170; &quot;pets&quot;:[&quot;cats&quot;,&quot;dogs&quot;] }; 可以用 . 即点操作符来操作对象属性也可以用中括号[]example(以上面的Person为例子):Person[&quot;first name&quot;]中括号的另外一个作用是用变量来访问一个属性example(来自freecodecamp): var someProp = &quot;propName&quot;; var myObj = { propName: &quot;Some Value&quot; } myObj[someProp]; // &quot;Some Value&quot; 最终myObj[someProp]返回的值是”Some value” 可以使用delete关键字来删除一个Object中特定的属性example: delete ourDog.bark 使用hasOwnProperty(propname)函数来检查对象是否有该属性]]></content>
      <categories>
        <category>Coding(basic)</category>
      </categories>
      <tags>
        <tag>Javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[语法糖(Syntactic-Suger)]]></title>
    <url>%2Fhfuter7712.github.io%2F2019%2F07%2F31%2FSyntacticSuger%2F</url>
    <content type="text"><![CDATA[今天在学习某查询语言的时候在官方文档里面发现有一个词组重复出现，叫做 Syntactic suger,点击谷歌翻译后，翻译成语法糖。。。一开始我肯定是不相信的，以为是谷歌翻译出的问题，还在想怎么谷歌翻译也会出现机翻，后来多次出现我实在忍不住就去网上进行了查询发现百科的词条大标题写的就是“语法糖”看来是自己的无知冤枉了谷歌，233在浏览了相关词条后，大致了解了这是什么玩意语法糖，也称为糖衣语法，到这边我大概明白了，什么叫做语法糖，糖衣很多人小时候都可能吃过，表面上尝起来可能是酸甜可口的，但实际上是药。有些程序的语法过于复杂，如果按照原来那样写的话，语法上是没有什么错误，但是会使得程序可读性大大降低，别说普通人，甚至部分程序员也很难理解，需要很长时间来理解，这时，糖衣语法就出现了baidu:通常来说使用语法糖能够增加程序的可读性，从而减少代码出错的机会这个术语由英国计算机科学家彼得·约翰·兰达（Peter J. Landin）发明，感谢前辈example:C语言中用 a[i]表示 *(a+i) ,用a[i][j] 表示 *(*(a+i)+j)个人总结:糖衣语法让繁杂的程序语法变得浅显易懂]]></content>
      <categories>
        <category>Coding(basic)</category>
      </categories>
      <tags>
        <tag>术语</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Sparql查询语言学习（二）]]></title>
    <url>%2Fhfuter7712.github.io%2F2019%2F07%2F31%2FSparqlLearn2%2F</url>
    <content type="text"><![CDATA[FILTER函数个人理解：当FILTER括号中的表达式为true时匹配，否则不匹配(相当于只有满足FILTER括号中的内容才能匹配)regex 用来测试RDF文字，仅匹配没有语言标签（见上一篇博文中的language tag)的普通文字，regex可以使用str函数来匹配其他文字的词法形式example:FILTER regex(&quot;title,&quot;^SPARQL&quot;)正则表达式匹配可以使用”i”标志（不区分大小写）example:FILTER regex(?title,&quot;web&quot;,&quot;i&quot;) 用来匹配数值相关的表达式example:如果要匹配的内容的类型是数字,可以有以下表达式FILTER(?price &lt; 23.4)结果只会匹配那些价格低于23.4的内容 除了数字类型(numeric types)，SPARQL还支持xsd:string,xsd:boolean,xsd:dateTime类型 Sparql语法 变量 查询语句中的变量以$或者?开头，这两个符号并不是变量的一部分，而是用来表示这是一个变量,在查询中，$abc和?abc标识相同的变量 空节点 空白节点由标签形式表示，例如_:abc与缩写形式[]在查询语法中，仅在唯一一个位置使用的可以被视作[]相同的空白节点标签不能在同一查询中的两个不同的基本图形模式中使用example:两种形式 [: p&quot;v&quot;]. 与 []: p&quot;v&quot;. 分配了唯一一个空白节点标签假设分配的节点标签是b57,那就相当于这样:_: b57: p&quot;v&quot;.该分配的空白节点可以作为其他三重模式的主体或对象,作为主题[: p&quot;v&quot;]: q&quot;w&quot;.相当于两个三元组 _: b57: p&quot;v&quot;. 与 _: b57: q&quot;w&quot;.作为对象: x: q [: p&quot;v&quot;].相当于两个三元组: x: q_: b57.与 _: b57: p&quot;v&quot; 三重模式的写法 可以编写具有共同主题的三重模式，使得目标变量只用声明一次可以运用到多个三重模式,使用;来分隔example: ?x foaf:name ?name ; foaf:mbox ?mbox. 等同于 ?x foaf:name ?name . ?x foaf:mbox ?mbox . 如果三重模式享有多个项目变量或谓语，之间,分隔example:?x foaf:name ?name ; foaf:nick &quot;Alice&quot;, &quot;Alice_&quot; .等同于 ?x foaf:name ?name . ?x foaf:nick &quot;Alice&quot; . ?x foaf:nick &quot;Alice_&quot; . End at 5 Graph Patterns,to be continued…]]></content>
      <categories>
        <category>Coding(Project)</category>
      </categories>
      <tags>
        <tag>RDF</tag>
        <tag>Sparql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Sparql查询语言基础学习（一）]]></title>
    <url>%2Fhfuter7712.github.io%2F2019%2F07%2F31%2FSparqlLearn%2F</url>
    <content type="text"><![CDATA[全程官方文档英文阅读理解。。 （有部分谷歌翻译辅助，不过大部分还是阅读理解，因为谷歌翻译的虽然很好，但是有些也会脱离本意）标题写着 “SPARQL Query Language for RDF”想必也是针对RDF设计的一种查询语言了 大多数形式的SPARQL查询包含一族成为基本图形模式的三重模式(triple patterns 编写一条简单的查询语言Data:&lt;http://example.org/book/book1&gt; &lt;http://purl.org/dc/elements/1.1/title&gt; &quot;SPARQL Tutorial&quot; . 查询语句: SELECT ?title WHERE { &lt;http://example.org/book/book1&gt; &lt;http://purl.org/dc/elements/1.1/title&gt; ?title . } 语句由两部分组成，一个是SELECT 部分，标识要在查询结果中进行显示的变量(在查询结果中将以第一行的形式出现),也就是说 ?title是一个变量另外一个是WHERE部分，提供与数据图表匹配的基本图形模式(basic grapg pattern) 多个匹配根据WHERE部分的基本图形部分，匹配的结果可能是0个，1个或者多个 匹配RDF文本(literals)在Turtle中以下RDF文本&quot;cat&quot;@en意味着有着 词汇形式(lexical form):”cat”以及语言(language):”en” (语言标签language tags) 以下RDF文本&quot;42&quot;^^xsd:integer&quot;是一个http://www.w3.org/2001/XMLSchema#integer;类型的文本 以下RDF文本&quot;abc&quot;^^dt:specialDatatype&quot;是一个http://example.org/datatype#specialDatatype.类型的文本 根据语言标签匹配文本若要匹配&quot;cat&quot;@en,执行下列查询语句将没有结果SELECT ?v WHERE {?v ?p &quot;cat&quot;}因为”cat”和”cat”@en在RDF文本层面并不相同，因此无法匹配为此有另外一种解决方案`SELECT ?v WHERE {?v ?p “cat”@en}也就是将语言标签也添加上去进行匹配，即可获得结果 使用数字类型来匹配文本匹配&quot;42&quot;^^xsd:integer&quot;可使用以下查询语句SELECT ?v WHERE {?v ?p 42} 匹配具有任意数字类型的文本SELECT ?v WHERE{?v ?p &quot;abc&quot;^^&lt;http://example.org/datatype#specialDatatype&gt;}词法形式和数据类型都匹配，不管数据类型是什么（任意数据类型），都可以匹配成功 查询结果中可包含空白节点， 空白节点标签的范围限定为结果集 SPARQL具有多种查询形式有SELECT查询形式,返回变量绑定也有CONSTRUUCT查询形式,返回RDF图 —-CONSTRUCT查询形式—- data: @prefix org: &lt;http://example.com/ns#&gt; . _:a org:employeeName &quot;Alice&quot; . _:a org:employeeId 12345 . _:b org:employeeName &quot;Bob&quot; . _:b org:employeeId 67890 . 查询语句: PREFIX foaf: &lt;http://xmlns.com/foaf/0.1/&gt; PREFIX org: &lt;http://example.com/ns#&gt; CONSTRUCT { ?x foaf:name ?name } WHERE { ?x org:employeeName ?name } result: @prefix org: &lt;http://example.com/ns#&gt; . _:x foaf:name &quot;Alice&quot; . _:y foaf:name &quot;Bob&quot; . ORDER BY 关键字该ORDER BY字句之后是一系列顺序比较器，有表达式和可选的顺序修饰符组成，每个排序比较器是升序(由ASC()修饰),降序(由DESC()修饰) SPARQL未定义所有可能的RDF术语的总排序example: PREFIX foaf: &lt;http://xmlns.com/foaf/0.1/&gt; SELECT ?name WHERE { ?x foaf:name ?name } ORDER BY ?name]]></content>
      <categories>
        <category>coding</category>
      </categories>
      <tags>
        <tag>RDF</tag>
        <tag>Sparql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RDF基础学习]]></title>
    <url>%2Fhfuter7712.github.io%2F2019%2F07%2F31%2FRDFLearn%2F</url>
    <content type="text"><![CDATA[资源描述框架RDF是用于描述网络资源的W3C标准（网页的标题，作者，修改日期，内容和版权信息）RDF使用XML编写，被RDF使用的XML语言被称为RDF/XMLRDF被设计为可被计算机阅读和理解RDF语言是W3C语义网活动的组成部分 RDF使用Web标识符（URIs)来标识资源,使用属性值来描述资源example: &lt;?xml version=&quot;1.0&quot;?&gt; &lt;RDF&gt; &lt;Description about=&quot;https://www.runoob.com//rdf&quot;&gt; &lt;author&gt;Jan Egil Refsnes&lt;/author&gt; &lt;homepage&gt;https://www.runoob.com/&lt;/homepage&gt; &lt;/Description&gt; &lt;/RDF&gt; RDF陈述资源，属性和属性值的组合可以形成一个陈述（分别被称为陈述的主体，谓语和客体）example(来源于菜鸟教程):陈述：&quot;The author of https://www.runoob.com//rdf is David.&quot;陈述的主体是：https://www.runoob.com//rdf谓语是：author客体是：David rdf:RDF 元素&lt;rdf:RDF&gt;是RDF文档的根元素，它把XML文档定义为一个RDF文档，也包含了对RDF命名空间的引用&lt;rdf:RDF xmlns:rdf=&quot;http://www.w3.org/1999/02/22-rdf-syntax-ns#&quot;&gt; rdf:Description 元素该元素可通过about属性标识一个资源可包含描述资源的那些元素 RDF容器 rdf:Bag 元素&lt;rdf:Bag&gt;元素用于描述一个规定为无序的值的列表，可包含重复的值example: &lt;rdf:Bag&gt; &lt;rdf:li&gt;John&lt;/rdf:li&gt; &lt;rdf:li&gt;Paul&lt;/rdf:li&gt; &lt;rdf:li&gt;George&lt;/rdf:li&gt; &lt;rdf:li&gt;Ringo&lt;/rdf:li&gt; &lt;/rdf:Bag&gt; rdf:Seq 元素&lt;rdf:Seq&gt;元素用于描述一个规定为有序的列表（比如一个字母顺序的排序），可包含重复的值 rdf:Alt 元素&lt;rdf:Alt&gt;元素用于一个可替换的值得列表(用户仅可选择这些值得其中之一) RDF集合rdf:parseType=&quot;Collection&quot;RDF集合用于描述仅包含制定成员的组 RDF都柏林核心表:https://www.runoob.com/rdf/rdf-dublin.htmlRDF参考手册: https://www.runoob.com/rdf/rdf-reference.htmlRDF在线验证器:http://www.w3.org/RDF/Validator/]]></content>
      <categories>
        <category>Coding(Project)</category>
      </categories>
      <tags>
        <tag>RDF</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[完成的第一个HTML+css+Bootstrap实践]]></title>
    <url>%2Fhfuter7712.github.io%2F2019%2F07%2F30%2FfirstHTML%2BCSS%20project%2F</url>
    <content type="text"><![CDATA[在某网站上学习前端之后按照一个界面（单单看着界面一个个元素敲出来的界面）搞出来的第一个实践作品介绍的是我最佩服的图灵先辈（一说到图灵就想到那部卷福演的电影，泪目）实践中的部分笔记与收获: &lt;hr&gt;可以在界面中定义一条水平实线，可以用于页面的分割 字体的粗细可以用font-weight来定义，400px相当于font-style的normal,700px相当于bold 此次作品中运用到了Bootstrap的两个类，一个是让图片自动适应界面的img-responsive,还有一个就是让文本居中的text-center感受:第一次实践，虽说整体来讲没有什么难度，但是也是本人第一次在页面上进行实践，对照着模板网页，没有查看源代码的情况下用HTML和css一个个尝试和调整，也是一次相当宝贵的实践了 实践工具: codepen作品网址: https://codepen.io/hfuter7712/pen/pMeXOz]]></content>
      <categories>
        <category>Coding(Front End)</category>
      </categories>
      <tags>
        <tag>HTML</tag>
        <tag>css</tag>
        <tag>Bootstrap</tag>
        <tag>作品集</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTML基础复习(三)+结合jQuery]]></title>
    <url>%2Fhfuter7712.github.io%2F2019%2F07%2F30%2FHTML%20combine%20with%20jQuery%2F</url>
    <content type="text"><![CDATA[script元素 内含JavaScript语句，浏览器会执行script里面的所有语句，包括jQuery jQuery所有jQuery方法都是由$开始的,通常称为美元符号或者简称为bling 使用jQuery的 .address() 方法，就可以给元素添加class了 使用jQuery的.removeClass()方法去掉元素上的class了 使用.css()可以改变元素的CSS样式example: $(&quot;#target&quot;).css(&quot;color&quot;,&quot;blue&quot;); 使用.prop()来调整元素的属性example: $(&quot;button&quot;).prop(&quot;disabled&quot;,true); 使用.remove() 来移除HTML元素 使用appendTo() 方法可以把选中的元素加到其他元素中example:假设id为one的元素在id为first的区块中，有另外一个区块id为second要想把该元素移动到区块second中,可以这么操作$(&quot;#one&quot;).appendTo(&quot;#second&quot;); 使用clone()可以拷贝元素假设id为one的元素在id为first的区块中，有另外一个区块id为second要想把该元素复制到区块second中，可以这么操作$(&quot;#one&quot;).clone().appendTo(&quot;#second&quot;);可以这么理解,移动元素就是剪切，拷贝元素就是复制 使用parent()可以访问当前元素的父元素example:一个id为first的h2元素的父元素是div，可以通过以下代码让div区块的背景颜色变蓝$(&quot;first&quot;).parent().css(&quot;background-color&quot;,&quot;blue&quot;); 使用children()可以访问当前元素的子元素 使用$(&quot;button&quot;)来选中按钮,使用$(&quot;.well&quot;)来获取所有class为well的对象，使用$(&quot;#fist&quot;)来获取所有id为first的对象 部分classanimated bounce 所应用部分有弹跳效果animated shake 所应用部分有摇摆效果 在线编辑器:CodePen程序员的Read-Search-Ask大法，加油!]]></content>
      <categories>
        <category>Coding(Front End)</category>
      </categories>
      <tags>
        <tag>HTML</tag>
        <tag>css</tag>
        <tag>jQuery</tag>
        <tag>Javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTML基础复习+Bootstrap+Font Awesome图标库]]></title>
    <url>%2Fhfuter7712.github.io%2F2019%2F07%2F30%2FHTMLReview%2Bbootstrap%2F</url>
    <content type="text"><![CDATA[Bootstrap将会根据你的屏幕大小来调整HTML元素的大小–强调响应式概念使用Bootstrap需要添加下列代码 &lt;link rel=&quot;stylesheet&quot; href=&quot;//cdn.bootcss.com/bootstrap/3.3.1/css/bootstrap.min.css&quot;/&gt; img-responsive类 当导入一张图片时，给图片添加该类，这样图片的宽度就能完美的适配页面宽度了&lt;img src=&quot;&quot; class=&quot;img-responsive&quot;&gt; text-center类 运用于文本，可以将文本居中&lt;h2 class=&quot;text-center&quot;&gt;title&lt;/h2&gt; btn类 是Bootstrap的按钮风格&lt;button class=&quot;btn&quot;&gt;press&lt;/button&gt; btn-block类 使按钮成为块级元素，按钮将会伸展并填满页面整个水平空间，任何在它之下的元素都会跟着浮动到该区块的下一行（注:该属性仍需要有 btn 属性) btn-primary类 使按钮呈现深蓝色，更加美观，是主要操作按钮的颜色（注:该属性仍需要有 btn 与btn-block属性) btn-info类 使按钮呈现浅蓝色，更加美观，是用户可能采取操作按钮的颜色 btn-danger类 使按钮呈现红色，通常用于一些“破坏性”的操作，比如删除图片 well类 它的作用视为设定的列创造出一种视觉上的深度感 Font Awesome图标库 是一个非常方便的图标库，这些图标都是矢量图形，被保存在.svg的文件格式中可以添加如下代码来使用该库 &lt;link rel=&quot;stylesheet&quot; href=&quot;//cdn.bootcss.com/font-awesome/4.2.0/css/font-awesome.min.css&quot;/&gt; i元素起初一般是让它的元素变成斜体，现在一般用来指代图标,用它来实现图标库的使用&lt;i class=&quot;fa fa-info-circle&gt;&lt;/i&gt;fa-thumbs-up 一个大拇指形状的图标fa-info-circle 一个圆圈里面带一个字母i，代表informationfa-trash 一个垃圾桶的标志fa-paper-plane 一个纸飞机的标志]]></content>
      <categories>
        <category>Coding(Front End)</category>
      </categories>
      <tags>
        <tag>HTML</tag>
        <tag>Bootstrap</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTML基础复习（二）]]></title>
    <url>%2Fhfuter7712.github.io%2F2019%2F07%2F29%2FHTMLReview2%2F</url>
    <content type="text"><![CDATA[marign:外边距如果一个元素的margin为负值，元素将会变大 border:边框padding:内边距可以根据padding-top,padding-right,padding-left,padding-bottom四个属性来控制上下左右四个内边距的属性margin同理如果按照如下格式padding: 10px 20px 10px 20px按照顺时针方式排列依次是顶部，右侧，底部，左侧（上右下左） 关于class的优先权问题 在HTML中，class=”类A 类B 类C” 排序是无所谓的但是在style元素中，class的声明顺序却非常重要，第二个声明总是比第一个具有优先权但是有一点很重要：id属性总是具有更高的优先权更重要的一点：行内样式可以覆盖id（优先权更大）example:1234567891011121314151617&lt;style&gt; body &#123; background-color: black; font-family: Monospace; color: green; &#125; #orange-text &#123; color: orange; &#125; .pink-text &#123; color: pink; &#125; .blue-text &#123; color: blue; &#125;&lt;/style&gt;&lt;h1 id=&quot;orange-text&quot; class=&quot;pink-text blue-text&quot; style=&quot;color:white&quot;&gt;Hello World!&lt;/h1&gt; 最终文本显示为白色 by the way,还有最强大的一种方法，在某些元素的属性后面加上!important可以使得该属性覆盖其他任何相同的属性 用十六进制表示颜色说到颜色，颜色在CSS中还可以用十六进制表示，格式是#XXXXXX例如#000000是黑色0是hex code中最小的一个，F是hex code中最大的一个#000000白色#FFFFFF黑色#111111 深灰色不过也可以用三位数来表示，比如#F00它等同于#FF0000 用rgb值表示rgb(0,0,0)取值范围从0~255]]></content>
      <categories>
        <category>Coding(Front End)</category>
      </categories>
      <tags>
        <tag>HTML</tag>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于hexo博客以及markdown的一些坑]]></title>
    <url>%2Fhfuter7712.github.io%2F2019%2F07%2F29%2Fhexo2%2F</url>
    <content type="text"><![CDATA[今天在搞博客的时候又踩了一些markdown的坑，不得不说emmmm..首先还是关于代码块的问题在上次的基础上，如果你要在一个文档中插入多个代码块 记住将代码行的第一行文本backspace直到和前三个引号连在一块，敲一次空格键，然后回车即可(2019-7-30更新) 还有一个就是12文本- 并不能使这个文本成为一个帅气的大标题，即使markdown里面是这样显示的，在博客上显示为文本- …还有一个（这都什么鬼）markdown中的大标题h1也就是#文本#在博客上并没有效果 不知道是本人hexo的问题还是就是这个样子，总之markdown预览器里的东西跟博客上呈现的样子真的有很多差别]]></content>
      <categories>
        <category>Coding(blog)</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>markdown</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTML基础复习(一）]]></title>
    <url>%2Fhfuter7712.github.io%2F2019%2F07%2F29%2FHTMLReview%2F</url>
    <content type="text"><![CDATA[标题分6个等级，从&lt;h1&gt;到&lt;h6&gt;&lt;h1&gt;这是一个一级标题&lt;h1&gt;如何让你的标题变红&lt;h1 style=&quot;color:red&quot;&gt;title&lt;/h1&gt;即使用style属性中的color，这是style的内联样式如果需要配置的属性过多，可以使用&lt;style&gt;结合css 1234&lt;style&gt; 选择器&#123;属性名称:属性值;&#125;example: h2&#123;color:red;&#125;&lt;/style&gt; 注：一定要在属性值的后面加上分号 类选择器12345&lt;style&gt; .类名&#123; &#125;&lt;/style&gt;&lt;h2 class=&quot;类名&quot;&gt;title2&lt;/h2&gt; class=”类A 类B 类C…”可以应用多个类，但是必须用空格隔开 改变文章的字体大小可以用font-size属性改变文章的字体可以用font-family属性当某种字体不可用时，可以让它自动降级到另一种字体example: 123p&#123; font-family: Helvetica,Sans-Serif;&#125; 当Helvetica字体不可用时，字体会自动降级到San-Serif img元素img是自关闭元素，不需要结束标记&lt;img src=图片的具体地址&gt;若要设置图片宽度，可用CSS中的width属性给图片添加边框，可以用border-width,border-tstyle与border-color三个属性若想要添加圆角边框，则可以用属性border-radius,参数可以是像素，也可以是百分比alt属性：当图片因为各种原因无法加载时显示的替代文本 a元素anchor元素，可以用来连接到外部地址实现页面跳转功能,也可连接到当前页面的某部分实现内部导航功能&lt;a href=&quot;URL&quot;&gt;anchor text&lt;/a&gt;但是如果你暂时不知道要跳转到哪里的时候，可以用#代替，别名哈希符号href=&quot;#&quot;想把一张图片作为一个连接，直接将图片嵌套进a元素即可&lt;a&gt;&lt;img&gt;&lt;/img&gt;&lt;/a&gt; ul元素创意一个无序列表,包含多个li元素 1234&lt;ul&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt;&lt;/ul&gt; ol元素与无序表用法类似，在ol中嵌套多个li元素 input元素input元素是自关闭的其中初始化方框的文本为属性placeholder&lt;input type=&quot;text&quot; placeholder=&quot;预定义文本&quot;&gt;如果要设置必填，则添加上required属性即可&lt;imput type=&quot;text&quot; required&gt; button元素定义一个按钮 单选按钮(type=”radio”)用来定义单选按钮，在多个选项中只能选一个，嵌套在自己的label元素中,所有关联的单选按钮要使用相同的name属性example: 12&lt;label&gt;&lt;input type=&quot;radio&quot; name=&quot;indoor/outdoor&quot;&gt;indoor&lt;/label&gt;&lt;label&gt;&lt;input type=&quot;radio&quot; name=&quot;indoor/outdoor&quot;&gt;outdoor&lt;/label&gt; 多选按钮(type=”checkbox”)可以被多选 多选按钮和单选按钮都可以用checked属性来表明默认被选中 背景颜色可以用background-color属性来设置 设置id会对以后的jQuery有好处（小本本记下来）&lt;div id=&quot;id号&quot;&gt;在style元素中的表示方法为 123#&#123;属性; &#125;]]></content>
      <categories>
        <category>Coding(Front End)</category>
      </categories>
      <tags>
        <tag>HTML</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[XML命名空间学习]]></title>
    <url>%2Fhfuter7712.github.io%2F2019%2F07%2F29%2FxmlNamespace%2F</url>
    <content type="text"><![CDATA[命名空间是为了防止不同文档使用相同的元素名时引发命名冲突比如A文档使用了&lt;name&gt;标签,B文档也使用了&lt;name&gt;标签，这个就会产生命名冲突这个时候可以使用前缀来避免这种情况 &lt;前缀名:标签名&gt;&lt;h:table&gt;&lt;i:table&gt;&lt;g:address&gt;&lt;j:address&gt; XML命名空间 xmlns属性当在XML中使用前缀时，一个所谓的用于前缀的命名空间必须定义xmlns:前缀=&quot;URI&quot;当命名空间被定义在元素的开始标签中时，所有带有相同前缀的子元素都会与同一个命名空间相关联 example: &lt;root&gt; &lt;h:table xmlns:h=&quot;http://www.w3.org/TR/html4/&quot;&gt; &lt;h:tr&gt; &lt;h:td&gt;Apples&lt;/h:td&gt; &lt;h:td&gt;Bananas&lt;/h:td&gt; &lt;/h:tr&gt; &lt;/h:table&gt; &lt;f:table xmlns:f=&quot;http://www.w3cschool.cc/furniture&quot;&gt; &lt;f:name&gt;African Coffee Table&lt;/f:name&gt; &lt;f:width&gt;80&lt;/f:width&gt; &lt;f:length&gt;120&lt;/f:length&gt; &lt;/f:table&gt; &lt;/root&gt; 默认的命名空间xmlne=:namespaceURI 注：URI(Uniform Resource Identifier)统一资源标识符最常用的URI是用来标识因特网域名地址的统一资源定位器(URL)]]></content>
      <categories>
        <category>Coding(Front End)</category>
      </categories>
      <tags>
        <tag>XML</tag>
        <tag>namespace</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于markdown中代码块的一个小问题]]></title>
    <url>%2Fhfuter7712.github.io%2F2019%2F07%2F29%2FmarkdownCodeBlock%2F</url>
    <content type="text"><![CDATA[刚刚在折腾博客的时候，写日志嘛，然后有一段代码块需要放进来，用过markdown的人都知道代码块是用三个连续的引号来搞定的但是我刚刚就遇到一个问题就是markdown预览器中的界面和博客界面不一定是相同的在经过一系列尝试之后，这样的格式是正确的引号引号引号 在这一片空白区域输入你的代码块，该怎么缩进怎么缩进 引号引号引号 引号不需要tab的，我那个只要一tab在markdown预览里面就像是一行代码块，但是gds操作后在上网去看博客却发现是一团糟所以还是那句老话，请以实物为准发完博客记得去博客上看看效果]]></content>
      <categories>
        <category>Coding(blog)</category>
      </categories>
      <tags>
        <tag>markdown</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[XML可扩展标记语言基础学习]]></title>
    <url>%2Fhfuter7712.github.io%2F2019%2F07%2F29%2FxmlLearn1%2F</url>
    <content type="text"><![CDATA[XML(EXtensible Markup Language)XML的设计宗旨是传输数据而不是显示数据XML标签没有被预定义，需要自行定义标签XML是W3C的推荐标准一般来说XML用于传输数据，HTML用于格式化并显示数据一个XML文档的第一行是一个XML声明,定义XML的版本和所使用的编码&lt;?xml version=&quot;1.0&quot; encoding = &quot;UTF-8&quot;?&gt;下一行描述文档的根元素&lt;note&gt;接下来描述子元素 ，并在最后一行定义根元素的结尾由于具有根元素以及其子元素的特征，因此XML文档形成一种树结构 XML必须包含根元素所有的元素都必须有关闭标签（这里提到一点，HTML的部分标签可以没有关闭标签，如,但是XML中都必须有关闭标签）XML标签对大小写敏感XML属性值必须加引号&lt;note date=&quot;12/11/2018&quot;&gt; 实体引用理解:因为XML本身语法的原因，在XML中的部分符号需要用特定的字段代替，就好比在某些语言里引号”要用”/代替一样&amp;lt; &lt; 大于号&amp;gt; &gt; 小于号&amp;amp; &amp; 连接号&amp;apos; &#39; 单引号&amp;quat; &quot; 双引号 XML中的注释（和HTML一样）&lt;!-- This is a comment --&gt;在XML中，空格会被保留（在HTML中，多个连续的空格字符会被裁剪为1个） XML命名规则 名称可以字母，数字以及其他字符 名称不能以数字或者标点符号开始 名称不能以xml,XML,Xml等一系列字段开始 名称不能包含空格 XML是可扩展的 XML中的属性值必须被引号保卫，不过可以单引号双引号都能使用suggestion:XML中应避免使用属性，尽量使用标签reason: 属性不能包含多个值 属性不能包含树结构 属性不容易扩展example: 12345678910111213&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;note&gt; &lt;to&gt;Tove&lt;/to&gt; &lt;from&gt;Jani&lt;/from&gt; &lt;heading&gt;Reminder&lt;/heading&gt; &lt;body&gt;Don&apos;t forget me this weekend!&lt;/body&gt; &lt;/note&gt; XML验证器链接: https://www.runoob.com/xml/xml-validator.html教程链接:https://www.runoob.com/xml/xml-tutorial.html]]></content>
      <categories>
        <category>Coding(Front End)</category>
      </categories>
      <tags>
        <tag>XML</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SQL指令学习]]></title>
    <url>%2Fhfuter7712.github.io%2F2019%2F07%2F28%2FsqlLearn%2F</url>
    <content type="text"><![CDATA[SELECT - 从数据库中提取数据UPDATE - 更新数据库中的数据DELETE - 从数据库中删除数据INSERT INTO - 向数据库中插入新数据CREATE DATABASE - 创建新数据库ALTER DATABASE - 修改数据库CREATE TABLE - 创建新表ALTER TABLE - 变更（改变）数据库表DROP TABLE - 删除表CREATE INDEX - 创建索引（搜索键）DROP INDEX - 删除索引 SQL SELECT SELECT语句用于从数据库中选取数据结果被存储在一个结果表中，称为结果集 SQL SELECT DISTINCT SELECT DISTINCT country FROM Websites;在表中，一个列可能会包含多个重复值，有时您也许希望仅仅列出不同（distinct）的值。DISTINCT 关键词用于返回唯一不同的值 SQL WHERE WHERE子句用于提取那些满足指定条件的记录 SQL ORDER BY 关键字ORDER BY关键字用于对结果集按照一个列或者多个列进行排序。ORDER BY 关键字默认按照升序对记录进行排序。如果需要按照降序对记录进行排序您可以使用 DESC 关键字DESC关键字 降序 update 警告！在更新记录时要格外小心！在上面的实例中，如果我们省略了 WHERE 子句，如下所示：UPDATE Websites SET alexa=&#39;5000&#39;, country=&#39;USA&#39;执行以上代码会将 Websites 表中所有数据的 alexa 改为 5000，country 改为 USA。执行没有 WHERE 子句的 UPDATE 要慎重，再慎重]]></content>
      <categories>
        <category>Coding(Database)</category>
      </categories>
      <tags>
        <tag>数据库</tag>
        <tag>sql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[暑假回归+hexo:command no found解决]]></title>
    <url>%2Fhfuter7712.github.io%2F2019%2F07%2F27%2Fsummer%20return%2F</url>
    <content type="text"><![CDATA[暑假闲着无聊，突然想到自己还有个博客2333就回来了，这次打算把印象笔记上的那一大坨笔记都搬上来，以后开始日常更新了，这可是项技术活啊，哈哈然而打开博客目录就发现在根目录下git bash 输入hexo相关指令竟然跟我说 hexo:Command not found这怎么可能，在检查了npm和node的安装情况后 (方法来自https://blog.csdn.net/kittowang/article/details/56011794 author:kittowang )$ node -v$ npm -v检查版本号，然后再检查hexo的文件是否安装，都没发现有问题最后找到问题根源，是环境变量中的Path未设置，只要在环境变量中设置Path添加一个变量设置为根目录/node_modules/.bin即可不过以前好像也没有配置环境变量，那以前是怎么行得通的，真是玄学]]></content>
      <categories>
        <category>coding</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>个人博客</tag>
        <tag>环境变量</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[课程设计，completed！]]></title>
    <url>%2Fhfuter7712.github.io%2F2019%2F05%2F16%2F996%2F</url>
    <content type="text"><![CDATA[前段日子为了写课程设计代码可谓是费尽心思，都没有时间写博客了，本来在上学期选（抢）课设题目的时候就没搞到好题目，分不算低，但是技术含量不是很高，就是一个以堆为基础的优先队列的作业系统而已，后来临近验收，脑洞大开又想写一个。第一次选了一个电梯题目，简单粗暴没有提示只有要求，至少4台电梯，十层楼，每层楼0~15人随机上下，要求实现调度，本人只写出了数据结构和显示函数就放弃了，因为太菜不知道怎么实现调度，想了好久最后还是放弃了第二次选了B+树，B+树和B树都是数据库的基础，因此想趁机提前学习一下相关基础，奈何本人学艺不精，终究还是失败了，又转战B树，这回好歹看上去好搞了一点，在网上查阅了大量资料后，凭着借鉴和乱写大致写出了B树的基本操作，真的不容易啊2333，B树真的是一生痛，没有之一，写B树的删除我曾经连着3个小时盯着屏幕debug和画图验证。总归还好最后课设验收给了个海星的分数没有让我这个菜鸡的自信心受到进一步打击，但是通过这次课设我也看到了自身的弱点，满满的全是弱点，一触即溃，这样下去以后读研工作会有大麻烦的，虽然我一直秉承学习技术优先，但是秉承了这么久好像也没有学到什么精髓，学的全是基础，一旦要求高起来真的是束手无策。连续两周每天十小时以上的敲代码真的把我累坏了，最近睡觉都是一倒在床铺上就秒入睡的，还会做一些莫名其妙的怪梦，感觉一个比较恐怖的是有时候做那种突然前面有一个深渊我踩空然后惊醒同时发现自己在踢腿23333，太迷幻了，还是要注意身体啊菜鸡的学习还需继续，帝牙卢卡赐予我时间的力量！（中二病发作）]]></content>
      <categories>
        <category>日常</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>课程设计</tag>
        <tag>B树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[本体初步了解]]></title>
    <url>%2Fhfuter7712.github.io%2F2019%2F04%2F29%2Fontology%2F</url>
    <content type="text"><![CDATA[category：ontology/knowledge graph 本体 通常在一个本体中主要定义以下几个组成部分 类:领域和任务中的概念，通常使用分类法组织在一起 关系：领域概念之间的一种联系类型 函数：一种特殊的关系，在关系的N个元素中前N-1个元素决定了第N各元素 公理：一种关于事实地语句，如果学生选修了课程A和B，那么他是二年级学生 实例：表示特定的元素，如Peter是学生的实例 XML DTDs 和 XML Schemas 对于在两个遵守预先定义的协议的应用是足够的但是由于它们缺乏语义使得难以利用新的XML词汇来执行任务而 RDF 和 RDF Schema 通过允许联系与标识符的简单语义来着手处理这个问题使用 RDF Schema :一个人能定义具有多个子类和超类的类，定义具有子属性，领域和范围的属性然而为了达到在众多独自发展和管理的模式之间的交互操作，丰富的语义是必须的 ###传统的本体表示语言### Ontolingua基于 KIF (Knowledge Interchange Format) 和 FO (Frame Ontology) 的语言 KIF(Knowledge Interchange Format)主要功能：解决知识表示语言的异质性，定义对象，函数和关系，基于一阶谓词逻辑，并含有一个前缀符号此外它还可以表示元知识的非单调推理规则，具有描述性语义 OKBC（Open Knowledge Base Connectivity) 协议具体描述了一个协议，对其底层的知识表示系统做了假定，对于支持语言共享的语言是一个有力的补充 GFP知识模型能够用以对象为中心的方法来表示知识还提供了一个问答界面，以使用 OKBC协议访问知识库 OCML一种基于框架的语言能够表示诸如关系，函数规则，类和实例等项还另外增加了一些逻辑机制以增强推理的有效性与标准相容 Flogic综合了基于框架的语言和一阶谓词逻辑能够清楚明白的说明面向对象和基于框架语言的大多数结构方面在推理演绎方面，Flogic有一个理论模型和一个完整有效的基于决策的证明机制 LOOM提供了明确定义而且表达能力较强的模型描述语言能描述定义，规则，事实和缺省规则等，提供了有效的推理机制，能利用向前推理，语义一致化和面向对象的真值为维护等技术实现推理，提供了变成范例，产生式规则范例和面向对象范例 ###传统的本体表示语言### OntolinguaKSL开发的一个本体开发环境，包括一个服务器和一个表示语言1.使用 Ontolingua 语言的扩展版本作为半形式化的表示语言2.使用满足面向对象的框架视图表示和浏览知识，使用类/子类的方式展现类层次3.使用户能迅速地从模块库中组合新本体4.为用户提供三种与Ontolingua服务器交互的主要模式5.支持合作开发本体，观察从一个本体转变为另一个本体的动作集合，方便的监视本体的变化，通过检查槽，槽值，面，面值确保他们满足已知的限制的方法，可分析本体的一致性 参考：华中师范大学 舒江波 硕士学位论文《本体库的构建方法和应用研究》链接来源:点击此处]]></content>
      <categories>
        <category>大创</category>
      </categories>
      <tags>
        <tag>知识图谱</tag>
        <tag>本体</tag>
        <tag>XML</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于在进行generate以及d操作后仍然无法更新文章的解决]]></title>
    <url>%2Fhfuter7712.github.io%2F2019%2F04%2F27%2Fexperience1%2F</url>
    <content type="text"><![CDATA[刚刚折腾了半天，如果进来而且想要搞博客的大佬们在进行了 hexo g hexo d 博客主页面仍然没有更新文章的话 检查是否进行了如下操作 –在博客主文件夹下进行git bash，然后输入 npm install hexo-deployer-git --save 之后再进行常规操作，测试是否有效，本人亲测有效 （方法来源：Z皓）来源链接]]></content>
      <categories>
        <category>Coding(blog)</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>个人博客</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[return!]]></title>
    <url>%2Fhfuter7712.github.io%2F2019%2F04%2F27%2Freturn%2F</url>
    <content type="text"><![CDATA[昨天刚测完体测，个子贼高郑老师的带领下进行了引体向上，50米和1000米的测试，引体向上很遗憾由于自重较大加上牵引力不足因此只完成了三个，50米跟着ass跑倒还过得去，1000米大集团进行测试，和ass一组，起跑慢了0.7s在队伍中间蹭风，所幸体力过得去很快到了第二，第一名依旧是ass，不愧是本班体委，到最后还是没追上，成绩马马虎虎过得去，也算是圆满了8 昨天晚上日常训练，骑着车绕了校园几圈，走了几个技术点，下了几段楼梯，其实也就那样，克服了心理恐惧，发现这几个所谓技术点也就看着唬人，其实没那么恐怖，不过好又多旁边的大跨度楼梯，计算机楼前的连续楼梯以及兔跳还是没学会，非得我上锁么！锁鞋很贵的，不过上了锁也美滋滋，而且速度和熟练度也上升的很快 昨天晚上熬到十二点半因为运动过度直接倒床上睡了，第二天八点半起来收拾了一下就去了自习室，回顾了一下git和hexo的操作（上一次搞这玩意大物实验课还没开始),也是挺有趣的，与其天天在空间发那几十个文字，还不如自己搞个博客把这些都存储下来。 中午收到赖师傅的消息，他带着他的速降车要去敬亭山速降，最近疯狂开发自己的我当然按捺不住自己午觉也不睡就去北门会和，骑了一小会就到了敬亭山下，俗话说速降速降，上山两小时，下来两分钟，果不其然，从赛道上去俩人推着坦克达和am重车疯狂向上，花了1小时57分钟到达所谓起点——一段楼梯，我在半路停下了，这么连续的楼梯以我那破技术估计够呛，于是赖师傅扛着am又向上走了一段，然后进入了短暂的休息。。在山顶一声吼叫后，am重车从山顶踏着楼梯一路向下飞驰，我拍完视频后也紧随其后。。。准确来说是人都看不到，26轮径加上我那烂技术这个楼梯完全hold不住，干脆直接推车，进入主赛道，赖师傅又一次消失在我眼前。。。我就小心的下，遇到飞包，小的就推把莽过去，大的直接绕过去，现在的我还完全不敢飞车，速降全程下坡没有给你喘息的余地，偶尔还给你来个转弯下坡，表示刹车完全不够用，终于有一段我稍稍松开了刹车，速度瞬间起来了，我估计有33左右，路上一堆小石子，一压到小石子就很容易侧滑，但是今天貌似苍天有眼，我竟然把持住了，全程没有摔车，狼狈的推车推过了技术难点乱石堆，然后继续下行，这条赛道已经荒废三年了，路上很多地方都长了草，有些路段甚至看不清，凭借着毅力和鸭子最终下到了我们出发的地方，一看时间，2分37s，emmmm。。还没爽够，说真的，但是那些包我是真的不敢飞，真的太高了，一摔妥妥进ICU，跟996有的一拼]]></content>
      <categories>
        <category>cycling</category>
      </categories>
      <tags>
        <tag>骑行</tag>
        <tag>速降</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[aaa.hexo]]></title>
    <url>%2Fhfuter7712.github.io%2F2019%2F02%2F22%2Faaa-hexo%2F</url>
    <content type="text"><![CDATA[bug]]></content>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2Fhfuter7712.github.io%2F2019%2F02%2F22%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
