<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[编译原理预习笔记（二）--高级语言及其语法描述]]></title>
    <url>%2Fhfuter7712.github.io%2F2019%2F09%2F03%2FcomplieP2%2F</url>
    <content type="text"><![CDATA[语法任何语言程序都可以看做是一定字符集（字母表）上的一个字符串（有限序列）语言的单词符号是由语法规则所确定的一个程序语言只使用一个有限字符集作为字母表单词符号是语言中具有独立意义的最基本结构词法规则是指单词符号的形成规则语法规则是语法单位的形成规则上下文无关文法是一种可取的有效工具语法单位比单词符号具有更丰富的意义 语义对于一个语言，不仅要给出他的词法，语法规则，还要定义它的单词符号和语法单位的意义一个程序的基本功能是描述数据和对数据的运算 ，所谓一个程序，从本质上说是描述一定数据的处理过程程序语言的每个组成成分都有（抽象的）逻辑和计算机实现 两方面的意义 数据类型与操作一个数据类型通常包括以下三种要素：1.用于区别这种类型的数据对象的属性2.这种类型的数据对象可以具有的值3.可以作用于这种类型的数据对象的操作 一个程序语言必须提供一定的初等类型数据成分]]></content>
      <categories>
        <category>specialized-course</category>
      </categories>
      <tags>
        <tag>principle</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[编译原理学习笔记（一）]]></title>
    <url>%2Fhfuter7712.github.io%2F2019%2F09%2F03%2FcomplieL1%2F</url>
    <content type="text"><![CDATA[来自MOOC哈工大教程编译：将高级语言翻译成汇编语言或机器语言的过程 通过分析源语言获得句子的语义：语义分析通常从划分句子成分入手 分析部分/前端:与源语言有关综合部分/后端:与目标语言有关 常用的中间表达形式：1.三地址码2.语法结构树/语法树 课后习题错题笔记：编译是对高级语言的翻译源程序是句子的集合，树可以较好地反映句子的结构]]></content>
      <categories>
        <category>specialized-course</category>
      </categories>
      <tags>
        <tag>principle</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jQuery复习（一）]]></title>
    <url>%2Fhfuter7712.github.io%2F2019%2F09%2F02%2Fjquery1%2F</url>
    <content type="text"><![CDATA[在开头&lt;head&gt;标签中加入如下语句 &lt;script src=&quot;https://cdn.staticfile.org/jquery/2.0.0/jquery.min.js&quot;&gt; &lt;/script&gt; 元素选择器https://www.runoob.com/jquery/jquery-selectors.html 对某个标签的所有元素进行选取:example:选取所有元素$(&quot;p&quot;) 根据id来选取元素$(&quot;#ident&quot;)选取id为ident的元素 根据class选取元素$(&quot;.classF&quot;)选取class为classF的元素 事件example:点击p元素后触发某函数 $(&quot;p&quot;).click(function(){ //要执行的代码 }); $(document).ready()该方法允许我们在文档完全加载完后执行函数 click() 点击按钮触发dblclick() 双击触发mouseenter() 鼠标指针穿过元素时触发mouseleave() 鼠标指针从元素上移开时触发 mousedown() 当鼠标指针移动到元素上方并按下鼠标按键时触发mouseup() 在元素上松开鼠标按钮hover() 模拟光标悬停（分两个函数，一个是光标移到元素上，一个是从元素上移开)example: $(&quot;#p1&quot;).hover( function(){ alert(&quot;鼠标移入&quot;); }, function(){ alert(&quot;鼠标移开&quot;); } ); focus()当元素获得焦点时触发（一般用于文本框输入，比如姓名，点击输入框，输入框变色)blur()和上一个相反，失去焦点时触发 隐藏与显示hide()将会隐藏一个元素show()将会显示一个隐藏的元素可以详细设置参数hide(speed,callback)speed是隐藏或显示的速度，”slow”,”fast”或者毫秒callback是隐藏或显示完成所执行的函数名称 toggle()相当于一个开关，可以在hide()和show()之间切换，如果元素处于隐藏状态，触发之后会将元素显示，反之会隐藏 淡入淡出fadeIn(speed,callback) 淡入fadeOut(speed,callback) 淡出speed同样是速度，取值同样是”slow”,”fast”或者毫秒callback是淡入淡出后执行的函数 fadeToggle()同样是起到开关的作用，在上述两种淡入淡出之间切换fadeTo(speed,opacity,callback)speed:规定效果的时长，”slow”,”fast”或毫秒opacity:目标不透明度(0~1)callback:执行完后的函数名称 滑动slideDown(speed,callback)slideUp(speed,callback)向上滑动与向下滑动speed与callback与淡入淡出的一样slideToggle()也是相当于开关，在上述两种效果间切换 动画https://www.runoob.com/jquery/jquery-animate.html 停止动画: stop(stopAll,gotoEnd)stopAll参数规定是否应该清除动画队列，默认是falsegoToEnd参数规定是否立即完成当前动画，默认是false因此默认情况下stop()函数会清除在被选元素上指定的动画 捕获text() 设置或者返回所选元素的文本内容html() 设置货返回所选元素的内容（包括HTML标记)val() 设置或返回表单字段的值attr() 属性 对比列子:&lt;p id=&quot;as&quot;&gt;&lt;em&gt;啊啊啊&lt;/em&gt;&lt;span&gt;我的头&lt;/span&gt;&lt;/p&gt;通过分别对id等于”as”获取其text以及html，结果为可以看出html还返回了内容中的html标签等 修改 $(document).ready(function(){ $(&quot;.text&quot;).click(function(){ $(&quot;#as&quot;).html(&quot;&lt;em&gt;疑是地上霜&lt;/em&gt;&quot;); }); 修改id为”as”的html效果图: 本人最喜欢的还是接下来这个功能，修改属性值 $(document).ready(function(){ $(&quot;.text&quot;).click(function(){ $(&quot;#as&quot;).attr({ &quot;href&quot;:&quot;https://www.bilibili.com/&quot; }); }); 点击class为text的按钮后id为as的链接href就从其他转变为B站网址了 添加append()在被选元素的结尾插入内容比如$(&quot;p&quot;).append(&quot;gkd&quot;);是在p元素的末尾添加”gkd” prepend()在被选元素的开头插入内容比如$(&quot;p&quot;).prepend(&quot;yes&quot;);是在p元素的开头添加”yes” after()在被选元素之后插入内容 before()在被选元素之前插入内容这四个函数都允许多参数example:$(&quot;#as&quot;).append(txt1,txt2,txt3); 删除remove()删除被选元素及其子元素 empty()删除被选元素的子元素remove()和empty()的差别就是remove()删除被选元素，而empty()不删除]]></content>
      <categories>
        <category>coding</category>
      </categories>
      <tags>
        <tag>Javascript</tag>
        <tag>jQuery</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[编译原理预习笔记（一）]]></title>
    <url>%2Fhfuter7712.github.io%2F2019%2F09%2F02%2FcomplieP1%2F</url>
    <content type="text"><![CDATA[世界上第一个编译程序：FORTRAN编译程序于20世纪50年代中期研制成功 编译程序的工作一般可划分为五个阶段（编译程序工作时的动态特征）：1.词法分析任务：输入源程序，对构成源程序的字符串进行扫描和分解 ，识别出单词 2.语法分析任务： 在词法分析的基础上，根据语言的语法规则，把单词符号串分解为各类语法单位通过语法分析：确定整个输入串是否构成语法上正确的“程序”语法分析依循的是语言的语法规则语法规则通常用上下文无关文法描述 3.语义分析与中间代码产生任务：对语法分析所识别出的各类语法范畴，分析其含义，并进行初步翻译（产生中间代码） 4.优化任务：对前端产生的中间代码进行加工变换，以期在最后阶段能产生吃醋更为高效的目标代码 5.目标代码生成任务：把中间代码变换成特定机器上的低级语言代码 注：并非所有编译程序都分为五阶段 编译程序的结构：1.词法分析器（扫描器）输入源程序，进行词法分析，输出单词符号 2.语法分析器（分析器）对单词符号串进行语法分析 3.语义分析与中间代码产生器按照语义规则对语法分析器归约出的语法单位进行语义分析后把它们翻译成一定形式的中间代码 4.优化器对中间代码进行优化处理 5.目标代码生成器把中间代码翻译成目标程序 表格编译程序在工作过程中需要保持一些列的表格，用于登记源程序的各类信息和编译各阶段的进展情况在编译程序使用的表格中，最重要的是符号表 出错处理源程序中的错误通常分为语法错误和语义错误两大类语法错误：源程序中不符合语法规则的错误语义错误：源程序中不符合语义规则的错误 遍对源程序或源程序的中间结果从头到尾扫描一次 ，并作有关的加工处理，生成新的中间结果或目标程序当一遍中包含若干阶段时，各阶段的工作是穿插进行的 要在某一台机器上为某种语言构造一个编译程序，必须掌握下述三方面内容：1.源语言深刻理解其结构和含义 2.目标语言 3.编译方法 任何语言实现的基础是语言定义一个程序语言只使用一个有限字符集作为字母表单词符号是语言中具有独立意义的最基本结构语法单位比单词符号具有更丰富的意义 高级语言分类:1.强制式语言（过程式语言）特点：命令驱动，面向语句 2.应用式语言更注重程序所表示的功能，开发过程：从前面已有的函数触发构造出更复杂的函数 3.基于规则的语言执行过程：检查一定的条件，当他满足值时，执行适当的动作 4.面向对象语言主要特征：封装性，多态性，继承性等]]></content>
      <categories>
        <category>specialized-course</category>
      </categories>
      <tags>
        <tag>principle</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[计算机组成原理预习笔记（一）]]></title>
    <url>%2Fhfuter7712.github.io%2F2019%2F09%2F02%2FcomputerOrgan%2F</url>
    <content type="text"><![CDATA[来自MOOC电子科技大学课程+教材 电子计算机：可以存储程序，可以通过执行程序指令，可以自动，高速精确地对数字信息进行各种复杂处理 ，然后输出运算结果关键词：存储程序，执行程序，复杂处理，输出运算结果 5个逻辑设备(计算机五大件)： 输入设备，存储器，运算器，控制器，输出设备通过数据通路和控制通路相互连接形成有机整体由于运算器和控制器在逻辑关系和电路结构联系上十分紧密，因此两部往往结合在同一芯片上，合起来统称为中央处理器（Central Processing Unit，CPU）把输入设备与输出设备称为I/O设备 因此现代计算机可认为由三大部件组成：CPU，I/O设备，主存储器 CPU与主存储器合起来称为主机I/O设备又称为外部设备 主存储器是存储子系统中的一类，用来存放程序与数据，可直接与CPU交换信息另一类称为副主存储器，简称辅存，也称外存ALU和CU是CPU的核心部件 ALU（Arithmetic Logic Unit）:算术逻辑单元作用：完成算术逻辑运算以全加器为核心 CU（Control Unit）：控制单元作用：用来解析存储器中的指令，发出各种操作命令来执行命令 I/O设备受CU控制 信息的数字化表示1.在计算机中用数字代码（二进制代码）表示各种信息2.在物理机制上用数字信号表示数字代码 信息数字化优点：1.物理上容易实现信息的表示与存储2.抗干扰能力强，可靠性高3.数值表示范围大，精度高4.可标识的信息类型广泛5.能用数字逻辑技术进行处理 计算机从总体上来说分为两大类：模拟计算机和数字计算机模拟计算机：由模拟运算器件构成，处理在实践和数值上连续的模拟量数字计算机：由数字逻辑器件构成，处理离散数字量 机器字长：值CPU一次能处理数据的位数，通常与CPU的寄存器位数有关，机器字长的确定不能单从精度和数的标识范围来考虑 存储容量：主存容量+辅存容量存储容量 = 存储单元格数 * 存储字长用字节数来描述容量的大小 EDVAC 电子离散变量计算机（冯诺依曼思想）: 宣告电子计算机时代即将来临，在该指定的计划中首次提出了存储程序的概念第一台严格意义上的电子计算机： ENIAC 并夕法尼亚大学，1946年2月 冯诺依曼体系：1.用二进制代码表示程序与数据2.采用存储程序的工作方式3.新型的现代计算机硬件组成 主要器件第一代计算机（1946-1957）:电子管第二代计算机（1958-1964）:晶体管第三代计算机（1965-1971）:中小规模集成电路（速度达到MIPS级）第四-五代计算机（1972-今）：大规模，超大规模集成电路（速度高达GIPS甚至TIPS级别）（具体是1972-1977是第四代，1978-今是第五代） 未来发展趋势：1.巨型化方向2.微型化方向3.多媒体化方向4.网络化方向5.智能化方向 硬件：构成计算机系统的实体和装置之类的有形设备，是组成计算机系统的物质基础软件：由硬件所表达的各种内在信息，包括数据与控制程序，无形 系统软件：主要用来管理整个计算机系统，监事服务，使得系统资源得到合理调度，高效运行应用软件：用户根据任务需要所编制的各种程序 总线能为多个部件分时共享的一组信息传送通路计算机五大部件之间的互联方式有两种：1、各部件之间使用单独的连线，称为分散连接2、将各部件连到一组公共信息传输线上，称为总线连接 接口为了将总线与各类外设连接，需在两者之间设置的一些部件，具有缓冲，转换，连接等接口如VGA接口 计算机硬件的典型架构微型计算机：南-北桥架构小型计算机：多处理器架构超级计算机：集群式架构]]></content>
      <categories>
        <category>specialized-course</category>
      </categories>
      <tags>
        <tag>principle</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Jena javadoc 探索(二)]]></title>
    <url>%2Fhfuter7712.github.io%2F2019%2F09%2F02%2Fjenadoc2%2F</url>
    <content type="text"><![CDATA[Rule用来代表一般推理规则 规则范例: [ (?C rdf:type *), guard(?C, ?P) -&gt; (?c rb:restriction some(?P, ?D)) ]. [ (?s owl:foo ?p) -&gt; [ (?s owl:bar ?a) -&gt; (?s ?p ?a) ] ]. [name: (?s owl:foo ?p) -&gt; (?s ?p ?a)]. *代表通配符节点（wildcard node 可以匹配一切），?p代表变量，name(node ... node)代表一个仿函数(functor),(node,node,node)是一个三元模式，[..]是一个嵌入式规则(embedded rule) List rules=parseRules(String source)将一串字符串作为规则 用法(注:rules是String类型的字符串)： java.util.List&lt;Rule&gt; rules = Rule.parseRules(ruleSrc); GenericRuleReasoner一种能够援引各种有用的规则引擎结合，可以设置前向（forward），反向（backward）或者是混合（hybird）一般用法:Reasoner reasoner = new GenericRuleReasoner(Rule.parseRules(rules));个人理解：GenericRuleReasoner里面的参数是Rule组成的List,通过这些rules构成建Reasoner]]></content>
      <categories>
        <category>coding</category>
      </categories>
      <tags>
        <tag>Jena</tag>
        <tag>Java</tag>
        <tag>javadoc</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[FontAwesome图标字体库]]></title>
    <url>%2Fhfuter7712.github.io%2F2019%2F09%2F01%2FfontAwesome%2F</url>
    <content type="text"><![CDATA[(内容来自菜鸟教程，本博客为笔记)国内推荐CDN&lt;link rel=&quot;stylesheet&quot; href=&quot;https://cdn.staticfile.org/font-awesome/4.7.0/css/font-awesome.css&quot;&gt;使用fa前缀来放置Font Awesome设置class为fa fa-car可以设置汽车图标通过style设置图标大小和颜色font-size设置大小color设置颜色 列表图标设置类为fa-li fa外加第三个类为fa-check-square 为黑色打钩框框外加第三个类为fa-spinner fa-spin 为动态黑色转圈圈外加fa-square 为黑色实心正方形 动态图标设置类fa-spin可以让图标旋转设置类fa-pulse 让图标以8步为周期进行旋转 堆叠图标在&lt;span&gt;的class中添加类fa-stack即可然后依次键入需要堆叠的图标，越上面语句所产生的图像越在下层example:禁止照相 &lt;span class=&quot;fa-stack fa-lg&quot;&gt; &lt;i class=&quot;fa fa-camera fa-stack-1x&quot;&gt;&lt;/i&gt; &lt;i class=&quot;fa fa-ban fa-stack-2x text-danger&quot; style=&quot;color:red;&quot;&gt;&lt;/i&gt; &lt;/span&gt; 效果: 品牌图标大全网址:https://www.runoob.com/font-awesome/fontawesome-icons-brand.html个人喜好图标:fa fa-android 安卓图标fa fa-apple 苹果图标fa fa-edge edge图标fa fa-deviantart deviantart图标fa-fa-chrome chrome图标fa fa-facebook 脸书图标fa fa-facebook-official 脸书官方图标fa fa-free-code-camp freecodecamp图标fa fa-git git图标fa fa-github github图标fa fa-google 谷歌图标fa fa-html5 HTML5图标fa fa-internet-explorer IE图标fa fa-qq QQ图标fa fa-safari safari图标fa fa-share-alt 分享图标fa fa-steam steam图标fa fa-twitter 推特图标fa fa-usb usb图标fa fa-wechat 微信图标fa fa-weibo 微博图标fa fa-wikipedia-w 维基百科图标fa fa-windows 微软图标fa fa-youtube-play 油管图标 货币图标https://www.runoob.com/font-awesome/fontawesome-icons-currency.htmlfa fa-rmb人民币fa fa-eur欧元fa fa-usd美元 方向图标https://www.runoob.com/font-awesome/fontawesome-icons-directional.html 表单图标fa fa-check-square 黑框框里面一个√ 手势图标fa fa-thumbs-down 一个向下的大拇指(可以代表踩）fa fa-thumbs-up 一个向上的大拇指（可以代表赞)fa fa-thumbs-o-down 白色的赞fa fa-thumbs-o-up 白色的踩 付款图标https://www.runoob.com/font-awesome/fontawesome-icons-payment.html 加载图标https://www.runoob.com/font-awesome/fontawesome-icons-spinner.html Font Awesome参考手册https://www.runoob.com/font-awesome/fontawesome-reference.html 总结：是一个很好的图标库，可以有效地帮助我们改善某些小组件的设计]]></content>
      <categories>
        <category>coding</category>
      </categories>
      <tags>
        <tag>HTML</tag>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Jena javadoc 探索(一)]]></title>
    <url>%2Fhfuter7712.github.io%2F2019%2F09%2F01%2FJenadoc1%2F</url>
    <content type="text"><![CDATA[官方javadoc:http://jena.apache.org/documentation/javadoc/jena/ (PS:谷歌翻译在这里面无效，全都是阅读理解得来的) ModelFactory createDefaultModel具体用法: Model model=ModelFactory.createDefaultModel();用于返回一个默认规格的新模型（fresh model） createInfModel(InfGraph g)从推理图表g中获取一个推理模型 createInfModel(Reasoner reasoner, Model model)将给定的RDF模型model附加到给定的推理器reasoner上来获取一个推理模型具体用法:InfModel infmodel=ModelFactory.createInfModel(reasoner,data); createInfModel(Reasoner reasoner, Model schema, Model model)（官方函数解释和上面一个函数一致，但是参数多了一个schema模型，目前不确定是什么意思，在后续会实践验证) createOntologyModel()返回一个加载了用默认本体语言（OWL）表达的内存模型的本体模型（可以理解为默认OnModelSpec spec参数为OWL) createOntologyModel(OntModelSpec spec)根据所给定的参数设定建立新的本体模型 createOntologyModel(OntModelSpec spec, Model base)根据所给定的参数设定建立新的本体模型，并且以给定的模型base中的数据作为初始数据 createRDFSModel(Model model)在所给模型model中所有可导出的RDFS语法(RDFS entailments derivable)都可行的情况下返回一个模型 createRDFSModel(Model schema, Model model)在模型schema和model的可导出RDFS语法(RDFS entailments derivable)都可行的情况下返回模型 Interface Reasoner bindSchema(Graph tbox)将一个本体(ontology)附加到一个推理器(reasoner)上的最普遍方法 bindSchema(Model tbox)与上述函数同理用法: reasoner=reasoner.bindSchema(schema); setDerivationLogging(boolean logOn) 设置drivation logging的开关 setParameter(Property parameterUri, Object value)设置推理器的参数比如设置RDFS推理器的等级 reasoner.setParameter(ReasonerVocabulary.PROPsetRDFSLevel, ReasonerVocabulary.RDFS_SIMPLE); FileManager 可以从一个系统资源加载RDF数据到一个已经存在的模型或者新建立的模型FileManage和LocationMapper一同工作 get()获取全局文件管理者（global file manager） loadModel(String filenameOrURI)loadModel(String filenameOrURI, String rdfSyntax)loadModel(String filenameOrURI, String baseURI, String rdfSyntax) 用法（来自Jena官方文档推理api）:Model schema = FileManage.get().loadModel(&quot;file:data/owlDemoSchema.owl&quot;); 从一个文件中加载模型参数解释:baseURI:加载RDF模型的基本URIrdfSynatax: RDF Serialization synatax—-RDF序列化语法（翻译自百度翻译) readModel(Model model, String filenameOrURI)readModel(Model model, String filenameOrURI, String rdfSyntax)readModel(Model model, String filenameOrURI, String baseURI, String syntax)读取若干RDF数据并导入模型model中参数解释同上述loadModel Model InfModel 在Jena中推理的主要作用是给RDF数据集增加限制,这些需求只是以推理模型中附加的RDF数据的形式出现举个例子：如果一个推理引擎可以确定一个叫做“foo”的资源是“fooClass”那么当三元组 foo rdf:type fooClass .在数据集中时 ，所有Model API 比如说listStatments或者getProperty应当act(不知道咋翻译) listStatements(Resource subject, Property predicate, RDFNode object, Model posit)返回一个迭代器，包含该模型中所有的statements参数：subject：主语predicate:谓语object:宾语类似于三元组的(s,p,o) Model RDF模型 add(List&lt;Statement&gt; statements)将List中所有的statement都添加到模型中 add(Model m)将模型m中所有的statement都添加到当前模型中 add(Statement s)单单添加s语句到模型中 add(StmtIterator iter)将该迭代器中所有statements添加到当前模型中 close()关闭模型并释放资源所占用的内存 contains(Resource s, Property p)布尔型函数，判断模型中是否含有resource为s，property为p的statement contains(Resource s, Property p, RDFNode o)布尔型函数，判断模型中是否含有(s,p,o)模式的语句 contains(Statement s)布尔型函数，判断模型中是否含有该语句 containsAll(Model model)布尔型函数，判断当前model是否包含参数中model的所有语句（个人感觉应该是用来判断是否包含） createResource()创建一个新的匿名Resource具体用法(注:rdfsExample是一个Model实例):rdfsExample.createResource(NS+&quot;a&quot;) createStatement(Resource s, Property p, RDFNode o)创建一个新的statement difference(Model model)创建一个新的，独立的模型包含当前模型所有的而参数中模型中没有的statements getProperty(Resource s, Property p)返回一个resource为s，Property为p的statement（s,p,?o) getResource(String uri)根据参数中的url返回对应的资源resource independent()布尔型函数，判断该模型是否独立 isEmpty()布尔型函数，判断模型是否为空 listObjects()列举出模型中所有的object（类型为NodeIterator) listStatements(Resource s, Property p, RDFNode o)列举出满足特定条件的所有statement（类型为StmtIterator) listSubjects()列举出模型中所有的subject（类型为ResIterator) query(Selector s)创建一个包含满足某个特定查询的所有语句的新模型 read(InputStream in, String base)从指定输入流文档中读取statements remove(List&lt;Statement&gt; statements)将该List中所有的statement从模型中移去（适用于一次性移去大规模statement) remove(Statement s)将s从该模型中移去 removeAll()将当前模型中所有语句都移除 setNsPrefix(String prefix, String uri)为指定URI prefix设定prefix name size()返回当前模型的大小（statement语句的数量） union(Model model)将当前模型和参数中的model进行联合 write(Writer writer)将当前模型写成XML文档 ReasonerRegistry感觉和ModelFactory类似，用于reasoner的注册（即创建）一般用法:Reasoner reasoner = ReasonerRegistry.getRDFSReasoner(); getOWLReasoner()预建立一个标准配置的默认OWL推理器 getRDFSReasoner()预建立一个标准配置的默认RDFS推理器 create(String uri, Resource configuration)创建并返回一个被给定uri标记的reasoner 创建配置资源格式: Resource config = ModelFactory.createDefaultModel() .createResource() .addProperty(ReasonerVocabulary.PROPsetRDFSLevel, &quot;simple&quot;);]]></content>
      <categories>
        <category>coding</category>
      </categories>
      <tags>
        <tag>Jena</tag>
        <tag>Java</tag>
        <tag>javadoc</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[计算机基础笔记（freecodecamp)]]></title>
    <url>%2Fhfuter7712.github.io%2F2019%2F08%2F31%2FcomputerB%2F</url>
    <content type="text"><![CDATA[计算机由四个基本部分组成：输入，输出，CPU和存储器CPU对存储器具有独占访问权，无法通过输入和输出来访问内存而不适用CPU存储器可以分为短期存储器（RAM）和长期存储器 ，长期存储器通常是硬盘主板是连接硬件的东西，当数据导出流动试图找出该去哪里的时候，主板起到的是一个导流作用扩展卡：声卡、显卡之类的可以提升用户体验的东西电源：给计算机提供电力一个芯片由成千上万个晶体管（只能是0或1的开关）组成 ，所有这些晶体管塞进了一个芯片里一个芯片上集成的晶体管数量决定了芯片的大小与速度摩尔定律：观察到自从1965年芯片上的晶体管数量每两年增加一倍的一种规律（但是在近几年增加速度逐渐减慢） 数据的大小数据大小是按字节来计算的 最小的单位称之为1比特(bit)比特只能是0或14比特(bit)8比特(bit)，字节KB，1024个字节MB，1024的平方个字节GB，1024的立方个字节TB，1024的四次方个字节PB，1024的五次方个字节数据的速度数据速率是按照比特来计算的 音频下载中，用的是KB/s网速用的是MB/s网络中用GB/s此外，如果你看到你的网速有多少多少比特每秒，记住它永远比按你提到数据大小时的字节小8倍 所有数字（255及以下），字母和符号都可以被转化为计算机所理解的字节 —错题：“记住这些转化是一种很好的做法”我选择了true，但是其实是false，理由是“你只需要查阅就好了” 计算机的种类最大的一个类型称为超级计算机，一种使用一种叫做 并行处理 的技术同理用很多CPU处理同一问题的计算机下一种类型叫做服务器，服务器拥有并访问大量的数据或程序其次是工作站，一种和个人电脑非常类似的计算机，但是更耗能而且贵得多然后是个人电脑最后是微控制器 主板主板的构成是处理器和内存之间的桥梁扩展槽：可以插入任意提高计算及性能的东西 数据网络三种类型分别为局域网（LAN），广域网（WAN），虚拟专用网（VPN）局域网就像是一小组计算机连接在了一起。特征：离的很近广域网：两个以上的局域网长距离的连接起来一个广域网通常租用来自因特网公司的电缆来创建连接同样是连接局域网，广域网使用租用的电缆而VPN使用互联网 IP地址是基于位置分配的如果一个设备没有IP地址，因特网无法向它发送数据IP地址由位置所决定，起始于5个大型国际地区 软件软件是程序或者在硬件上运行的程序软件是写入硬件的代码有三个主要的操作系统： Windows，Max和Linux CDN（内容传递网络)CDN是一种分布式服务器，基于用户的地理位置向用户分发网页和其他Web内容目标：建立更高质量的网络连接 采样一个模拟声波看起来像任何东西计算机采集和测量很多不同的点，把他们转化成数字，就是所谓的采样 数据压缩压缩声音的一种常用方法是以更低的频率采样，另一种方式是从一个重点而不是从0开始采样，因此采集的声音更小在图像中：通过测量一组16个的像素来压缩，而不是独立的 路由器是连接不同的小范围网络的东西路由器甚至不必有完整的包的信息倘若一台电脑正试图将信息发送到另一个电脑时，数据可能会在不同的路由器之间分开，但是没关系，计算机仍然知道如何正确的把信息重新组合到一起所发送信息的小碎片称为数据包 包实际上是一小段二进制代码 源代码本身是程序员创建的文本文档编译器与解释器不同，编译器将其所有的工作都放在了程序员的端上 开源：意味着所有的文档和源代码是开放及可以访问的 控制台常用于显示系统管理级的消息 计算机安全字典攻击：尝试字典里的每一个字词，或者是它自己数据库中的常见词汇和很多人使用过的密码创建密码时，使用不同的类型，数字和符号，不要使用序列号学习加密和HTTPS来免受这些攻击HTTPS相比HTTP更加安全 ，因为向该网站所发送的密码和其他信息都被加密 DOM(Document Object Model)DOM是浏览器的内部，网页的程序化称呼，JS允许修改网页的DOM结构从技术上来讲，DOM是一种API DOM会告诉浏览器，一旦HTML被加载，他就已经准备好了，但是有时候CSS和JS还没进来 MDN（Mozilla Developer Network)是一个很棒的开源项目，不仅有JS相关文档，还有其他语言和主题的文档]]></content>
      <categories>
        <category>coding</category>
      </categories>
      <tags>
        <tag>计算机</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[502 Bad Gateway]]></title>
    <url>%2Fhfuter7712.github.io%2F2019%2F08%2F31%2F502%2F</url>
    <content type="text"><![CDATA[今天在访问某站时出现了 502 Bad Gateway的错误提示上网搜索后知道如下该类错误是指错误网关，无效网关，并不是意味着上游服务器已关闭，而是上游服务器和网关/代理使用不一致的协议交换数据一般原因：向服务器发送请求，由于服务器当前链接过多，导致服务器方面无法给予正常相应（来自百度词条）]]></content>
      <categories>
        <category>coding</category>
      </categories>
      <tags>
        <tag>术语</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bootstrap学习]]></title>
    <url>%2Fhfuter7712.github.io%2F2019%2F08%2F30%2Fbootstrap1%2F</url>
    <content type="text"><![CDATA[网格系统example: &lt;div class=&quot;row&quot;&gt; &lt;div class=&quot;col-sm-3&quot;&gt;.col-sm-3&lt;/div&gt; &lt;div class=&quot;col-sm-3&quot;&gt;.col-sm-3&lt;/div&gt; &lt;div class=&quot;col-sm-3&quot;&gt;.col-sm-3&lt;/div&gt; &lt;div class=&quot;col-sm-3&quot;&gt;.col-sm-3&lt;/div&gt; &lt;/div&gt; 效果（每个div都赋予了不同颜色以分辨）:超小设备 .col-平板 .col-sm-桌面显示器 col-md- &lt;div class=&quot;row&quot;&gt; &lt;div class=&quot;col-sm-3 first&quot;&gt;.col-sm-3&lt;/div&gt; &lt;div class=&quot;col-sm-3 offset-sm-3 second&quot;&gt;.col-sm-3&lt;/div&gt; &lt;/div&gt; offset-sm-3相当于偏移一个col-sm-3效果: 颜色文本颜色(个人感觉可用于连接) &lt;p class=&quot;text-muted&quot;&gt;柔和的文本。&lt;/p&gt; &lt;p class=&quot;text-primary&quot;&gt;重要的文本。&lt;/p&gt; &lt;p class=&quot;text-success&quot;&gt;执行成功的文本。&lt;/p&gt; &lt;p class=&quot;text-info&quot;&gt;代表一些提示信息的文本。&lt;/p&gt; &lt;p class=&quot;text-warning&quot;&gt;警告文本。&lt;/p&gt; &lt;p class=&quot;text-danger&quot;&gt;危险操作文本。&lt;/p&gt; &lt;p class=&quot;text-secondary&quot;&gt;副标题。&lt;/p&gt; &lt;p class=&quot;text-dark&quot;&gt;深灰色文字。&lt;/p&gt; &lt;p class=&quot;text-light&quot;&gt;浅灰色文本（白色背景上看不清楚）。&lt;/p&gt; &lt;p class=&quot;text-white&quot;&gt;白色文本（白色背景上看不清楚）。&lt;/p&gt; 表格提供了特色表格，通过定义&lt;table class=&quot;table&quot;&gt; 来设置设置前:设置后:设置带条纹的表格:在table类的基础上再添加一个.table-striped黑色的表格（逼格) 添加类table-dark将上述两个合起来得到本人认为最霸气的表格可以通过设定其中不同的tr来实现在一个表格中有不同的效果 响应式图片图片的大小需要根据屏幕的大小自动适应添加类.img-fluid即可（本质是将图片的max-width设置为100%，height设为auto) 按钮来自菜鸟教程 &lt;button type=&quot;button&quot; class=&quot;btn&quot;&gt;基本按钮&lt;/button&gt; &lt;button type=&quot;button&quot; class=&quot;btn btn-primary&quot;&gt;主要按钮&lt;/button&gt; &lt;button type=&quot;button&quot; class=&quot;btn btn-secondary&quot;&gt;次要按钮&lt;/button&gt; &lt;button type=&quot;button&quot; class=&quot;btn btn-success&quot;&gt;成功&lt;/button&gt; &lt;button type=&quot;button&quot; class=&quot;btn btn-info&quot;&gt;信息&lt;/button&gt; &lt;button type=&quot;button&quot; class=&quot;btn btn-warning&quot;&gt;警告&lt;/button&gt; &lt;button type=&quot;button&quot; class=&quot;btn btn-danger&quot;&gt;危险&lt;/button&gt; &lt;button type=&quot;button&quot; class=&quot;btn btn-dark&quot;&gt;黑色&lt;/button&gt; &lt;button type=&quot;button&quot; class=&quot;btn btn-light&quot;&gt;浅色&lt;/button&gt; &lt;button type=&quot;button&quot; class=&quot;btn btn-link&quot;&gt;链接&lt;/button&gt; 这些按钮的类还可以用于&lt;a&gt;和&lt;input&gt;中 禁用按钮(个人感觉以后可以用于特定条件下的按钮设定，通过JS改变按钮的可用性，比如说要输入用户名才能点击下一步，否则禁用)添加类.disabled徽章我觉得这个可以有 &lt;p class=&quot;badge badge-danger&quot;&gt;警告&lt;/p&gt; &lt;p class=&quot;badge badge-dark&quot;&gt;失效&lt;/p&gt; &lt;p class=&quot;badge badge-info&quot;&gt;新消息&lt;/p&gt; &lt;p class=&quot;badge badge-light&quot;&gt;温馨提示&lt;/p&gt; &lt;p class=&quot;badge badge-primary&quot;&gt;主要&lt;/p&gt; &lt;p class=&quot;badge-secondary badge&quot;&gt;次要&lt;/p&gt; &lt;p class=&quot;badge-success badge&quot;&gt;注册成功&lt;/p&gt; &lt;p class=&quot;badge badge-warning&quot;&gt;warning&lt;/p&gt; 效果: 分页在&lt;ul&gt;标签中添加.pagination类，然后在下属&lt;li&gt;中添加.page-item类，然后在li下属的&lt;a&gt;中添加.page-link类 &lt;ul class=&quot;pagination&quot;&gt; &lt;li class=&quot;page-item&quot;&gt;&lt;a class=&quot;page-link&quot;&gt;Previous&lt;/a&gt;&lt;/li&gt; &lt;li class=&quot;page-item&quot;&gt;&lt;a class=&quot;page-link&quot;&gt;1&lt;/a&gt;&lt;/li&gt; &lt;li class=&quot;page-item&quot;&gt;&lt;a class=&quot;page-link&quot;&gt;2&lt;/a&gt;&lt;/li&gt; &lt;li class=&quot;page-item&quot;&gt;&lt;a class=&quot;page-link&quot;&gt;3&lt;/a&gt;&lt;/li&gt; &lt;li class=&quot;page-item&quot;&gt;&lt;a class=&quot;page-link&quot;&gt;4&lt;/a&gt;&lt;/li&gt; &lt;li class=&quot;page-item&quot;&gt;&lt;a class=&quot;page-link&quot;&gt;next&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; 效果: 同样的道理，如果想要设置链接不可点击，只要在li的class添加.disabled类即可 ———-分割线———- 以下内容需要添加下属语句 &lt;script src=&quot;https://cdn.staticfile.org/jquery/3.2.1/jquery.min.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;https://cdn.staticfile.org/popper.js/1.15.0/umd/popper.min.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;https://cdn.staticfile.org/twitter-bootstrap/4.3.1/js/bootstrap.min.js&quot;&gt;&lt;/script&gt; 在原先bootstrap link添加即可折叠内容 &lt;div class=&quot;container&quot;&gt; &lt;button type=&quot;button&quot; class=&quot;btn btn-primary&quot; data-toggle=&quot;collapse&quot; data-target=&quot;#demo&quot;&gt;简单的折叠&lt;/button&gt; &lt;div id=&quot;demo&quot; class=&quot;collapse&quot;&gt; this is a card which can hide yeah this is second paragraph third fourth &lt;/div&gt; &lt;/div&gt; 一开始进入的时候内容会隐藏，点击按钮后有一个下滑动画，显示出内容 下拉列表初始状态是一个带着下三角的按钮，点击会下拉一个列表example: &lt;div class=&quot;container&quot;&gt; &lt;div class=&quot;dropdown&quot;&gt; &lt;button type=&quot;button&quot; class=&quot;btn btn-primary dropdown-toggle&quot; data-toggle=&quot;dropdown&quot;&gt;省份&lt;/button&gt; &lt;div class=&quot;dropdown-menu&quot;&gt; &lt;a class=&quot;dropdown-item&quot; href=&quot;#&quot;&gt;福建&lt;/a&gt; &lt;a class=&quot;dropdown-item&quot; href=&quot;#&quot;&gt;湖北&lt;/a&gt; &lt;a class=&quot;dropdown-item&quot; href=&quot;#&quot;&gt;安徽&lt;/a&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; 效果: 导航(个人偏好的一种) 大体代码: &lt;div class=&quot;container&quot;&gt; &lt;ul class=&quot;nav nav-tabs&quot;&gt; &lt;li class=&quot;nav-item&quot;&gt; &lt;a class=&quot;nav-link&quot; data-toggle=&quot;tab&quot; href=&quot;#WH&quot;&gt;武汉&lt;/a&gt; &lt;/li&gt; &lt;li class=&quot;nav-item&quot;&gt; &lt;a class=&quot;nav-link&quot; data-toggle=&quot;tab&quot; href=&quot;#QZ&quot;&gt;泉州&lt;/a&gt; &lt;/li&gt; &lt;li class=&quot;nav-item&quot;&gt; &lt;a class=&quot;nav-link&quot; data-toggle=&quot;tab&quot; href=&quot;#XC&quot;&gt;宣城&lt;/a&gt; &lt;/li&gt; &lt;li class=&quot;nav-item&quot;&gt; &lt;a class=&quot;nav-link&quot; data-toggle=&quot;tab&quot; href=&quot;#SH&quot;&gt;上海&lt;/a&gt; &lt;/li&gt; &lt;/ul&gt; &lt;div class=&quot;tab-content&quot;&gt; &lt;div class=&quot;container tab-pane active&quot; id=&quot;QZ&quot;&gt; 泉州市隶属于福建，地级市 &lt;/div&gt; &lt;div class=&quot;container tab-pane fade&quot; id=&quot;WH&quot;&gt; 武汉市隶属于湖北，省会 &lt;/div&gt; &lt;div class=&quot;container tab-pane fade&quot; id=&quot;XC&quot;&gt; 宣城市隶属于安徽，地级市 &lt;/div&gt; &lt;div class=&quot;container tab-pane fade&quot; id=&quot;SH&quot;&gt; 上海，直辖市 &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; 效果图: 面包屑导航是一种基于网络层次信息的显示方式代码如下: &lt;div class=&quot;container&quot;&gt; &lt;ol class=&quot;breadcrumb&quot;&gt; &lt;li class=&quot;breadcrumb-item&quot;&gt;&lt;a href=&quot;#&quot;&gt;文档&lt;/a&gt;&lt;/li&gt; &lt;li class=&quot;breadcrumb-item&quot;&gt;&lt;a href=&quot;#&quot;&gt;功能性文档&lt;/a&gt;&lt;/li&gt; &lt;li class=&quot;breadcrumb-item active&quot;&gt;C++&lt;/li&gt; &lt;/ol&gt; &lt;/div&gt; 效果图: 幻灯片切换效果链接:https://www.runoob.com/bootstrap4/bootstrap4-carousel.html]]></content>
      <categories>
        <category>coding</category>
      </categories>
      <tags>
        <tag>HTML</tag>
        <tag>Bootstrap</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[.org--互联网的通用顶级域之一]]></title>
    <url>%2Fhfuter7712.github.io%2F2019%2F08%2F30%2Forg%2F</url>
    <content type="text"><![CDATA[.org域名是互联网的通用顶级域之一，适用于各类组织机构，全称为Origanizations.ORG任何人（包括盈利组织，个人，非营利组织等）都可以注册 规则(来自百度百科):1.只提供英文字母（大小写皆可），数字以及连接符-2.-不能用作开头和结尾3.长度不能超过63个字符]]></content>
      <categories>
        <category>coding</category>
      </categories>
      <tags>
        <tag>术语</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Jena全面学习+小细节]]></title>
    <url>%2Fhfuter7712.github.io%2F2019%2F08%2F29%2FJenaL%2F</url>
    <content type="text"><![CDATA[Jena实例代码二中有一个VCARD类，去官方javadoc看了也没解释是干啥的，后来在网上查了原来是电子名片的意思]]></content>
      <categories>
        <category>coding</category>
      </categories>
      <tags>
        <tag>Jena</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端页面设计时的那些乱七八糟的注意事项]]></title>
    <url>%2Fhfuter7712.github.io%2F2019%2F08%2F26%2Ffront-end%20first%20notice%2F</url>
    <content type="text"><![CDATA[各种RGB颜色:https://www.runoob.com/html/html-colornames.htmlHTML速查表:https://www.runoob.com/html/html-quicklist.htmlHTML标签列表:https://www.runoob.com/tags/html-reference.htmlHTML事件列表:https://www.runoob.com/tags/ref-eventattributes.htmlHTML拾色器:https://www.runoob.com/tags/html-colorpicker.html CSS参考手册:https://www.runoob.com/cssref/css-reference.htmlCSS Web安全字体:https://www.runoob.com/cssref/css-websafe-fonts.html XHTML是以XML格式编写的HTML注意:在XHTML中空元素必须包含关闭标签example: 不能写&lt;br&gt;,而是&lt;br /&gt;]]></content>
      <categories>
        <category>coding</category>
      </categories>
      <tags>
        <tag>HTML</tag>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Jena2]]></title>
    <url>%2Fhfuter7712.github.io%2F2019%2F08%2F11%2FJena2%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[mysql+D2RQ+D2R+sparql第一次实践]]></title>
    <url>%2Fhfuter7712.github.io%2F2019%2F08%2F07%2FmysqlD2RQ1%2F</url>
    <content type="text"><![CDATA[因为大创需求，需要将数据库中的内容转换成rdf然后给Apache Jena进行推理，因此对一系列的知识进行了学习，今天终于迎来了第一次综合实践首先我在mysql中构建了一个叫做test的数据库，然后建立了一个叫做metal的表随随便便输入了几个数据如下然后开始运用D2RQ处理进入D2RQ根目录打开cmd输入以下语句.\generate-mapping -u root -p yyn321 -o test.ttl jdbc:mysql:///test?useSSL=falseyyn321是数据库密码test.ttl是要生成的ttl文件的名字mysql:///后面跟的是需要进行处理的数据库的名字比如你的数据库名字是test,就这样写:jdbc:mysql:///test?是metro的话就jdbc:mysql:///metro?回车之后没有任何提示直接进入下一个语句在根目录下生成了对应的ttl文件，这个就是默认的mapping language映射文件打开可以看到一系列代码可以选择手工修改，本人这里暂时不动（先熟悉操作）再在刚刚的cmd中继续输入下列代码dump-rdf -o test.nt test.ttl和第一条语句一样，并没有提示任何东西，在根目录下生成了一个同名nt文件打开看到大量代码，这个就是所谓的RDF文件了，仔细观察都是三个一组接下来的操作便是通过这个文件打开D2R服务器在cmd中输入d2r-server test.ttl显示在服务器在2020端口 打开 在浏览器上进入2020端口显示页面如下单击metal,进入界面如下单击metal#1界面如下 返回主界面，点击最下列sparql窗口的链接即可进入sparql查询界面 在其中输入sparql语句即可进行查询 查询人数大于4的乐队查询乐队nightwish的歌曲]]></content>
      <categories>
        <category>coding</category>
      </categories>
      <tags>
        <tag>D2RQ</tag>
        <tag>Sparql</tag>
        <tag>mysql</tag>
        <tag>D2R</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mysql数据库基础学习（一）]]></title>
    <url>%2Fhfuter7712.github.io%2F2019%2F08%2F07%2Fmysql1%2F</url>
    <content type="text"><![CDATA[启动mysql数据库以管理员身份打开cmd命令行工具,切换目录到mysql根目录的bin文件夹下初始化数据库mysqld --initialize --console执行完毕后，会输出root用户的默认密码输入安装命令mysqld install —启动mysql命令—net start mysql —登录本机的mysql数据库—mysql -u root -p之后会要求输入密码，输入即可输入exit或者quit退出登录 —-数据库操作—- USE 数据库名选择要操作的Mysql数据库，使用该命令后所有命令都只针对该数据库 SHOW DATABASES列出mysql数据库管理系统的数据库列表 SHOW TABLES列出指定数据库的所有表 CREATE 数据库可在登陆MySQL服务后使用create创建数据库CREATE DATEBASE 数据库名;如 CREATE DATEBASE TEST; DROP 数据库用drop命令删除数据库drop database 数据库名;以下是创建并删除一个数据库的实践 CREATE 数据表CREATE TABLE table_name(column_name column_type);column_name是表单名字，column_type是内容的数据类型example(来自菜鸟教程): CREATE TABLE IF NOT EXISTS `runoob_tbl`( `runoob_id` INT UNSIGNED AUTO_INCREMENT, `runoob_title` VARCHAR(100) NOT NULL, `runoob_author` VARCHAR(40) NOT NULL, `submission_date` DATE, PRIMARY KEY ( `runoob_id` ) )ENGINE=InnoDB DEFAULT CHARSET=utf8; DROP 数据表DROP TABLE table_name在进行删除表操作的时候要非常小心，因为执行删除命令后所有数据都会消失 INSERT INTO使用该语句向数据表中插入数据 INSERT INTO table_name(field1,field2,...fieldN) VALUES (value1,value2,...valueN); example(亲自实践):该操作向数据库中添加了一组数据，结果显示成功 SELECT 查询数据语法: SELECT column_name,column_name FROM table_name [WHERE Clause] [LIMIT N][ OFFSET M] example:该查询选择了曲目名字和乐队名字，乐队成员大于5且限制输出2条匹配 WHERE 提供条件查询 SELECT field1, field2,...fieldN FROM table_name1, table_name2... [WHERE condition1 [AND [OR]] condition2..... 可以用AND 或者OR制定一个或多个条件 UPDATE 更新用于更新也就是修改MySQL中的数据 UPDATE table_name SET field1=new-value1, field2=new-value2 [WHERE Clause] 注意，必须谨慎操作，因为如果少了WHERE条件语句，你的所有相应数据都会被修改将id为8的曲目submission_data更新为1999-08-04 DELETE 删除用于删除MySQL中的数据DELETE FROM table_name [WHERE Clause]和update一样，这两个语句必须谨慎操作，没有where语句的情况下，所有相应数据都会被删除 LIKE 字符串匹配用于WHERE语句中，主要适用于字符串类型的数据的选择 SELECT field1, field2,...fieldN FROM table_name WHERE field1 LIKE condition1 [AND [OR]] filed2 = &apos;somevalue&apos; example: &apos;%a&apos; 以a结尾 &apos;a%&apos; 以a开头 &apos;%a%&apos; 含有a &apos;_a_&apos; 三位字符串且a位于中间位置 &apos;_a&apos; 两位字符串且a位于末尾 &apos;a_&apos; 两位字符串且a位于开头 UNION用于连接两个以上的SELECT语句的结果到一个结果集合中，多个SELECT语句会删除重复的数据 SELECT expression1, expression2, ... expression_n FROM tables [WHERE conditions] UNION [ALL | DISTINCT] SELECT expression1, expression2, ... expression_n FROM tables [WHERE conditions]; DISTINCT:删除结果集中重复的数据ALL:返回所有数据集，包括重复的数据 ORDER BY 排序 SELECT field1, field2,...fieldN FROM table_name1, table_name2... ORDER BY field1 [ASC [DESC][默认 ASC]], [field2...] [ASC [DESC][默认 ASC]] 默认是ASC 升序排列，可以使用DESC修饰符来进行降序排列example:按照乐队名字降序排序按照乐队成员升序排序 GROUP BY 分组该语句根据一个或者多个列对结果进行分组 SELECT column_name, function(column_name) FROM table_name WHERE column_name operator value GROUP BY column_name; 使用WITH ROLLUP可以实现在分组统计数据基础上再进行相同的统计（SUM,AVG,COUNT…)example: 按照出现过的数字总和，并在最后求和按照出现过的数组求平均值按照每个乐队出现过的次数 MySQL菜鸟教程：https://www.runoob.com/mysql/mysql-tutorial.html]]></content>
      <categories>
        <category>coding</category>
      </categories>
      <tags>
        <tag>数据库</tag>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[D2RQ数据导出-从数据库到RDF mapping language学习(一)]]></title>
    <url>%2Fhfuter7712.github.io%2F2019%2F08%2F06%2FD2RQLearn1%2F</url>
    <content type="text"><![CDATA[官方文档:R2RQ的映射结构:;模板:以下实例D2RQ映射将数据库中的表会议与本体中的类会议相关联，可以使用地图作为模板来编写自己的地图 # D2RQ Namespace @prefix d2rq: &lt;http://www.wiwiss.fu-berlin.de/suhl/bizer/D2RQ/0.1#&gt; . # Namespace of the ontology @prefix : &lt;http://annotation.semanticweb.org/iswc/iswc.daml#&gt; . # Namespace of the mapping file; does not appear in mapped data @prefix map: &lt;file:///Users/d2r/example.ttl#&gt; . # Other namespaces @prefix rdfs: &lt;http://www.w3.org/2000/01/rdf-schema#&gt; . @prefix xsd: &lt;http://www.w3.org/2001/XMLSchema#&gt; . map:Database1 a d2rq:Database; d2rq:jdbcDSN &quot;jdbc:mysql://localhost/iswc&quot;; d2rq:jdbcDriver &quot;com.mysql.jdbc.Driver&quot;; d2rq:username &quot;user&quot;; d2rq:password &quot;password&quot;; . # ----------------------------------------------- # CREATE TABLE Conferences (ConfID int, Name text, Location text); map:Conference a d2rq:ClassMap; d2rq:dataStorage map:Database1; d2rq:class :Conference; d2rq:uriPattern &quot;http://conferences.org/comp/confno@@Conferences.ConfID@@&quot;; . map:eventTitle a d2rq:PropertyBridge; d2rq:belongsToClassMap map:Conference; d2rq:property :eventTitle; d2rq:column &quot;Conferences.Name&quot;; d2rq:datatype xsd:string; . map:location a d2rq:PropertyBridge; d2rq:belongsToClassMap map:Conference; d2rq:property :location; d2rq:column &quot;Conferences.Location&quot;; d2rq:datatype xsd:string; . 属性:D2RQ : jdbcDSN JDBC数据库URL，是一个表单的字符串D2RQ : jdbcDriver 数据库的JDBC驱动程序类名称D2RQ : username 若数据库有要求，用户名D2RQ : password 若数据库有要求，密码D2RQ : resultSizeLimit 整数值，作为LIMIT添加到所有SQL查询中，设置从大型数据库返回结果数的上限D2RQ : FETCHSIZE 整数值，指定每个数据库请求要求检索的行数D2RQ : startupSQLScript 启动的时候要执行的SQL脚本的URL，用于初始化连接与测试 示例一：连接mysql数据库 map:Database1 a d2rq:Database; d2rq:jdbcDSN &quot;jdbc:mysql://localhost/iswc&quot;; d2rq:jdbcDriver &quot;com.mysql.jdbc.Driver&quot;; d2rq:username &quot;user&quot;; d2rq:password &quot;password&quot;; . 保持长期的连接某些数据库服务器可能会在一段时间后关闭客户端连接（如mysql，为8小时），为了保持长期的连接（可能是为了转换数据），可以将D2R配置为定期运行“noop”查询，可以使用特殊属性启用该功能jdbc:keepAliveexample: @prefix jdbc: &lt;http://d2rq.org/terms/jdbc/&gt; . map:database a d2rq:Database; # ... other database configuration ... jdbc:keepAlive &quot;3600&quot;; # value in seconds jdbc:keepAliveQuery &quot;SELECT 1&quot;; # (optionally to override default noop query) . 映射引擎的全局配置d2rq : Configuration控制D2RQ的全局行为D2RQ : serveVocabulary 是否提供推断和用户提供的词汇数据D2RQ : useAllOptimizations 是否使用出血边缘优化(bleeding edge optimizations) 创建RDF资源d2rq :ClassMap 表示OWL本体或者RDFS模式的类或一组类似类，类映射定义了如何识别类的实例，它连接到a d2rq : Database 并且具有一组d2rq:PropertyBridges附加属性的实例 d2rq:ClassMap属性 example: —–使用URI模式标识类映射实例—– map:PaperClassMap a d2rq:ClassMap; d2rq:uriPattern &quot;http://www.conference.org/conf02004/paper#Paper@@Papers.PaperID@@&quot;; d2rq:class :Paper; d2rq:classDefinitionLabel &quot;paper&quot;@en; d2rq:classDefinitionComment &quot;A conference paper.&quot;@en; d2rq:dataStorage map:Database1; . 涉及到的d2rq:uriPattern 指定将用于标识此类映射实例的URI模式d2rq:class RDFS或者OWL类，该ClassMap生成的所有资源都是此类的实例d2rq:classDefinitionLabel 指定将rdfs:label用于所有关联类定义的标签，支持多个标签d2rq:classDefinitionComment 指定将作为rdfs:comment所有关联类定义的标签d2rq:dataStorage 引用d2rq:Database存储实例数据的位置 —–具有空白节点的类映射实例—– map:Topic a d2rq:ClassMap; d2rq:bNodeIdColumns &quot;Topics.TopicID&quot;; d2rq:class :Topic; d2rq:classDefinitionLabel &quot;topic&quot;@en; d2rq:classDefinitionComment &quot;A topic.&quot;@en; d2rq:dataStorage map:Database1; . d2rq:bNodeIdColumns用”TableName.ColumnName”符号表示的逗号分隔的列名列表 ,此类映射的实例将是空白节点，这些列的每个不同元组有一个不同的空白节点 d2rq:PropertyBridge属性用途，向资源添加属性example: map:PaperTitle a d2rq:PropertyBridge; d2rq:belongsToClassMap map:Paper; d2rq:property :title; d2rq:column &quot;Papers.Title&quot;; d2rq:lang &quot;en&quot;; d2rq:propertyDefinitionLabel &quot;title&quot;@en; d2rq:propertyDefinitionComment &quot;A paper&apos;s title.&quot;@en; . 一个简单的property bridge该例子将:title属性添加到所有由map:Paper类映射产生的资源d2rq:column对于具有文字值的属性，包含文字值的数据库列，列名必须在表单中给出”TableName.ColumnName”d2rq:property 连接ClassMap与桥创建的对象或者文字的RDF属性，必须为每个属性桥指定 d2rq 映射语言官方文档：http://d2rq.org/d2rq-language]]></content>
      <categories>
        <category>coding</category>
      </categories>
      <tags>
        <tag>D2RQ</tag>
        <tag>RDF</tag>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo博文图片添加测试]]></title>
    <url>%2Fhfuter7712.github.io%2F2019%2F08%2F06%2FimageTest%2F</url>
    <content type="text"><![CDATA[.PNG格式 .JPG格式 .CR2格式结果：加载失败，233，果然相机导出的raw格式确实很难搞，连adobe pr也不支持]]></content>
      <categories>
        <category>coding</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Jena推理学习（一）]]></title>
    <url>%2Fhfuter7712.github.io%2F2019%2F08%2F05%2FJenaInterface%2F</url>
    <content type="text"><![CDATA[官方文档: Jena推理子系统旨在将一系列推理引擎或者推理器插入Jena，这些引擎用于导出额外的RDF断言（RDF assertions）这些RDF断言来自某些基本RDF以及任何可选的本体信息以及与推理器相关联的公理和规则支持使用RDF和OWL语言这些语言允许从实例数据和类描述中推理出其他事实这个机制（machinery）设计的非常通用，它包括一个通用规则引擎，可用于许多RDF处理或转换任务 在RDF中，模式（schema，也称为Ontology AKA tbox）数据和实例（instance，也称为AKA abox)之间没有强烈分离(strongly)，因此任何数据无论是类相关还是实例相关，都可包含在bind或者在bindSchema中 通用推理器对于每种类型的推理器，都有一个工厂类(factory class)，其实例可以用来创建关联实例Reasoner，可以通过直接转到已知工厂类并使用theInstance()静态方法或者从全局检索来定位ReasonerRegistry工厂实例，该全局存储着由分配给推理的URI索引的工厂实例(存储实例）构建reasoners的工厂对象就是为了简化注册表服务的设计和扩展，一旦有了一个推理器实例，同一个实例可以在不同的数据集起作用并多次重复使用，而不会互相影响个人总结：定义了一个推理器实例便可以通用，多用一旦有了推理器实例，就可以将其附加到一组RDF数据上创建推理模型，可以通过将所有RDF数据放入一个模型中或分成两个组件（模式schema与实例数据instance）来完成,官方PS：一些外部reasoners可能需要硬分离，对于所有内置reasoners，分离是任意的这种分离的主要价值是 允许从一组数据中的一些推论有效的应用在几个辅助数据集中（一般是实例数据集） —–推理模型的操作—–对于大部分应用程序，只需要创建一个包含一些推理步骤的模型，使用ModelFactory方法然后运行在标准Jena Model API中所包含的语句即可，但是有时候需要获得虚拟三元组所没有的更多控制处理以及额外的推理器性能（sometimes it is necessary to gain more control over the processing or to access additional reasoner features not available as virtual triples.）为了使用推理器测试数据集的不一致性，使用InfModel.validate接口，该接口将对架构和实例数据进行全局检查，查找不一致性它包括一个简单的通过/失败标志ValidityReport.isValid()和一个特定报告列表ValidityReport.Report 接口的实例,详细说明任何检测到的不一致 RDFS推理器Jena包含一个RDFS推理器，它支持RDF核心工作组（RDF Semantics）描述的几乎所有RDFS蕴含要访问该推理器可以使用ModelFactory.createRDFSModel或者手动访问ReasonerRegistery.getRDFSReasoner() 在Jena中，可以通过将包含空白节点的图形转换为包含变量代替空白节点的等效查询来实现简单包含，这样的查询可以直接匹配文字节点，RDF API可以用于提取文字的数据类型分为三种配置—Full(完整)—实现了所有的RDFS公理和闭包规则， 除了exception of bNode entailments and datatypes (rdfD 1) ，是极其昂贵的模式，因为需要检查数据图中所有语句是否可以使用容器成员资格属性 —Default(默认)—省略了对容器成员资格属性的昂贵检查，使用“一切都是资源”以及“用作属性的所有东西都是一个”规则，该模式仍然包含所有公里规则 —Simple(简单)—省略了所有公理，实现了SubPropertyOf和subClassOf关系的传递闭包，域和范围蕴涵（the domain and range entailments）以及SubPropertyOf和subClassOf的含义 Jena RDFS实现尚未通过数据库模型进行测试和评估，Jena架构使构建此类模型变得容易，但是在没有缓存的情况下，预计性能会很差]]></content>
      <categories>
        <category>大创</category>
      </categories>
      <tags>
        <tag>Jena</tag>
        <tag>知识推理</tag>
        <tag>知识图谱</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Javascript+jQuery+API]]></title>
    <url>%2Fhfuter7712.github.io%2F2019%2F08%2F05%2FJavascript4%2F</url>
    <content type="text"><![CDATA[$(document).ready()该函数中的代码只会在页面加载的时候运行一次 API(Application Programming Interface) 应用程序接口 可以通过浏览器navigator获取我们当前所在的位置 geolocation位置的信息包括longitude和latitude样例代码如下，将会看到一个是否允许获取当前位置的提示，如果允许，输出的将是当前位置所在的经纬度 if (navigator.geolocation) { navigator.geolocation.getCurrentPosition(function(position) { $(&quot;#data&quot;).html(&quot;latitude: &quot; + position.coords.latitude + &quot;&lt;br&gt;longitude: &quot; + position.coords.longitude); }); }]]></content>
      <categories>
        <category>coding</category>
      </categories>
      <tags>
        <tag>Javascript</tag>
        <tag>jQuery</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Javascript中关于sort()函数的注意事项]]></title>
    <url>%2Fhfuter7712.github.io%2F2019%2F08%2F05%2FJSsort%2F</url>
    <content type="text"><![CDATA[JS中用于数组的sort()函数，咋一看是排序数组，但是和C中的sort()函数不同，sort（）若没有生命参数，是默认按照字符编码的顺序进行排序的，并不是按照从大到小或从小到大，如果要按照顺序排序的话，需要另外定义一个函数用于实现功能从小到大排序: function sortNumber(a,b) { return a-b; }]]></content>
      <categories>
        <category>coding</category>
      </categories>
      <tags>
        <tag>Javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Javascript中剔除数组中的假值]]></title>
    <url>%2Fhfuter7712.github.io%2F2019%2F08%2F05%2FJSArrayN%2F</url>
    <content type="text"><![CDATA[刚刚在网上做一个题目，实则感慨就是题目很简单，就是要剔除一个数组中所有假值包括false、null、0、&quot;&quot;、undefined 和 NaN打算用.filter()外加过滤check函数做的一开始写的check函数如下return !(member === false || member === null || member === 0 || member === undefined || isNaN(member));很复杂，而且还有bug就是当正常的字符串成员出现的时候也会被滤掉后来发现是isNaN()这个地方有问题，上网查阅发现只要不是数字的一律都会被这个函数判定为true刷掉这下坏了，玩意isNaN和正常字符串一起出现呢。。NaN这玩意可是连自己本身都不相等的呢后来想了想，假值，，，emmmmm…做点小修改return member;成功AC只要member是假值，return的就会是false,因此可以顺利剔除所有假值]]></content>
      <categories>
        <category>coding</category>
      </categories>
      <tags>
        <tag>Javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Javascript用正则表达式替代字符串中的标点符号]]></title>
    <url>%2Fhfuter7712.github.io%2F2019%2F08%2F05%2FJSreg%2F</url>
    <content type="text"><![CDATA[当在处理字符串的时候要对其中的标点符号进行处理时，用if==&amp;&amp;肯定是行不通的，因为太麻烦了，这时候正则表达式就派上用场了正则表达式以/开始，以/结尾[]表示匹配其中所有内容记住标点符号要用转义符号，之间用|间隔/[\-|\_|\(|\)|\+|\=|\{|\[|\]|\}|\;|\:|\&#39;|\&quot;|\,|\.|\/|\?]/gg代表全局模式，运用于所有字符串，即匹配所有符合条件的字符]]></content>
      <categories>
        <category>coding</category>
      </categories>
      <tags>
        <tag>Javascript</tag>
        <tag>正则表达式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[佳能EOS M10 刷魔灯实践]]></title>
    <url>%2Fhfuter7712.github.io%2F2019%2F08%2F03%2FCanonM10-tecdee%2F</url>
    <content type="text"><![CDATA[结果显而易见的失败了！虽然本人努力的查阅资料和尝试首先先把魔灯最新版下了（很有野心），然后查看相关文档需要佳能2.02固件，进相机一看，1.10，不行啊就去官网查阅了一下，M系列！记住这个系列固件已经升级到2.03了，作为M10，肯定是要下的啊按照操作，格式化了一张64G的存储卡将固件文件放入其中，然后，，，点击升级没反应怎么可能，M系列啊！以为是存储卡的问题，换了一张16G的存储卡，也进行了格式化没反应、、后来在晚上继续查阅，在官网M10介绍下看到了一条消息如果固件为1.10则不用继续升级what?于是临时又去官网搜了搜，最后终于发现了一个很现实的事实佳能有一个M系列的2.03固件升级，同时还有一个M10的1.10升级！也就是说M10被孤立了、、、好吧，入门中的入门机果然是没人权的也不用折腾了，233，还是等以后有钱了换机子吧，醉了]]></content>
      <categories>
        <category>photograph</category>
      </categories>
      <tags>
        <tag>摄影</tag>
        <tag>魔灯</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RDF结合Jena初步基础学习（一)]]></title>
    <url>%2Fhfuter7712.github.io%2F2019%2F08%2F03%2FRDF%2BJena%2F</url>
    <content type="text"><![CDATA[资源具有属性Jena是一个Java API，可用于创建和操作RDF图，Jena有对象类表示图形，资源，属性和文字表示资源的接口: Resource表示属性的接口: Property表示文字的接口: Literal在Jnea中，图形称为模型，由接口 Model 表示 Model model = ModelFactory.createDefaultModel();使用该方法创建基于内存的模型Resource joinSmith = model.createResource(personURI);使用该方法创建资源 “常量”类:VCARD，该类保存表示VCARD模式中所有定义的对象 joinSmith.addProperty(VCARD.FN, fullName);给资源添加属性 创建资源和添加属性还可以更紧凑的以级联样式编写: Resource joinSmith = model.createResource(personURI) .addProperty(VCARD.FN , fullName); 可定义空节点model.createResource()括号内不含参数即可定义一个空节点 RDF模型中一般一个语句包含三个部分subject:箭头出发点predicate:箭头object: 箭头目的地可称为主语，谓语和宾语主语——谓语——&gt;宾语 example: // list the statements in the Model StmtIterator iter = model.listStatements(); // print out the predicate, subject and object of each statement while (iter.hasNext()) { Statement stmt = iter.nextStatement(); // get next statement Resource subject = stmt.getSubject(); // get the subject Property predicate = stmt.getPredicate(); // get the predicate RDFNode object = stmt.getObject(); // get the object System.out.print(subject.toString()); System.out.print(&quot; &quot; + predicate.toString() + &quot; &quot;); if (object instanceof Resource) { System.out.print(object.toString()); } else { // object is a literal System.out.print(&quot; \&quot;&quot; + object.toString() + &quot;\&quot;&quot;); } System.out.println(&quot; .&quot;); } listStatements() 方法该方法返回一个StmIterator, 一种可以遍历模型中所有语句的迭代器(这里的谷歌翻译真是醉了，还好切回英文读懂了，不然简直了) nextStatement() 方法该方法从迭代器中返回当前的下一个语句使用Statement 进行一个语句的初始化Statement stmt = iter.nextStatement();在此基础上分别通过.getSubject()获取该语句的主语subject.getPredicate() 获取该语句的谓语Predicate.getObject()获取该语句的宾语Object iter.hasNext()个人理解: iter即当前迭代器，`hasNext（）是一个布尔型函数，如果迭代器当前位置之后没有语句了，就返回false,否则返回true .write(System.out)方法 将一个模型以RDF的形式写出来model.write(System.out); 要写入大文件并保留空白节点，请以N-TRUPLES格式写入model.write(System.out,&quot;N-TRIPLES&quot;); ===从文件中读取RDF===example: // create an empty model Model model = ModelFactory.createDefaultModel(); // use the FileManager to find the input file InputStream in = FileManager.get().open( inputFileName ); if (in == null) { throw new IllegalArgumentException( &quot;File: &quot; + inputFileName + &quot; not found&quot;); } // read the RDF/XML file model.read(in, null); // write it to standard out model.write(System.out); 使用.read()函数来对文件进行读取model.read(in,null);in为创建的输入流 setNsPrefix(String prefix,String URI)声明命名空间URI可以缩写成prefix(为了方便，因为有些命名空间真的太长了，每次写非常麻烦)，Jena要求prefix是一个合法的XML命名空间名称，并URI以非名称字符结尾 给定资源的URI，可以用下列方法从模型中检索资源对象Resource name = model.getResource(johnSmithURI);访问资源的属性如下Resource.getProperty(Property p); —查询模型—Model.listStatements() 列出模型中所有语句，但是不适用于数据量大的模型 Model.listStatementWithProperty(Property p,RDFNode o)将会返回一个迭代器，包含所有含有属性p，并且value是o的资源 选择器Selector selector = new SimpleSelector(subject, predicate, object);如果三个参数中任意一个为null,将相当于Sparql中的SELECT *如果三个参数都为null,则选择模型中的所有语句Selector selector = new SimpleSelector(null,VCARD.FN,null);将选择谓语是VCARD.FN的所有语句 容器 Bag是无序集合 ALT是一种旨在代表替代品的无序集合 SEQ是有序集合 创建一个Bag容器Bag smiths = model.createBag();容器接口提供一个迭代器来列出容器的内容NodeIterator iter2 = smiths.iterator();可以像上述那样用迭代器遍历 if (iter2.hasNext()) { System.out.println(&quot;The bag contains:&quot;); while (iter2.hasNext()) { System.out.println(&quot; &quot; + ((Resource) iter2.next()) .getProperty(VCARD.FN) .getString()); } } else { System.out.println(&quot;The bag is empty&quot;); } 官方教程之一: http://jena.apache.org/tutorials/rdf_api.html如何在Eclipse中配置Jena : http://jena.apache.org/tutorials/using_jena_with_eclipse.html]]></content>
      <categories>
        <category>coding</category>
      </categories>
      <tags>
        <tag>RDF</tag>
        <tag>Jena</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Sparql基础学习（四）]]></title>
    <url>%2Fhfuter7712.github.io%2F2019%2F08%2F03%2FSparqlLearn4%2F</url>
    <content type="text"><![CDATA[四种查询格式 SELECT使用该格式结果直接返回所定义变量和它们绑定的数据，和SQL一样，SELECT *用于选取所有的变量 CONSTRUCT返回由图形模板中一个指定单一的RDF图，通过在解决方案序列中获取每个查询解决方案，替换图形模板的变量，然后合成RDF图（见基础学习（一）中末尾的例子） ASKASK返回的是yes或者no，如果对应的查询有结果的话，结果输出yes如果对应的查询没有结果则返回no DESCRIBE该模式返回包含有关资源的RDF数据的单个结果RDF图该DESCRIBE表单获取解决方案中标识的每个资源以及IRI直接命名的任何资源，并通过任何可以用的信息的“描述”来组装单个RDF图，同理,DESCRIBE *是查询所有变量的缩写 数据类型 类型文字值((typed literals) xsd:integerxsd:decimalxsd:floatxsd:doublexsd:stringxsd:booleanxsd:dateTime Filter函数中的逻辑关系与运算符Filter作为一个过滤器函数也有 ||与&amp;&amp;两种运算符其中有三种对应的值,T(true),F(false)和E(error) 对应关系如下(来自官方文档) A B A || B A &amp;&amp; B T T T T T F T F F T T F F F F F T E T E E T T E F E E F E F E F E E E E bound函数 如果函数中的变量绑定到值(???)个人理解:意思应该是如果匹配中含有该类型变量，则视为绑定成功返回true,否则返回false,若匹配带有NaN或者INF类型的的被视为绑定成功example: data: @prefix foaf: &lt;http://xmlns.com/foaf/0.1/&gt; . @prefix dc: &lt;http://purl.org/dc/elements/1.1/&gt; . @prefix xsd: &lt;http://www.w3.org/2001/XMLSchema#&gt; . _:a foaf:givenName &quot;Alice&quot;. _:b foaf:givenName &quot;Bob&quot; . _:b dc:date &quot;2005-04-04T04:04:04Z&quot;^^xsd:dateTime 查询语句: PREFIX foaf: &lt;http://xmlns.com/foaf/0.1/&gt; PREFIX dc: &lt;http://purl.org/dc/elements/1.1/&gt; PREFIX xsd: &lt;http://www.w3.org/2001/XMLSchema#&gt; SELECT ?name WHERE { ?x foaf:givenName ?givenName . OPTIONAL { ?x dc:date ?date } . FILTER ( bound(?date) ) } 结果: givenName &quot;Bob&quot; 可以看出，结果仅返回了带有date值得的Bob，另外一个例子中使用的是!bound,与改例子相反，匹配的是不含date类型的匹配，因此结果为&quot;Alice&quot; isIRI 函数若果该函数中参数为一个合法IRI，那么返回true即匹配，否则不匹配（用在Filter函数中作为过滤条件) isBlank函数如果函数参数是一个空白节点，返回true，否则返回false同样用在Filter中作为过滤条件 isLiteral若函数参数是一个字符串，返回true，否则返回falseexample: _:a foaf:name &quot;Alice&quot;. _:a foaf:mbox &lt;mailto:alice@work.example&gt; . _:b foaf:name &quot;Bob&quot; . _:b foaf:mbox &quot;bob@work.example&quot; . Alice所含有的mbox是一个IRI，Bob所含有的mbox是一个字符串 str函数个人理解:就是将相应的IRI转化为字符串进行处理example:在对IRI进行筛选时这个函数相当有用regex(str(?mbox), &quot;@work.example&quot;)作用是筛选出带有”@work.example”的IRI，所以要将IRI转换为字符串处理 SPARQL官方文档：https://www.w3.org/TR/rdf-sparql-query/]]></content>
      <categories>
        <category>coding</category>
      </categories>
      <tags>
        <tag>Sparql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Javascript基础学习（三）]]></title>
    <url>%2Fhfuter7712.github.io%2F2019%2F08%2F02%2FJavascript3%2F</url>
    <content type="text"><![CDATA[用构造函数创建对象构造函数通常采用大写字母开头，以便把自己和其他普通函数区分开example: var Animal = function(){ this.legs = 4; this.heart = 1; }; this指向被该构造函数创造出来的对象 new 关键字 掉用构造函数构造一个实例的方法var myCar = new Car() 构造函数可添加参数example: var Car = function(wheels,seats,engines){ this.wheels=wheels; this.seats=seats; this.engines=engines; }; 在调用时传入参数即可var myCar = new Car(4,2,5); 在设置构造函数时，在函数体中用var代替this声明变量即可声明私有变量与私有方法 map方法map方法可以方便的迭代数组会迭代数组中的每一个元素，并根据回调函数来处理每一个元素，最后返回一个新数组（不会改变原始数组）example:让数组ArrayA每一项+3,并存储到newArray中 var newArray = ArrayA.map(function(val){ return val+3; }; reduce方法数组方法reduce用来迭代一个数组，并将其累积到一个值中第一个参数是一个累加器回调函数第二个参数是一个可选的参数，比用来设置累加器的初始值example:让ArrayA数组中所有元素都累加: var sum; sum = ArrayA.reduce(function(pre,cur){ return pre + cur; },sum); filter函数话说在学sparql的时候也有这玩意呢，果真过滤器嘛该函数传入一个回调函数，该回调函数会携带一个参数，参数为当前迭代的项所返回表达式中若数组元素使该表达式为真时加入新数组，为假时则不添加example: var newArray = ArrayA.filter(function(val){ return val&lt;6; }); 上述代码将ArrayA数组中小于6的元素传入newArray数组中 reverse方法reverse方法是对一个数组进行翻转，传入一个新的数组中var newArray = ArrayA.reverse() concat方法该方法可以用来把两个数组的内容合并到一个数组中example:连接secondArray到firstArray后面var newArray = firstArray.concat(secondArray); split方法可以按照指定分隔符将字符串分为数组example:将一个字符串按照字符s分割成数组var newArray=ArrayA.split(&quot;s&quot;); join方法可以使用该方法把数组转换成字符串，里面的每一个元素用指定的连接符连接example: ArrayA=[&quot;I&quot;,&quot;Jerry&quot;,&quot;Tom&quot;]; var stringA = ArrayA.split(&quot; and &quot;); //结果stringA=“I and Jerry and Tom&quot;]]></content>
      <categories>
        <category>coding</category>
      </categories>
      <tags>
        <tag>Javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Sparql基础学习(三)]]></title>
    <url>%2Fhfuter7712.github.io%2F2019%2F08%2F02%2FSparqlLearn3%2F</url>
    <content type="text"><![CDATA[Filters的作用域FILETER是对其出现的整个组的限制，因此只要大括号内有FILTER，解决方案都是相同的 Basic Garph Patterns Basic Graph Patterns,where a set of triple patterns must match example: { ?x foaf:name ?name . ?x foaf:mbox ?mbox . } 是一组基本图形模式，由两个三重模式组成 { ?x foaf:name ?name . FILTER regex(?name, &quot;Smith&quot;) ?x foaf:mbox ?mbox . } 在上述基础上添加了FILTER 包含可选(OPTIONAL关键字)语法如下:{OPTIONAL{pattern}}个人理解:由于不是所有的RDF图中都具有完整的结构，有些RDF会缺乏部分属性，因此OPTIONAL的作用就是在OPTIONAL的括号内的属性如果匹配，即选上，如果可选部分不匹配，但是其他基础属性都匹配的话，也会认定为是匹配的就比方说上大学，有很多人是有加分项的，有加分项的人可以被录取并标明，但是没有加分项的人也可以被录取，这就是OPTIONAL的功能 example:数据: @prefix foaf: &lt;http://xmlns.com/foaf/0.1/&gt; . @prefix rdf: &lt;http://www.w3.org/1999/02/22-rdf-syntax-ns#&gt; . _:a rdf:type foaf:Person . _:a foaf:name &quot;Alice&quot; . _:a foaf:mbox &lt;mailto:alice@example.com&gt; . _:a foaf:mbox &lt;mailto:alice@work.example&gt; . _:b rdf:type foaf:Person . _:b foaf:name &quot;Bob&quot; . 查询语句: PREFIX foaf: &lt;http://xmlns.com/foaf/0.1/&gt; SELECT ?name ?mbox WHERE { ?x foaf:name ?name . OPTIONAL { ?x foaf:mbox ?mbox } } 结果: name mbox &quot;Alice&quot; &lt;mailto:alice@example.com&gt; &quot;Alice&quot; &lt;mailto:alice@work.example&gt; &quot;Bob&quot; 可见name为Bob的这项匹配即使mbox为空白（即在mbox方面不匹配)也可以在最终被认定为匹配 UNION关键字个人理解：用UNION链接的模式中满足任意一个即可匹配example:数据: @prefix dc10: &lt;http://purl.org/dc/elements/1.0/&gt; . @prefix dc11: &lt;http://purl.org/dc/elements/1.1/&gt; . _:a dc10:title &quot;SPARQL Query Language Tutorial&quot; . _:a dc10:creator &quot;Alice&quot; . _:b dc11:title &quot;SPARQL Protocol Tutorial&quot; . _:b dc11:creator &quot;Bob&quot; . _:c dc10:title &quot;SPARQL&quot; . _:c dc11:title &quot;SPARQL (updated)&quot; . 查询语句 PREFIX dc10: &lt;http://purl.org/dc/elements/1.0/&gt; PREFIX dc11: &lt;http://purl.org/dc/elements/1.1/&gt; SELECT ?title WHERE { { ?book dc10:title ?title } UNION { ?book dc11:title ?title } } 结果 title &quot;SPARQL Protocol Tutorial&quot; &quot;SPARQL&quot; &quot;SPARQL (updated)&quot; &quot;SPARQL Query Language Tutorial&quot; 可以看出，凡是满足三重模式第三项中为”title”的都成功匹配了二而第二项可以为dc10或者dc11，这两个也是UNION连接的两个条件 FROM关键字SPARQL查询可以使用FROM和FROM NAMED字句来指定要用于匹配的数据集，以描述RDF数据集 由许多FROM和FROM NAMED 自己产生的数据集是: 一个默认图谱(graph)，由FROM字句中引用的图谱的RDF合并形成 一组(IRI,图谱)对，每个FROM NAMED字句一个 每个FROM语句都包含一个IRIexample: PREFIX foaf: &lt;http://xmlns.com/foaf/0.1/&gt; SELECT ?name FROM &lt;http://example.org/foaf/aliceFoaf&gt; WHERE { ?x foaf:name ?name } 如果一个查询包含多个FROM，那么最终的默认图谱是这些FROM所引用所有图谱的合并 使用FROM NAMED来匹配RDF数据集中的命名图 GRAPH关键字GRAPH关键字用于将图形模式与数据集中的每个命名图形相匹配，并形成解决方案可将其后面的变量绑定到匹配的图谱的IRIexample: WHERE { GRAPH?src {?x foaf：mbox &lt;mailto：bob@work.example&gt;. ?x foaf：nick?bobNick } } 最终src匹配到的都是类似&lt;http://example.org/foaf/aliceFoaf&gt;的IRI同时GRAPH还可以限制应用于特定图谱的匹配 重复的解决方案如果在查询语句中没有DISTINCT或者REDUCED关键字，重复的解决方案将会被保留，也就是说不同的匹配可能会相同DISTINCT该关键字用法如下SELECT DISTINCT ?name WHERE{ ?x foaf:name ?name }该方法将会消除所有重复的解决方案REDUCED该关键字用法如下SELECT REDUCED ?name WHERE { ?x foaf:name ?name }顾名思义，该方法将会减少重复的次数，范围从1~未使用上述两个关键字之间不等也就是说仍然可能不变，比如重复的匹配有4个，那么使用REDUCED后可能就剩1个，2个，3个甚至仍然还是四个 OFFSET关键字该关键字定义在特定的偏移数量后的方法，顾名思义，OFFSET即偏移，OFFSET 0没有实际作用 LIMIT关键字这个关键字想必也不难理解，就是限制结果显示匹配的数量，假设有10个满足条件匹配成功，使用LIMIT 5使得最终结果只显示5个匹配 SPARQL官方教程（英文）：https://www.w3.org/TR/rdf-sparql-query/]]></content>
      <categories>
        <category>coding</category>
      </categories>
      <tags>
        <tag>Sparql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS对象数组操作属性小雷区]]></title>
    <url>%2Fhfuter7712.github.io%2F2019%2F08%2F01%2FJSwrong1%2F</url>
    <content type="text"><![CDATA[在网上学习实践的时候遇到了一个bug，de了好长时间，后来终于de出来了内容是这样的，首先有个存储着通讯录的对象数组如下 var contacts = [ { &quot;firstName&quot;: &quot;Akira&quot;, &quot;lastName&quot;: &quot;Laine&quot;, &quot;number&quot;: &quot;0543236543&quot;, &quot;likes&quot;: [&quot;Pizza&quot;, &quot;Coding&quot;, &quot;Brownie Points&quot;] }, { &quot;firstName&quot;: &quot;Harry&quot;, &quot;lastName&quot;: &quot;Potter&quot;, &quot;number&quot;: &quot;0994372684&quot;, &quot;likes&quot;: [&quot;Hogwarts&quot;, &quot;Magic&quot;, &quot;Hagrid&quot;] }, { &quot;firstName&quot;: &quot;Sherlock&quot;, &quot;lastName&quot;: &quot;Holmes&quot;, &quot;number&quot;: &quot;0487345643&quot;, &quot;likes&quot;: [&quot;Intriguing Cases&quot;, &quot;Violin&quot;] }, { &quot;firstName&quot;: &quot;Kristian&quot;, &quot;lastName&quot;: &quot;Vos&quot;, &quot;number&quot;: &quot;unknown&quot;, &quot;likes&quot;: [&quot;Javascript&quot;, &quot;Gaming&quot;, &quot;Foxes&quot;] } ]; 在函数中定义了一个函数用于操作，如下 function lookUp(firstName, prop){ // 请把你的代码写在这条注释以下 var firstE=0; var propE=0; var index=0; for(var i=0;i&lt;contacts.length;i++) { if(contacts[i].firstName==firstName){ firstE=1; index=i; break; } } if(contacts[index].hasOwnProperty(prop)) propE=1; if(propE&amp;&amp;firstE) return contacts[index][prop]; else if(!firstE) return &quot;No such contact&quot;; else if(!propE) return &quot;No such property&quot;; // 请把你的代码写在这条注释以上 } 具体功能就是先查询对象数组中有没有firstName属性为firstName(参数)的成员找到之后再查询这个对象里面有没有一个叫做prop(参数)的属性如果两者同时满足，返回该对应成员对应属性的内容，否则进行相关说明 注意这条语句return contacts[index][prop];一开始我不是这么写的，一开始我是这样写的return contacts[index].prop;导致符合两个条件但是最终输出却为空白在检查了前面一系列节点发现都没有问题，检查到这条语句的时候，我尝试把.prop换成.firstName，是有正常输出的，因此本人断定一定是在这条语句上出了问题后来决定换一种表达形式，由.换到[]形式，输出果然正常了在这里要说明一下，引入的两个参数都是字符串类型，比如”adobe” ,本人觉得应该是.prop的时候相当于是.&quot;属性名称&quot;,而不是.属性名称,多了一对双引号导致了这次bug的产生，因此本人建议，以后属性的类型是字符串的，最好用中括号对对象属性进行操作，避免不必要的bug]]></content>
      <categories>
        <category>coding</category>
      </categories>
      <tags>
        <tag>Javascript</tag>
        <tag>误区</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Javascript基础学习+JSON]]></title>
    <url>%2Fhfuter7712.github.io%2F2019%2F08%2F01%2FJavascript2%2F</url>
    <content type="text"><![CDATA[JSON(JavaScript Object Notation) 使用Javascript对象的格式来存储数据允许数据结构是字符串，数字，布尔值和对象的任意组合(string、number、boolean与Object的任意组合)JSON对象可以嵌套对象和数组,用中括号操作符同样可以访问嵌套数组 产生指定范围内的随机整数(方法来自freecodecamp)Math.random() 产生随机小数Math.floor() 在目前的小数向下取证产生0~19内的整数Math.floor(Math.random()*20)产生a~b内的整数Math.floor(Math.random() * (b - a + 1)) + a 正则表达式是一种根据某种匹配方式来寻找strings中的某些单词在字符串中寻找单词the，可使用下列正则表达式 文本 /the/gi/是正则表达式的头部第二个/时候正则表达式的尾部g代表着global,意味着返回所有的匹配而不仅仅是第一个i代表忽略大小写 数字 数字选择器\d用法:/\d/g在选择器后加上一个加号/\d+/g允许这个正则表达式匹配一个或更多的数字 空白 空白字符有&quot; &quot;（空格符）,\r（回车符）,\n（换行符）,\t（制表符）,\f（换页符）空白选择器\s空白正则表达式类似于/\s+/g 有趣的是，以上两个选择器将小写转化为大写的话，就会匹配与原来相反的字符比如\S是匹配任何非空白字符]]></content>
      <categories>
        <category>coding</category>
      </categories>
      <tags>
        <tag>Javascript</tag>
        <tag>JSON</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Javascript基础复习+学习（一）]]></title>
    <url>%2Fhfuter7712.github.io%2F2019%2F08%2F01%2FJavascript1%2F</url>
    <content type="text"><![CDATA[终于开始复习JS了，哈哈，最早开始的时候JS学到一半没学完，这次一定要肝完 注释 javascript的注释和C语言的注释相同//这是一个注释 /*这是一段注释 没错，就是一段*/ 数据类型 JS提供七种不同的数据类型 undefined null boolean string symbol number object 当你对一个值为undefined的变量进行运算操作时，算出的结果将会是NaN当用一个没有定义的变量来做字符串连接操作时，他会如实的输出undefined 驼峰命名法变量名的第一个单词的首写字母小写，后面的单词的第一个字母大写 取余符号%使用%运算符来对一个数进行取余example: 5 % 2 = 1 在字符串中使用单引号和双引号可以使用转义字符串如要使用单引号，在前面加上反斜杠\&#39;双引号同理 \&quot;但是如果字符串内容中的符号与字符串起始终止所修饰的符号不同，可以不用比如字符串用双引号表示，内容包含单引号，可以不用转义 在JS中，字符串的值是不可变的，这意味着一旦字符串被创建就不能被改变但是可以通过重新赋值的形式来整体改变字符串 var Str1=&quot;3erf&quot;; Str1=&quot;34tc&quot;; 仍然是可以的 JS中的数组用法可以用数组名.push()来往数组中添加内容可以使用数组名.pop()来移除数组中的最后一条使用数组名.shift()来移除数组中的第一项同时也可以使用数组名.unshift()来在数组头部添加元素 使用函数console.log()来往开发控制台上打印内容 一个程序中可能有相同名称的局部变量和全局变量，在这种情况下局部变量将会优先于全局变量 严格相等运算符 ===与==不同的是，它会同时比较元素的值和数据类型因此如果比较的两个对象类型不同，那就直接返回false了 严格不相等运算符 !==与严格相等运算符类似，不仅比较元素的值，还要看他们的数据类型 JS Objects对象和数组相似，数组是通过索引来访问和修改数据，对象是通过属性来访问和修改数据的example: var Person{ &quot;first name&quot;: &quot;Ken&quot;, &quot;last name&quot;: &quot;Smith&quot;, &quot;weight&quot;: 170; &quot;pets&quot;:[&quot;cats&quot;,&quot;dogs&quot;] }; 可以用 . 即点操作符来操作对象属性也可以用中括号[]example(以上面的Person为例子):Person[&quot;first name&quot;]中括号的另外一个作用是用变量来访问一个属性example(来自freecodecamp): var someProp = &quot;propName&quot;; var myObj = { propName: &quot;Some Value&quot; } myObj[someProp]; // &quot;Some Value&quot; 最终myObj[someProp]返回的值是”Some value” 可以使用delete关键字来删除一个Object中特定的属性example: delete ourDog.bark 使用hasOwnProperty(propname)函数来检查对象是否有该属性]]></content>
      <categories>
        <category>coding</category>
      </categories>
      <tags>
        <tag>Javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[语法糖(Syntactic-Suger)]]></title>
    <url>%2Fhfuter7712.github.io%2F2019%2F07%2F31%2FSyntacticSuger%2F</url>
    <content type="text"><![CDATA[今天在学习某查询语言的时候在官方文档里面发现有一个词组重复出现，叫做 Syntactic suger,点击谷歌翻译后，翻译成语法糖。。。一开始我肯定是不相信的，以为是谷歌翻译出的问题，还在想怎么谷歌翻译也会出现机翻，后来多次出现我实在忍不住就去网上进行了查询发现百科的词条大标题写的就是“语法糖”看来是自己的无知冤枉了谷歌，233在浏览了相关词条后，大致了解了这是什么玩意语法糖，也称为糖衣语法，到这边我大概明白了，什么叫做语法糖，糖衣很多人小时候都可能吃过，表面上尝起来可能是酸甜可口的，但实际上是药。有些程序的语法过于复杂，如果按照原来那样写的话，语法上是没有什么错误，但是会使得程序可读性大大降低，别说普通人，甚至部分程序员也很难理解，需要很长时间来理解，这时，糖衣语法就出现了baidu:通常来说使用语法糖能够增加程序的可读性，从而减少代码出错的机会这个术语由英国计算机科学家彼得·约翰·兰达（Peter J. Landin）发明，感谢前辈example:C语言中用 a[i]表示 *(a+i) ,用a[i][j] 表示 *(*(a+i)+j)个人总结:糖衣语法让繁杂的程序语法变得浅显易懂]]></content>
      <categories>
        <category>coding</category>
      </categories>
      <tags>
        <tag>术语</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Sparql查询语言学习（二）]]></title>
    <url>%2Fhfuter7712.github.io%2F2019%2F07%2F31%2FSparqlLearn2%2F</url>
    <content type="text"><![CDATA[FILTER函数个人理解：当FILTER括号中的表达式为true时匹配，否则不匹配(相当于只有满足FILTER括号中的内容才能匹配)regex 用来测试RDF文字，仅匹配没有语言标签（见上一篇博文中的language tag)的普通文字，regex可以使用str函数来匹配其他文字的词法形式example:FILTER regex(&quot;title,&quot;^SPARQL&quot;)正则表达式匹配可以使用”i”标志（不区分大小写）example:FILTER regex(?title,&quot;web&quot;,&quot;i&quot;) 用来匹配数值相关的表达式example:如果要匹配的内容的类型是数字,可以有以下表达式FILTER(?price &lt; 23.4)结果只会匹配那些价格低于23.4的内容 除了数字类型(numeric types)，SPARQL还支持xsd:string,xsd:boolean,xsd:dateTime类型 Sparql语法 变量 查询语句中的变量以$或者?开头，这两个符号并不是变量的一部分，而是用来表示这是一个变量,在查询中，$abc和?abc标识相同的变量 空节点 空白节点由标签形式表示，例如_:abc与缩写形式[]在查询语法中，仅在唯一一个位置使用的可以被视作[]相同的空白节点标签不能在同一查询中的两个不同的基本图形模式中使用example:两种形式 [: p&quot;v&quot;]. 与 []: p&quot;v&quot;. 分配了唯一一个空白节点标签假设分配的节点标签是b57,那就相当于这样:_: b57: p&quot;v&quot;.该分配的空白节点可以作为其他三重模式的主体或对象,作为主题[: p&quot;v&quot;]: q&quot;w&quot;.相当于两个三元组 _: b57: p&quot;v&quot;. 与 _: b57: q&quot;w&quot;.作为对象: x: q [: p&quot;v&quot;].相当于两个三元组: x: q_: b57.与 _: b57: p&quot;v&quot; 三重模式的写法 可以编写具有共同主题的三重模式，使得目标变量只用声明一次可以运用到多个三重模式,使用;来分隔example: ?x foaf:name ?name ; foaf:mbox ?mbox. 等同于 ?x foaf:name ?name . ?x foaf:mbox ?mbox . 如果三重模式享有多个项目变量或谓语，之间,分隔example:?x foaf:name ?name ; foaf:nick &quot;Alice&quot;, &quot;Alice_&quot; .等同于 ?x foaf:name ?name . ?x foaf:nick &quot;Alice&quot; . ?x foaf:nick &quot;Alice_&quot; . End at 5 Graph Patterns,to be continued…]]></content>
      <categories>
        <category>coding</category>
      </categories>
      <tags>
        <tag>RDF</tag>
        <tag>Sparql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Sparql查询语言基础学习（一）]]></title>
    <url>%2Fhfuter7712.github.io%2F2019%2F07%2F31%2FSparqlLearn%2F</url>
    <content type="text"><![CDATA[全程官方文档英文阅读理解。。 （有部分谷歌翻译辅助，不过大部分还是阅读理解，因为谷歌翻译的虽然很好，但是有些也会脱离本意）标题写着 “SPARQL Query Language for RDF”想必也是针对RDF设计的一种查询语言了 大多数形式的SPARQL查询包含一族成为基本图形模式的三重模式(triple patterns 编写一条简单的查询语言Data:&lt;http://example.org/book/book1&gt; &lt;http://purl.org/dc/elements/1.1/title&gt; &quot;SPARQL Tutorial&quot; . 查询语句: SELECT ?title WHERE { &lt;http://example.org/book/book1&gt; &lt;http://purl.org/dc/elements/1.1/title&gt; ?title . } 语句由两部分组成，一个是SELECT 部分，标识要在查询结果中进行显示的变量(在查询结果中将以第一行的形式出现),也就是说 ?title是一个变量另外一个是WHERE部分，提供与数据图表匹配的基本图形模式(basic grapg pattern) 多个匹配根据WHERE部分的基本图形部分，匹配的结果可能是0个，1个或者多个 匹配RDF文本(literals)在Turtle中以下RDF文本&quot;cat&quot;@en意味着有着 词汇形式(lexical form):”cat”以及语言(language):”en” (语言标签language tags) 以下RDF文本&quot;42&quot;^^xsd:integer&quot;是一个http://www.w3.org/2001/XMLSchema#integer;类型的文本 以下RDF文本&quot;abc&quot;^^dt:specialDatatype&quot;是一个http://example.org/datatype#specialDatatype.类型的文本 根据语言标签匹配文本若要匹配&quot;cat&quot;@en,执行下列查询语句将没有结果SELECT ?v WHERE {?v ?p &quot;cat&quot;}因为”cat”和”cat”@en在RDF文本层面并不相同，因此无法匹配为此有另外一种解决方案`SELECT ?v WHERE {?v ?p “cat”@en}也就是将语言标签也添加上去进行匹配，即可获得结果 使用数字类型来匹配文本匹配&quot;42&quot;^^xsd:integer&quot;可使用以下查询语句SELECT ?v WHERE {?v ?p 42} 匹配具有任意数字类型的文本SELECT ?v WHERE{?v ?p &quot;abc&quot;^^&lt;http://example.org/datatype#specialDatatype&gt;}词法形式和数据类型都匹配，不管数据类型是什么（任意数据类型），都可以匹配成功 查询结果中可包含空白节点， 空白节点标签的范围限定为结果集 SPARQL具有多种查询形式有SELECT查询形式,返回变量绑定也有CONSTRUUCT查询形式,返回RDF图 —-CONSTRUCT查询形式—- data: @prefix org: &lt;http://example.com/ns#&gt; . _:a org:employeeName &quot;Alice&quot; . _:a org:employeeId 12345 . _:b org:employeeName &quot;Bob&quot; . _:b org:employeeId 67890 . 查询语句: PREFIX foaf: &lt;http://xmlns.com/foaf/0.1/&gt; PREFIX org: &lt;http://example.com/ns#&gt; CONSTRUCT { ?x foaf:name ?name } WHERE { ?x org:employeeName ?name } result: @prefix org: &lt;http://example.com/ns#&gt; . _:x foaf:name &quot;Alice&quot; . _:y foaf:name &quot;Bob&quot; . ORDER BY 关键字该ORDER BY字句之后是一系列顺序比较器，有表达式和可选的顺序修饰符组成，每个排序比较器是升序(由ASC()修饰),降序(由DESC()修饰) SPARQL未定义所有可能的RDF术语的总排序example: PREFIX foaf: &lt;http://xmlns.com/foaf/0.1/&gt; SELECT ?name WHERE { ?x foaf:name ?name } ORDER BY ?name]]></content>
      <categories>
        <category>coding</category>
      </categories>
      <tags>
        <tag>RDF</tag>
        <tag>Sparql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RDF基础学习]]></title>
    <url>%2Fhfuter7712.github.io%2F2019%2F07%2F31%2FRDFLearn%2F</url>
    <content type="text"><![CDATA[资源描述框架RDF是用于描述网络资源的W3C标准（网页的标题，作者，修改日期，内容和版权信息）RDF使用XML编写，被RDF使用的XML语言被称为RDF/XMLRDF被设计为可被计算机阅读和理解RDF语言是W3C语义网活动的组成部分 RDF使用Web标识符（URIs)来标识资源,使用属性值来描述资源example: &lt;?xml version=&quot;1.0&quot;?&gt; &lt;RDF&gt; &lt;Description about=&quot;https://www.runoob.com//rdf&quot;&gt; &lt;author&gt;Jan Egil Refsnes&lt;/author&gt; &lt;homepage&gt;https://www.runoob.com/&lt;/homepage&gt; &lt;/Description&gt; &lt;/RDF&gt; RDF陈述资源，属性和属性值的组合可以形成一个陈述（分别被称为陈述的主体，谓语和客体）example(来源于菜鸟教程):陈述：&quot;The author of https://www.runoob.com//rdf is David.&quot;陈述的主体是：https://www.runoob.com//rdf谓语是：author客体是：David rdf:RDF 元素&lt;rdf:RDF&gt;是RDF文档的根元素，它把XML文档定义为一个RDF文档，也包含了对RDF命名空间的引用&lt;rdf:RDF xmlns:rdf=&quot;http://www.w3.org/1999/02/22-rdf-syntax-ns#&quot;&gt; rdf:Description 元素该元素可通过about属性标识一个资源可包含描述资源的那些元素 RDF容器 rdf:Bag 元素&lt;rdf:Bag&gt;元素用于描述一个规定为无序的值的列表，可包含重复的值example: &lt;rdf:Bag&gt; &lt;rdf:li&gt;John&lt;/rdf:li&gt; &lt;rdf:li&gt;Paul&lt;/rdf:li&gt; &lt;rdf:li&gt;George&lt;/rdf:li&gt; &lt;rdf:li&gt;Ringo&lt;/rdf:li&gt; &lt;/rdf:Bag&gt; rdf:Seq 元素&lt;rdf:Seq&gt;元素用于描述一个规定为有序的列表（比如一个字母顺序的排序），可包含重复的值 rdf:Alt 元素&lt;rdf:Alt&gt;元素用于一个可替换的值得列表(用户仅可选择这些值得其中之一) RDF集合rdf:parseType=&quot;Collection&quot;RDF集合用于描述仅包含制定成员的组 RDF都柏林核心表:https://www.runoob.com/rdf/rdf-dublin.htmlRDF参考手册: https://www.runoob.com/rdf/rdf-reference.htmlRDF在线验证器:http://www.w3.org/RDF/Validator/]]></content>
      <categories>
        <category>coding</category>
      </categories>
      <tags>
        <tag>RDF</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[完成的第一个HTML+css+Bootstrap实践]]></title>
    <url>%2Fhfuter7712.github.io%2F2019%2F07%2F30%2FfirstHTML%2BCSS%20project%2F</url>
    <content type="text"><![CDATA[在某网站上学习前端之后按照一个界面（单单看着界面一个个元素敲出来的界面）搞出来的第一个实践作品介绍的是我最佩服的图灵先辈（一说到图灵就想到那部卷福演的电影，泪目）实践中的部分笔记与收获: &lt;hr&gt;可以在界面中定义一条水平实线，可以用于页面的分割 字体的粗细可以用font-weight来定义，400px相当于font-style的normal,700px相当于bold 此次作品中运用到了Bootstrap的两个类，一个是让图片自动适应界面的img-responsive,还有一个就是让文本居中的text-center感受:第一次实践，虽说整体来讲没有什么难度，但是也是本人第一次在页面上进行实践，对照着模板网页，没有查看源代码的情况下用HTML和css一个个尝试和调整，也是一次相当宝贵的实践了 实践工具: codepen作品网址: https://codepen.io/hfuter7712/pen/pMeXOz]]></content>
      <categories>
        <category>coding</category>
      </categories>
      <tags>
        <tag>HTML</tag>
        <tag>Bootstrap</tag>
        <tag>css</tag>
        <tag>作品集</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTML基础复习(三)+结合jQuery]]></title>
    <url>%2Fhfuter7712.github.io%2F2019%2F07%2F30%2FHTML%20combine%20with%20jQuery%2F</url>
    <content type="text"><![CDATA[script元素 内含JavaScript语句，浏览器会执行script里面的所有语句，包括jQuery jQuery所有jQuery方法都是由$开始的,通常称为美元符号或者简称为bling 使用jQuery的 .address() 方法，就可以给元素添加class了 使用jQuery的.removeClass()方法去掉元素上的class了 使用.css()可以改变元素的CSS样式example: $(&quot;#target&quot;).css(&quot;color&quot;,&quot;blue&quot;); 使用.prop()来调整元素的属性example: $(&quot;button&quot;).prop(&quot;disabled&quot;,true); 使用.remove() 来移除HTML元素 使用appendTo() 方法可以把选中的元素加到其他元素中example:假设id为one的元素在id为first的区块中，有另外一个区块id为second要想把该元素移动到区块second中,可以这么操作$(&quot;#one&quot;).appendTo(&quot;#second&quot;); 使用clone()可以拷贝元素假设id为one的元素在id为first的区块中，有另外一个区块id为second要想把该元素复制到区块second中，可以这么操作$(&quot;#one&quot;).clone().appendTo(&quot;#second&quot;);可以这么理解,移动元素就是剪切，拷贝元素就是复制 使用parent()可以访问当前元素的父元素example:一个id为first的h2元素的父元素是div，可以通过以下代码让div区块的背景颜色变蓝$(&quot;first&quot;).parent().css(&quot;background-color&quot;,&quot;blue&quot;); 使用children()可以访问当前元素的子元素 使用$(&quot;button&quot;)来选中按钮,使用$(&quot;.well&quot;)来获取所有class为well的对象，使用$(&quot;#fist&quot;)来获取所有id为first的对象 部分classanimated bounce 所应用部分有弹跳效果animated shake 所应用部分有摇摆效果 在线编辑器:CodePen程序员的Read-Search-Ask大法，加油!]]></content>
      <categories>
        <category>coding</category>
      </categories>
      <tags>
        <tag>HTML</tag>
        <tag>css</tag>
        <tag>Javascript</tag>
        <tag>jQuery</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTML基础复习+Bootstrap+Font Awesome图标库]]></title>
    <url>%2Fhfuter7712.github.io%2F2019%2F07%2F30%2FHTMLReview%2Bbootstrap%2F</url>
    <content type="text"><![CDATA[Bootstrap将会根据你的屏幕大小来调整HTML元素的大小–强调响应式概念使用Bootstrap需要添加下列代码 &lt;link rel=&quot;stylesheet&quot; href=&quot;//cdn.bootcss.com/bootstrap/3.3.1/css/bootstrap.min.css&quot;/&gt; img-responsive类 当导入一张图片时，给图片添加该类，这样图片的宽度就能完美的适配页面宽度了&lt;img src=&quot;&quot; class=&quot;img-responsive&quot;&gt; text-center类 运用于文本，可以将文本居中&lt;h2 class=&quot;text-center&quot;&gt;title&lt;/h2&gt; btn类 是Bootstrap的按钮风格&lt;button class=&quot;btn&quot;&gt;press&lt;/button&gt; btn-block类 使按钮成为块级元素，按钮将会伸展并填满页面整个水平空间，任何在它之下的元素都会跟着浮动到该区块的下一行（注:该属性仍需要有 btn 属性) btn-primary类 使按钮呈现深蓝色，更加美观，是主要操作按钮的颜色（注:该属性仍需要有 btn 与btn-block属性) btn-info类 使按钮呈现浅蓝色，更加美观，是用户可能采取操作按钮的颜色 btn-danger类 使按钮呈现红色，通常用于一些“破坏性”的操作，比如删除图片 well类 它的作用视为设定的列创造出一种视觉上的深度感 Font Awesome图标库 是一个非常方便的图标库，这些图标都是矢量图形，被保存在.svg的文件格式中可以添加如下代码来使用该库 &lt;link rel=&quot;stylesheet&quot; href=&quot;//cdn.bootcss.com/font-awesome/4.2.0/css/font-awesome.min.css&quot;/&gt; i元素起初一般是让它的元素变成斜体，现在一般用来指代图标,用它来实现图标库的使用&lt;i class=&quot;fa fa-info-circle&gt;&lt;/i&gt;fa-thumbs-up 一个大拇指形状的图标fa-info-circle 一个圆圈里面带一个字母i，代表informationfa-trash 一个垃圾桶的标志fa-paper-plane 一个纸飞机的标志]]></content>
      <categories>
        <category>coding</category>
      </categories>
      <tags>
        <tag>HTML</tag>
        <tag>Bootstrap</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTML基础复习（二）]]></title>
    <url>%2Fhfuter7712.github.io%2F2019%2F07%2F29%2FHTMLReview2%2F</url>
    <content type="text"><![CDATA[marign:外边距如果一个元素的margin为负值，元素将会变大 border:边框padding:内边距可以根据padding-top,padding-right,padding-left,padding-bottom四个属性来控制上下左右四个内边距的属性margin同理如果按照如下格式padding: 10px 20px 10px 20px按照顺时针方式排列依次是顶部，右侧，底部，左侧（上右下左） 关于class的优先权问题 在HTML中，class=”类A 类B 类C” 排序是无所谓的但是在style元素中，class的声明顺序却非常重要，第二个声明总是比第一个具有优先权但是有一点很重要：id属性总是具有更高的优先权更重要的一点：行内样式可以覆盖id（优先权更大）example:1234567891011121314151617&lt;style&gt; body &#123; background-color: black; font-family: Monospace; color: green; &#125; #orange-text &#123; color: orange; &#125; .pink-text &#123; color: pink; &#125; .blue-text &#123; color: blue; &#125;&lt;/style&gt;&lt;h1 id=&quot;orange-text&quot; class=&quot;pink-text blue-text&quot; style=&quot;color:white&quot;&gt;Hello World!&lt;/h1&gt; 最终文本显示为白色 by the way,还有最强大的一种方法，在某些元素的属性后面加上!important可以使得该属性覆盖其他任何相同的属性 用十六进制表示颜色说到颜色，颜色在CSS中还可以用十六进制表示，格式是#XXXXXX例如#000000是黑色0是hex code中最小的一个，F是hex code中最大的一个#000000白色#FFFFFF黑色#111111 深灰色不过也可以用三位数来表示，比如#F00它等同于#FF0000 用rgb值表示rgb(0,0,0)取值范围从0~255]]></content>
      <categories>
        <category>coding</category>
      </categories>
      <tags>
        <tag>HTML</tag>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于hexo博客以及markdown的一些坑]]></title>
    <url>%2Fhfuter7712.github.io%2F2019%2F07%2F29%2Fhexo2%2F</url>
    <content type="text"><![CDATA[今天在搞博客的时候又踩了一些markdown的坑，不得不说emmmm..首先还是关于代码块的问题在上次的基础上，如果你要在一个文档中插入多个代码块 记住将代码行的第一行文本backspace直到和前三个引号连在一块，敲一次空格键，然后回车即可(2019-7-30更新) 还有一个就是12文本- 并不能使这个文本成为一个帅气的大标题，即使markdown里面是这样显示的，在博客上显示为文本- …还有一个（这都什么鬼）markdown中的大标题h1也就是#文本#在博客上并没有效果 不知道是本人hexo的问题还是就是这个样子，总之markdown预览器里的东西跟博客上呈现的样子真的有很多差别]]></content>
      <categories>
        <category>coding</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>markdown</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTML基础复习(一）]]></title>
    <url>%2Fhfuter7712.github.io%2F2019%2F07%2F29%2FHTMLReview%2F</url>
    <content type="text"><![CDATA[标题分6个等级，从&lt;h1&gt;到&lt;h6&gt;&lt;h1&gt;这是一个一级标题&lt;h1&gt;如何让你的标题变红&lt;h1 style=&quot;color:red&quot;&gt;title&lt;/h1&gt;即使用style属性中的color，这是style的内联样式如果需要配置的属性过多，可以使用&lt;style&gt;结合css 1234&lt;style&gt; 选择器&#123;属性名称:属性值;&#125;example: h2&#123;color:red;&#125;&lt;/style&gt; 注：一定要在属性值的后面加上分号 类选择器12345&lt;style&gt; .类名&#123; &#125;&lt;/style&gt;&lt;h2 class=&quot;类名&quot;&gt;title2&lt;/h2&gt; class=”类A 类B 类C…”可以应用多个类，但是必须用空格隔开 改变文章的字体大小可以用font-size属性改变文章的字体可以用font-family属性当某种字体不可用时，可以让它自动降级到另一种字体example: 123p&#123; font-family: Helvetica,Sans-Serif;&#125; 当Helvetica字体不可用时，字体会自动降级到San-Serif img元素img是自关闭元素，不需要结束标记&lt;img src=图片的具体地址&gt;若要设置图片宽度，可用CSS中的width属性给图片添加边框，可以用border-width,border-tstyle与border-color三个属性若想要添加圆角边框，则可以用属性border-radius,参数可以是像素，也可以是百分比alt属性：当图片因为各种原因无法加载时显示的替代文本 a元素anchor元素，可以用来连接到外部地址实现页面跳转功能,也可连接到当前页面的某部分实现内部导航功能&lt;a href=&quot;URL&quot;&gt;anchor text&lt;/a&gt;但是如果你暂时不知道要跳转到哪里的时候，可以用#代替，别名哈希符号href=&quot;#&quot;想把一张图片作为一个连接，直接将图片嵌套进a元素即可&lt;a&gt;&lt;img&gt;&lt;/img&gt;&lt;/a&gt; ul元素创意一个无序列表,包含多个li元素 1234&lt;ul&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt;&lt;/ul&gt; ol元素与无序表用法类似，在ol中嵌套多个li元素 input元素input元素是自关闭的其中初始化方框的文本为属性placeholder&lt;input type=&quot;text&quot; placeholder=&quot;预定义文本&quot;&gt;如果要设置必填，则添加上required属性即可&lt;imput type=&quot;text&quot; required&gt; button元素定义一个按钮 单选按钮(type=”radio”)用来定义单选按钮，在多个选项中只能选一个，嵌套在自己的label元素中,所有关联的单选按钮要使用相同的name属性example: 12&lt;label&gt;&lt;input type=&quot;radio&quot; name=&quot;indoor/outdoor&quot;&gt;indoor&lt;/label&gt;&lt;label&gt;&lt;input type=&quot;radio&quot; name=&quot;indoor/outdoor&quot;&gt;outdoor&lt;/label&gt; 多选按钮(type=”checkbox”)可以被多选 多选按钮和单选按钮都可以用checked属性来表明默认被选中 背景颜色可以用background-color属性来设置 设置id会对以后的jQuery有好处（小本本记下来）&lt;div id=&quot;id号&quot;&gt;在style元素中的表示方法为 123#&#123;属性; &#125;]]></content>
      <categories>
        <category>coding</category>
      </categories>
      <tags>
        <tag>HTML</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[XML命名空间学习]]></title>
    <url>%2Fhfuter7712.github.io%2F2019%2F07%2F29%2FxmlNamespace%2F</url>
    <content type="text"><![CDATA[命名空间是为了防止不同文档使用相同的元素名时引发命名冲突比如A文档使用了&lt;name&gt;标签,B文档也使用了&lt;name&gt;标签，这个就会产生命名冲突这个时候可以使用前缀来避免这种情况 &lt;前缀名:标签名&gt;&lt;h:table&gt;&lt;i:table&gt;&lt;g:address&gt;&lt;j:address&gt; XML命名空间 xmlns属性当在XML中使用前缀时，一个所谓的用于前缀的命名空间必须定义xmlns:前缀=&quot;URI&quot;当命名空间被定义在元素的开始标签中时，所有带有相同前缀的子元素都会与同一个命名空间相关联 example: &lt;root&gt; &lt;h:table xmlns:h=&quot;http://www.w3.org/TR/html4/&quot;&gt; &lt;h:tr&gt; &lt;h:td&gt;Apples&lt;/h:td&gt; &lt;h:td&gt;Bananas&lt;/h:td&gt; &lt;/h:tr&gt; &lt;/h:table&gt; &lt;f:table xmlns:f=&quot;http://www.w3cschool.cc/furniture&quot;&gt; &lt;f:name&gt;African Coffee Table&lt;/f:name&gt; &lt;f:width&gt;80&lt;/f:width&gt; &lt;f:length&gt;120&lt;/f:length&gt; &lt;/f:table&gt; &lt;/root&gt; 默认的命名空间xmlne=:namespaceURI 注：URI(Uniform Resource Identifier)统一资源标识符最常用的URI是用来标识因特网域名地址的统一资源定位器(URL)]]></content>
      <categories>
        <category>coding</category>
      </categories>
      <tags>
        <tag>XML</tag>
        <tag>namespace</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于markdown中代码块的一个小问题]]></title>
    <url>%2Fhfuter7712.github.io%2F2019%2F07%2F29%2FmarkdownCodeBlock%2F</url>
    <content type="text"><![CDATA[刚刚在折腾博客的时候，写日志嘛，然后有一段代码块需要放进来，用过markdown的人都知道代码块是用三个连续的引号来搞定的但是我刚刚就遇到一个问题就是markdown预览器中的界面和博客界面不一定是相同的在经过一系列尝试之后，这样的格式是正确的引号引号引号 在这一片空白区域输入你的代码块，该怎么缩进怎么缩进 引号引号引号 引号不需要tab的，我那个只要一tab在markdown预览里面就像是一行代码块，但是gds操作后在上网去看博客却发现是一团糟所以还是那句老话，请以实物为准发完博客记得去博客上看看效果]]></content>
      <categories>
        <category>coding</category>
      </categories>
      <tags>
        <tag>markdown</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[XML可扩展标记语言基础学习]]></title>
    <url>%2Fhfuter7712.github.io%2F2019%2F07%2F29%2FxmlLearn1%2F</url>
    <content type="text"><![CDATA[XML(EXtensible Markup Language)XML的设计宗旨是传输数据而不是显示数据XML标签没有被预定义，需要自行定义标签XML是W3C的推荐标准一般来说XML用于传输数据，HTML用于格式化并显示数据一个XML文档的第一行是一个XML声明,定义XML的版本和所使用的编码&lt;?xml version=&quot;1.0&quot; encoding = &quot;UTF-8&quot;?&gt;下一行描述文档的根元素&lt;note&gt;接下来描述子元素 ，并在最后一行定义根元素的结尾由于具有根元素以及其子元素的特征，因此XML文档形成一种树结构 XML必须包含根元素所有的元素都必须有关闭标签（这里提到一点，HTML的部分标签可以没有关闭标签，如,但是XML中都必须有关闭标签）XML标签对大小写敏感XML属性值必须加引号&lt;note date=&quot;12/11/2018&quot;&gt; 实体引用理解:因为XML本身语法的原因，在XML中的部分符号需要用特定的字段代替，就好比在某些语言里引号”要用”/代替一样&amp;lt; &lt; 大于号&amp;gt; &gt; 小于号&amp;amp; &amp; 连接号&amp;apos; &#39; 单引号&amp;quat; &quot; 双引号 XML中的注释（和HTML一样）&lt;!-- This is a comment --&gt;在XML中，空格会被保留（在HTML中，多个连续的空格字符会被裁剪为1个） XML命名规则 名称可以字母，数字以及其他字符 名称不能以数字或者标点符号开始 名称不能以xml,XML,Xml等一系列字段开始 名称不能包含空格 XML是可扩展的 XML中的属性值必须被引号保卫，不过可以单引号双引号都能使用suggestion:XML中应避免使用属性，尽量使用标签reason: 属性不能包含多个值 属性不能包含树结构 属性不容易扩展example: 12345678910111213&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;note&gt; &lt;to&gt;Tove&lt;/to&gt; &lt;from&gt;Jani&lt;/from&gt; &lt;heading&gt;Reminder&lt;/heading&gt; &lt;body&gt;Don&apos;t forget me this weekend!&lt;/body&gt; &lt;/note&gt; XML验证器链接: https://www.runoob.com/xml/xml-validator.html教程链接:https://www.runoob.com/xml/xml-tutorial.html]]></content>
      <categories>
        <category>coding</category>
      </categories>
      <tags>
        <tag>XML</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SQL指令学习]]></title>
    <url>%2Fhfuter7712.github.io%2F2019%2F07%2F28%2FsqlLearn%2F</url>
    <content type="text"><![CDATA[SELECT - 从数据库中提取数据UPDATE - 更新数据库中的数据DELETE - 从数据库中删除数据INSERT INTO - 向数据库中插入新数据CREATE DATABASE - 创建新数据库ALTER DATABASE - 修改数据库CREATE TABLE - 创建新表ALTER TABLE - 变更（改变）数据库表DROP TABLE - 删除表CREATE INDEX - 创建索引（搜索键）DROP INDEX - 删除索引 SQL SELECT SELECT语句用于从数据库中选取数据结果被存储在一个结果表中，称为结果集 SQL SELECT DISTINCT SELECT DISTINCT country FROM Websites;在表中，一个列可能会包含多个重复值，有时您也许希望仅仅列出不同（distinct）的值。DISTINCT 关键词用于返回唯一不同的值 SQL WHERE WHERE子句用于提取那些满足指定条件的记录 SQL ORDER BY 关键字ORDER BY关键字用于对结果集按照一个列或者多个列进行排序。ORDER BY 关键字默认按照升序对记录进行排序。如果需要按照降序对记录进行排序您可以使用 DESC 关键字DESC关键字 降序 update 警告！在更新记录时要格外小心！在上面的实例中，如果我们省略了 WHERE 子句，如下所示：UPDATE Websites SET alexa=&#39;5000&#39;, country=&#39;USA&#39;执行以上代码会将 Websites 表中所有数据的 alexa 改为 5000，country 改为 USA。执行没有 WHERE 子句的 UPDATE 要慎重，再慎重]]></content>
      <categories>
        <category>coding</category>
      </categories>
      <tags>
        <tag>数据库</tag>
        <tag>sql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[暑假回归+hexo:command no found解决]]></title>
    <url>%2Fhfuter7712.github.io%2F2019%2F07%2F27%2Fsummer%20return%2F</url>
    <content type="text"><![CDATA[暑假闲着无聊，突然想到自己还有个博客2333就回来了，这次打算把印象笔记上的那一大坨笔记都搬上来，以后开始日常更新了，这可是项技术活啊，哈哈然而打开博客目录就发现在根目录下git bash 输入hexo相关指令竟然跟我说 hexo:Command not found这怎么可能，在检查了npm和node的安装情况后 (方法来自https://blog.csdn.net/kittowang/article/details/56011794 author:kittowang )$ node -v$ npm -v检查版本号，然后再检查hexo的文件是否安装，都没发现有问题最后找到问题根源，是环境变量中的Path未设置，只要在环境变量中设置Path添加一个变量设置为根目录/node_modules/.bin即可不过以前好像也没有配置环境变量，那以前是怎么行得通的，真是玄学]]></content>
      <categories>
        <category>coding</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>个人博客</tag>
        <tag>环境变量</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[课程设计，completed！]]></title>
    <url>%2Fhfuter7712.github.io%2F2019%2F05%2F16%2F996%2F</url>
    <content type="text"><![CDATA[前段日子为了写课程设计代码可谓是费尽心思，都没有时间写博客了，本来在上学期选（抢）课设题目的时候就没搞到好题目，分不算低，但是技术含量不是很高，就是一个以堆为基础的优先队列的作业系统而已，后来临近验收，脑洞大开又想写一个。第一次选了一个电梯题目，简单粗暴没有提示只有要求，至少4台电梯，十层楼，每层楼0~15人随机上下，要求实现调度，本人只写出了数据结构和显示函数就放弃了，因为太菜不知道怎么实现调度，想了好久最后还是放弃了第二次选了B+树，B+树和B树都是数据库的基础，因此想趁机提前学习一下相关基础，奈何本人学艺不精，终究还是失败了，又转战B树，这回好歹看上去好搞了一点，在网上查阅了大量资料后，凭着借鉴和乱写大致写出了B树的基本操作，真的不容易啊2333，B树真的是一生痛，没有之一，写B树的删除我曾经连着3个小时盯着屏幕debug和画图验证。总归还好最后课设验收给了个海星的分数没有让我这个菜鸡的自信心受到进一步打击，但是通过这次课设我也看到了自身的弱点，满满的全是弱点，一触即溃，这样下去以后读研工作会有大麻烦的，虽然我一直秉承学习技术优先，但是秉承了这么久好像也没有学到什么精髓，学的全是基础，一旦要求高起来真的是束手无策。连续两周每天十小时以上的敲代码真的把我累坏了，最近睡觉都是一倒在床铺上就秒入睡的，还会做一些莫名其妙的怪梦，感觉一个比较恐怖的是有时候做那种突然前面有一个深渊我踩空然后惊醒同时发现自己在踢腿23333，太迷幻了，还是要注意身体啊菜鸡的学习还需继续，帝牙卢卡赐予我时间的力量！（中二病发作）]]></content>
      <categories>
        <category>日常</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>课程设计</tag>
        <tag>B树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[本体初步了解]]></title>
    <url>%2Fhfuter7712.github.io%2F2019%2F04%2F29%2Fontology%2F</url>
    <content type="text"><![CDATA[category：ontology/knowledge graph 本体 通常在一个本体中主要定义以下几个组成部分 类:领域和任务中的概念，通常使用分类法组织在一起 关系：领域概念之间的一种联系类型 函数：一种特殊的关系，在关系的N个元素中前N-1个元素决定了第N各元素 公理：一种关于事实地语句，如果学生选修了课程A和B，那么他是二年级学生 实例：表示特定的元素，如Peter是学生的实例 XML DTDs 和 XML Schemas 对于在两个遵守预先定义的协议的应用是足够的但是由于它们缺乏语义使得难以利用新的XML词汇来执行任务而 RDF 和 RDF Schema 通过允许联系与标识符的简单语义来着手处理这个问题使用 RDF Schema :一个人能定义具有多个子类和超类的类，定义具有子属性，领域和范围的属性然而为了达到在众多独自发展和管理的模式之间的交互操作，丰富的语义是必须的 ###传统的本体表示语言### Ontolingua基于 KIF (Knowledge Interchange Format) 和 FO (Frame Ontology) 的语言 KIF(Knowledge Interchange Format)主要功能：解决知识表示语言的异质性，定义对象，函数和关系，基于一阶谓词逻辑，并含有一个前缀符号此外它还可以表示元知识的非单调推理规则，具有描述性语义 OKBC（Open Knowledge Base Connectivity) 协议具体描述了一个协议，对其底层的知识表示系统做了假定，对于支持语言共享的语言是一个有力的补充 GFP知识模型能够用以对象为中心的方法来表示知识还提供了一个问答界面，以使用 OKBC协议访问知识库 OCML一种基于框架的语言能够表示诸如关系，函数规则，类和实例等项还另外增加了一些逻辑机制以增强推理的有效性与标准相容 Flogic综合了基于框架的语言和一阶谓词逻辑能够清楚明白的说明面向对象和基于框架语言的大多数结构方面在推理演绎方面，Flogic有一个理论模型和一个完整有效的基于决策的证明机制 LOOM提供了明确定义而且表达能力较强的模型描述语言能描述定义，规则，事实和缺省规则等，提供了有效的推理机制，能利用向前推理，语义一致化和面向对象的真值为维护等技术实现推理，提供了变成范例，产生式规则范例和面向对象范例 ###传统的本体表示语言### OntolinguaKSL开发的一个本体开发环境，包括一个服务器和一个表示语言1.使用 Ontolingua 语言的扩展版本作为半形式化的表示语言2.使用满足面向对象的框架视图表示和浏览知识，使用类/子类的方式展现类层次3.使用户能迅速地从模块库中组合新本体4.为用户提供三种与Ontolingua服务器交互的主要模式5.支持合作开发本体，观察从一个本体转变为另一个本体的动作集合，方便的监视本体的变化，通过检查槽，槽值，面，面值确保他们满足已知的限制的方法，可分析本体的一致性 参考：华中师范大学 舒江波 硕士学位论文《本体库的构建方法和应用研究》链接来源:点击此处]]></content>
      <categories>
        <category>大创</category>
      </categories>
      <tags>
        <tag>知识图谱</tag>
        <tag>本体</tag>
        <tag>XML</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于在进行generate以及d操作后仍然无法更新文章的解决]]></title>
    <url>%2Fhfuter7712.github.io%2F2019%2F04%2F27%2Fexperience1%2F</url>
    <content type="text"><![CDATA[刚刚折腾了半天，如果进来而且想要搞博客的大佬们在进行了 hexo g hexo d 博客主页面仍然没有更新文章的话 检查是否进行了如下操作 –在博客主文件夹下进行git bash，然后输入 npm install hexo-deployer-git --save 之后再进行常规操作，测试是否有效，本人亲测有效 （方法来源：Z皓）来源链接]]></content>
      <categories>
        <category>coding</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>个人博客</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[return!]]></title>
    <url>%2Fhfuter7712.github.io%2F2019%2F04%2F27%2Freturn%2F</url>
    <content type="text"><![CDATA[昨天刚测完体测，个子贼高郑老师的带领下进行了引体向上，50米和1000米的测试，引体向上很遗憾由于自重较大加上牵引力不足因此只完成了三个，50米跟着ass跑倒还过得去，1000米大集团进行测试，和ass一组，起跑慢了0.7s在队伍中间蹭风，所幸体力过得去很快到了第二，第一名依旧是ass，不愧是本班体委，到最后还是没追上，成绩马马虎虎过得去，也算是圆满了8 昨天晚上日常训练，骑着车绕了校园几圈，走了几个技术点，下了几段楼梯，其实也就那样，克服了心理恐惧，发现这几个所谓技术点也就看着唬人，其实没那么恐怖，不过好又多旁边的大跨度楼梯，计算机楼前的连续楼梯以及兔跳还是没学会，非得我上锁么！锁鞋很贵的，不过上了锁也美滋滋，而且速度和熟练度也上升的很快 昨天晚上熬到十二点半因为运动过度直接倒床上睡了，第二天八点半起来收拾了一下就去了自习室，回顾了一下git和hexo的操作（上一次搞这玩意大物实验课还没开始),也是挺有趣的，与其天天在空间发那几十个文字，还不如自己搞个博客把这些都存储下来。 中午收到赖师傅的消息，他带着他的速降车要去敬亭山速降，最近疯狂开发自己的我当然按捺不住自己午觉也不睡就去北门会和，骑了一小会就到了敬亭山下，俗话说速降速降，上山两小时，下来两分钟，果不其然，从赛道上去俩人推着坦克达和am重车疯狂向上，花了1小时57分钟到达所谓起点——一段楼梯，我在半路停下了，这么连续的楼梯以我那破技术估计够呛，于是赖师傅扛着am又向上走了一段，然后进入了短暂的休息。。在山顶一声吼叫后，am重车从山顶踏着楼梯一路向下飞驰，我拍完视频后也紧随其后。。。准确来说是人都看不到，26轮径加上我那烂技术这个楼梯完全hold不住，干脆直接推车，进入主赛道，赖师傅又一次消失在我眼前。。。我就小心的下，遇到飞包，小的就推把莽过去，大的直接绕过去，现在的我还完全不敢飞车，速降全程下坡没有给你喘息的余地，偶尔还给你来个转弯下坡，表示刹车完全不够用，终于有一段我稍稍松开了刹车，速度瞬间起来了，我估计有33左右，路上一堆小石子，一压到小石子就很容易侧滑，但是今天貌似苍天有眼，我竟然把持住了，全程没有摔车，狼狈的推车推过了技术难点乱石堆，然后继续下行，这条赛道已经荒废三年了，路上很多地方都长了草，有些路段甚至看不清，凭借着毅力和鸭子最终下到了我们出发的地方，一看时间，2分37s，emmmm。。还没爽够，说真的，但是那些包我是真的不敢飞，真的太高了，一摔妥妥进ICU，跟996有的一拼]]></content>
      <categories>
        <category>cycling</category>
      </categories>
      <tags>
        <tag>骑行</tag>
        <tag>速降</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[aaa.hexo]]></title>
    <url>%2Fhfuter7712.github.io%2F2019%2F02%2F22%2Faaa-hexo%2F</url>
    <content type="text"><![CDATA[bug]]></content>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2Fhfuter7712.github.io%2F2019%2F02%2F22%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
